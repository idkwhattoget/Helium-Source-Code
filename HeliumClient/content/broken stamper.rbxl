<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.morblox.us/roblox.xsd" version="4">
	<External>null</External>
	<External>nil</External>
	<Item class="Workspace" referent="RBX0">
		<Properties>
			<Ref name="CurrentCamera">RBX1</Ref>
			<double name="DistributedGameTime">0</double>
			<CoordinateFrame name="ModelInPrimary">
				<X>0</X>
				<Y>0</Y>
				<Z>0</Z>
				<R00>1</R00>
				<R01>0</R01>
				<R02>0</R02>
				<R10>0</R10>
				<R11>1</R11>
				<R12>0</R12>
				<R20>0</R20>
				<R21>0</R21>
				<R22>1</R22>
			</CoordinateFrame>
			<string name="Name">Workspace</string>
			<Ref name="PrimaryPart">null</Ref>
		</Properties>
		<Item class="Camera" referent="RBX1">
			<Properties>
				<Ref name="CameraSubject">null</Ref>
				<token name="CameraType">0</token>
				<CoordinateFrame name="CoordinateFrame">
					<X>-1339.05261</X>
					<Y>816.051331</Y>
					<Z>1165.97778</Z>
					<R00>0.547405243</R00>
					<R01>0.50025475</R01>
					<R02>-0.670889497</R02>
					<R10>1.49011612e-008</R10>
					<R11>0.801667392</R11>
					<R12>0.597770393</R12>
					<R20>0.83686769</R20>
					<R21>-0.327222645</R21>
					<R22>0.438836932</R22>
				</CoordinateFrame>
				<float name="FieldOfView">70</float>
				<CoordinateFrame name="Focus">
					<X>-1337.71082</X>
					<Y>814.855774</Y>
					<Z>1165.1001</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">Camera</string>
			</Properties>
		</Item>
		<Item class="Terrain" referent="RBX2">
			<Properties>
				<bool name="Anchored">true</bool>
				<float name="BackParamA">-0.5</float>
				<float name="BackParamB">0.5</float>
				<token name="BackSurface">0</token>
				<token name="BackSurfaceInput">0</token>
				<float name="BottomParamA">-0.5</float>
				<float name="BottomParamB">0.5</float>
				<token name="BottomSurface">4</token>
				<token name="BottomSurfaceInput">0</token>
				<int name="BrickColor">194</int>
				<CoordinateFrame name="CFrame">
					<X>-2</X>
					<Y>126</Y>
					<Z>-2</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<bool name="CanCollide">true</bool>
				<string name="ClusterGridV2">&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#8;&#0;(&#255;8&#0;&#1;&#255;&#8;&#0;&#17;&#255;8&#0;&#0;&#255;&#3;&#224;( &#0;&#255;&#3;&#224;(&#255;8 &#1;&#255;&#3;&#224;&#17; &#1;&#255;&#3;&#224;&#17;&#255;8 (&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#30;`&#1;(!&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#1;&#0;&#31;(&#255;8!&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;!&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#1;&#1;&#31;&#17;&#255;8!(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;(&#255;@&#0;&#17;&#255;@&#0;</string>
				<float name="Elasticity">0.5</float>
				<float name="Friction">0.300000012</float>
				<float name="FrontParamA">-0.5</float>
				<float name="FrontParamB">0.5</float>
				<token name="FrontSurface">0</token>
				<token name="FrontSurfaceInput">0</token>
				<float name="LeftParamA">-0.5</float>
				<float name="LeftParamB">0.5</float>
				<token name="LeftSurface">0</token>
				<token name="LeftSurfaceInput">0</token>
				<bool name="Locked">true</bool>
				<token name="Material">256</token>
				<string name="Name">Terrain</string>
				<float name="Reflectance">0</float>
				<float name="RightParamA">-0.5</float>
				<float name="RightParamB">0.5</float>
				<token name="RightSurface">0</token>
				<token name="RightSurfaceInput">0</token>
				<Vector3 name="RotVelocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<float name="TopParamA">-0.5</float>
				<float name="TopParamB">0.5</float>
				<token name="TopSurface">3</token>
				<token name="TopSurfaceInput">0</token>
				<float name="Transparency">0</float>
				<Vector3 name="Velocity">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
				</Vector3>
				<Vector3 name="size">
					<X>2044</X>
					<Y>252</Y>
					<Z>2044</Z>
				</Vector3>
			</Properties>
		</Item>
		<Item class="Model" referent="RBX3">
			<Properties>
				<CoordinateFrame name="ModelInPrimary">
					<X>0</X>
					<Y>0</Y>
					<Z>0</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">StamperForAustiblox</string>
				<Ref name="PrimaryPart">null</Ref>
			</Properties>
			<Item class="Model" referent="RBX4">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Workspace</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX5">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">StarterGui</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX6">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">Lighting</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Model" referent="RBX7">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">AntiGreif</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="Humanoid" referent="RBX8">
						<Properties>
							<float name="Health">0</float>
							<float name="MaxHealth">0</float>
							<string name="Name">Humanoid</string>
							<token name="NameOcclusion">0</token>
							<float name="WalkSpeed">16</float>
						</Properties>
					</Item>
					<Item class="Part" referent="RBX9">
						<Properties>
							<bool name="Anchored">true</bool>
							<float name="BackParamA">-0.5</float>
							<float name="BackParamB">0.5</float>
							<token name="BackSurface">0</token>
							<token name="BackSurfaceInput">0</token>
							<float name="BottomParamA">-0.5</float>
							<float name="BottomParamB">0.5</float>
							<token name="BottomSurface">4</token>
							<token name="BottomSurfaceInput">0</token>
							<int name="BrickColor">1001</int>
							<CoordinateFrame name="CFrame">
								<X>-914.5</X>
								<Y>0.5</Y>
								<Z>1263.5</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="CanCollide">true</bool>
							<float name="Elasticity">0.5</float>
							<float name="Friction">0.300000012</float>
							<float name="FrontParamA">-0.5</float>
							<float name="FrontParamB">0.5</float>
							<token name="FrontSurface">0</token>
							<token name="FrontSurfaceInput">0</token>
							<float name="LeftParamA">-0.5</float>
							<float name="LeftParamB">0.5</float>
							<token name="LeftSurface">0</token>
							<token name="LeftSurfaceInput">0</token>
							<bool name="Locked">true</bool>
							<token name="Material">256</token>
							<string name="Name">Head</string>
							<float name="Reflectance">0</float>
							<float name="RightParamA">-0.5</float>
							<float name="RightParamB">0.5</float>
							<token name="RightSurface">0</token>
							<token name="RightSurfaceInput">0</token>
							<Vector3 name="RotVelocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<float name="TopParamA">-0.5</float>
							<float name="TopParamB">0.5</float>
							<token name="TopSurface">0</token>
							<token name="TopSurfaceInput">0</token>
							<float name="Transparency">0.899999976</float>
							<Vector3 name="Velocity">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
							</Vector3>
							<token name="formFactorRaw">1</token>
							<token name="shape">1</token>
							<Vector3 name="size">
								<X>1</X>
								<Y>1</Y>
								<Z>1</Z>
							</Vector3>
						</Properties>
						<Item class="Script" referent="RBX10">
							<Properties>
								<bool name="Disabled">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Script</string>
								<ProtectedString name="Source">wait (8) 
script.Parent.Parent:Remove()
</ProtectedString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Script" referent="RBX11">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FixDecals</string>
				<ProtectedString name="Source">game.Workspace.ChildAdded:connect(function(m)
&#9;num = 0
&#9;print(m.Name .. &quot; has been added&quot;)

wait(0.1)
&#9;for i,v in pairs(m:GetChildren()) do
&#9;&#9;if v:IsA(&quot;Decal&quot;) or v:IsA(&quot;Texture&quot;) then
&#9;&#9;&#9;print(&quot;Converting Decal&quot;)
&#9;&#9;&#9;v.Texture = (string.sub(string.gsub(v.Texture, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;end
&#9;&#9;for i,q in pairs(v:GetChildren()) do
&#9;&#9;&#9;if q:IsA(&quot;Decal&quot;) or q:IsA(&quot;Texture&quot;) then
&#9;&#9;&#9;print(&quot;Converting Subdecal&quot;)
&#9;&#9;&#9;&#9;q.Texture = (string.sub(string.gsub(q.Texture, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;for i,v in pairs(m:GetChildren()) do
&#9;&#9;if v:IsA(&quot;SpecialMesh&quot;)then
&#9;&#9;&#9;print(&quot;Converting Mesh&quot;)
&#9;&#9;&#9;v.MeshId = (string.sub(string.gsub(v.MeshId, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;&#9;v.TextureId = (string.sub(string.gsub(v.TextureId, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;end
&#9;&#9;for i,q in pairs(v:GetChildren()) do
&#9;&#9;&#9;if q:IsA(&quot;SpecialMesh&quot;) then
&#9;&#9;&#9;print(&quot;Converting Submesh&quot;)
&#9;&#9;&#9;&#9;q.MeshId = (string.sub(string.gsub(q.MeshId, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;&#9;&#9;q.TextureId = (string.sub(string.gsub(q.TextureId, &quot;pengin.xyz&quot;, &quot;pengin.xyz&quot;), 1, -1))
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end)</ProtectedString>
			</Properties>
		</Item>
	</Item>
	<Item class="StarterPack" referent="RBX12">
		<Properties>
			<string name="Name">StarterPack</string>
		</Properties>
		<Item class="Tool" referent="RBX13">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>-0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>-0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">ConfigTool</string>
				<Content name="TextureId"><url>http://www.pengin.xyz/asset/?id=59102714</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="LocalScript" referent="RBX14">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">ConfigurationLocal</string>
					<ProtectedString name="Source">print(&quot;SADlkjsdansadklnmsadkljndsakjndsakjnas&quot;)
-- general functions
function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end
function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
--[[
local RbxGui
if LoadLibrary then
&#9;--RbxGui = LoadLibrary(&quot;RbxGui&quot;)
&#9;RbxGui = game.Lighting:FindFirstChild(&quot;RbxGui&quot;):Clone()
else
&#9;return
end
]]
local RbxGui
--Because LoadLibrary is deprecated, we need to include all functions we use in here. :/
local t = {}

local function ScopedConnect(parentInstance, instance, event, signalFunc, syncFunc, removeFunc)
&#9;local eventConnection = nil

&#9;--Connection on parentInstance is scoped by parentInstance (when destroyed, it goes away)
&#9;local tryConnect = function()
&#9;&#9;if game:IsAncestorOf(parentInstance) then
&#9;&#9;&#9;--Entering the world, make sure we are connected/synced
&#9;&#9;&#9;if not eventConnection then
&#9;&#9;&#9;&#9;eventConnection = instance[event]:connect(signalFunc)
&#9;&#9;&#9;&#9;if syncFunc then syncFunc() end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--Probably leaving the world, so disconnect for now
&#9;&#9;&#9;if eventConnection then
&#9;&#9;&#9;&#9;eventConnection:disconnect()
&#9;&#9;&#9;&#9;if removeFunc then removeFunc() end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;--Hook it up to ancestryChanged signal
&#9;local connection = parentInstance.AncestryChanged:connect(tryConnect)
&#9;
&#9;--Now connect us if we&apos;re already in the world
&#9;tryConnect()
&#9;
&#9;return connection
end

local function getLayerCollectorAncestor(instance)
&#9;local localInstance = instance
&#9;while localInstance and not localInstance:IsA(&quot;LayerCollector&quot;) do
&#9;&#9;localInstance = localInstance.Parent
&#9;end
&#9;return localInstance
end

local function CreateButtons(frame, buttons, yPos, ySize)
&#9;local buttonNum = 1
&#9;local buttonObjs = {}
&#9;for i, obj in ipairs(buttons) do 
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot; .. buttonNum
&#9;&#9;button.Font = Enum.Font.Arial
&#9;&#9;button.FontSize = Enum.FontSize.Size18
&#9;&#9;button.AutoButtonColor = true
&#9;&#9;button.Modal = true
&#9;&#9;if obj[&quot;Style&quot;] then
&#9;&#9;&#9;button.Style = obj.Style
&#9;&#9;else
&#9;&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;end
&#9;&#9;if obj[&quot;ZIndex&quot;] then
&#9;&#9;&#9;button.ZIndex = obj.ZIndex
&#9;&#9;end
&#9;&#9;button.Text = obj.Text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.MouseButton1Click:connect(obj.Function)
&#9;&#9;button.Parent = frame
&#9;&#9;buttonObjs[buttonNum] = button

&#9;&#9;buttonNum = buttonNum + 1
&#9;end
&#9;local numButtons = buttonNum-1

&#9;if numButtons == 1 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.35, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.4,0,ySize.Scale, ySize.Offset)
&#9;elseif numButtons == 2 then
&#9;&#9;frame.Button1.Position = UDim2.new(0.1, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button1.Size = UDim2.new(.8/3,0, ySize.Scale, ySize.Offset)

&#9;&#9;frame.Button2.Position = UDim2.new(0.55, 0, yPos.Scale, yPos.Offset)
&#9;&#9;frame.Button2.Size = UDim2.new(.35,0, ySize.Scale, ySize.Offset)
&#9;elseif numButtons &gt;= 3 then
&#9;&#9;local spacing = .1 / numButtons
&#9;&#9;local buttonSize = .9 / numButtons

&#9;&#9;buttonNum = 1
&#9;&#9;while buttonNum &lt;= numButtons do
&#9;&#9;&#9;buttonObjs[buttonNum].Position = UDim2.new(spacing*buttonNum + (buttonNum-1) * buttonSize, 0, yPos.Scale, yPos.Offset)
&#9;&#9;&#9;buttonObjs[buttonNum].Size = UDim2.new(buttonSize, 0, ySize.Scale, ySize.Offset)
&#9;&#9;&#9;buttonNum = buttonNum + 1
&#9;&#9;end
&#9;end
end

local function setSliderPos(newAbsPosX,slider,sliderPosition,bar,steps)

&#9;local newStep = steps - 1 --otherwise we really get one more step than we want
&#9;local relativePosX = math.min(1, math.max(0, (newAbsPosX - bar.AbsolutePosition.X) / bar.AbsoluteSize.X ))
&#9;local wholeNum, remainder = math.modf(relativePosX * newStep)
&#9;if remainder &gt; 0.5 then
&#9;&#9;wholeNum = wholeNum + 1
&#9;end
&#9;relativePosX = wholeNum/newStep

&#9;local result = math.ceil(relativePosX * newStep)
&#9;if sliderPosition.Value ~= (result + 1) then --only update if we moved a step
&#9;&#9;sliderPosition.Value = result + 1
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end
&#9;
end

local function cancelSlide(areaSoak)
&#9;areaSoak.Visible = false
end

t.CreateStyledMessageDialog = function(title, message, style, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0, 165)
&#9;frame.Position = UDim2.new(0.25, 0, 0.5, -72.5)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound&#9;
&#9;
&#9;local styleImage = Instance.new(&quot;ImageLabel&quot;)
&#9;styleImage.Name = &quot;StyleImage&quot;
&#9;styleImage.BackgroundTransparency = 1
&#9;styleImage.Position = UDim2.new(0,5,0,15)
&#9;if style == &quot;error&quot; or style == &quot;Error&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;https://www.pengin.xyz/asset/?id=42565285&quot;
&#9;elseif style == &quot;notify&quot; or style == &quot;Notify&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 71, 0, 71)
&#9;&#9;styleImage.Image = &quot;https://www.pengin.xyz/asset/?id=42604978&quot;
&#9;elseif style == &quot;confirm&quot; or style == &quot;Confirm&quot; then
&#9;&#9;styleImage.Size = UDim2.new(0, 74, 0, 76)
&#9;&#9;styleImage.Image = &quot;https://www.pengin.xyz/asset/?id=42557901&quot;
&#9;else
&#9;&#9;return t.CreateMessageDialog(title,message,buttons)
&#9;end
&#9;styleImage.Parent = frame
&#9;
&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.TextStrokeTransparency = 0
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 80, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, -80, 0, 40)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextStrokeTransparency = 0
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 80, 0, 45)
&#9;messageLabel.Size = UDim2.new(0.95, -80, 0, 55)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0, 105), UDim.new(0, 40) )

&#9;return frame
end

t.CreateMessageDialog = function(title, message, buttons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Size = UDim2.new(0.5, 0, 0.5, 0)
&#9;frame.Position = UDim2.new(0.25, 0, 0.25, 0)
&#9;frame.Name = &quot;MessageDialog&quot;
&#9;frame.Active = true
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;Title&quot;
&#9;titleLabel.Text = title
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;titleLabel.Position = UDim2.new(0, 0, 0, 0)
&#9;titleLabel.Size = UDim2.new(1, 0, 0.15, 0)
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = Enum.FontSize.Size36
&#9;titleLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;titleLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;titleLabel.Parent = frame

&#9;local messageLabel = Instance.new(&quot;TextLabel&quot;)
&#9;messageLabel.Name = &quot;Message&quot;
&#9;messageLabel.Text = message
&#9;messageLabel.TextColor3 = Color3.new(221/255,221/255,221/255)
&#9;messageLabel.Position = UDim2.new(0.025, 0, 0.175, 0)
&#9;messageLabel.Size = UDim2.new(0.95, 0, .55, 0)
&#9;messageLabel.BackgroundTransparency = 1
&#9;messageLabel.Font = Enum.Font.Arial
&#9;messageLabel.FontSize = Enum.FontSize.Size18
&#9;messageLabel.TextWrap = true
&#9;messageLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;messageLabel.TextYAlignment = Enum.TextYAlignment.Top
&#9;messageLabel.Parent = frame

&#9;CreateButtons(frame, buttons, UDim.new(0.8,0), UDim.new(0.15, 0))

&#9;return frame
end

-- written by jmargh
-- to be used for the new settings menu
t.CreateScrollingDropDownMenu = function(onSelectedCallback, size, position, baseZ)
&#9;local maxVisibleList = 6
&#9;local baseZIndex = 0
&#9;if type(baseZ) == &apos;number&apos; then
&#9;&#9;baseZIndex = baseZ
&#9;end

&#9;local dropDownMenu = {}
&#9;local currentList = nil

&#9;local updateFunc = nil
&#9;local frame = Instance.new(&apos;Frame&apos;)
&#9;frame.Name = &quot;DropDownMenuFrame&quot;
&#9;frame.Size = size
&#9;frame.Position = position
&#9;frame.BackgroundTransparency = 1
&#9;dropDownMenu.Frame = frame

&#9;local currentSelectionName = Instance.new(&apos;TextButton&apos;)
&#9;currentSelectionName.Name = &quot;CurrentSelectionName&quot;
&#9;currentSelectionName.Size = UDim2.new(1, 0, 1, 0)
&#9;currentSelectionName.BackgroundTransparency = 1
&#9;currentSelectionName.Font = Enum.Font.SourceSansBold
&#9;currentSelectionName.FontSize = Enum.FontSize.Size18
&#9;currentSelectionName.TextXAlignment = Enum.TextXAlignment.Left
&#9;currentSelectionName.TextYAlignment = Enum.TextYAlignment.Center
&#9;currentSelectionName.TextColor3 = Color3.new(0.5, 0.5, 0.5)
&#9;currentSelectionName.TextWrap = true
&#9;currentSelectionName.ZIndex = baseZIndex
&#9;currentSelectionName.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;currentSelectionName.Text = &quot;Choose One&quot;
&#9;currentSelectionName.Parent = frame
&#9;dropDownMenu.CurrentSelectionButton = currentSelectionName

&#9;local icon = Instance.new(&apos;ImageLabel&apos;)
&#9;icon.Name = &quot;DropDownIcon&quot;
&#9;icon.Size = UDim2.new(0, 16, 0, 12)
&#9;icon.Position = UDim2.new(1, -17, 0.5, -6)
&#9;icon.Image = &apos;rbxasset://textures/ui/dropdown_arrow.png&apos;
&#9;icon.BackgroundTransparency = 1
&#9;icon.ZIndex = baseZIndex
&#9;icon.Parent = currentSelectionName

&#9;local listMenu = nil
&#9;local scrollingBackground = nil
&#9;local visibleCount = 0
&#9;local isOpen = false

&#9;local function onEntrySelected()
&#9;&#9;icon.Rotation = 0
&#9;&#9;scrollingBackground:TweenSize(UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
&#9;&#9;--
&#9;&#9;listMenu.ScrollBarThickness = 0
&#9;&#9;listMenu:TweenSize(UDim2.new(1, -16, 0, 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
&#9;&#9;&#9;if not isOpen then
&#9;&#9;&#9;&#9;listMenu.Visible = false
&#9;&#9;&#9;&#9;scrollingBackground.Visible = false
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;isOpen = false
&#9;end

&#9;currentSelectionName.MouseButton1Click:connect(function()
&#9;&#9;if not currentSelectionName.Active or #currentList == 0 then return end
&#9;&#9;if isOpen then
&#9;&#9;&#9;onEntrySelected()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;--
&#9;&#9;isOpen = true
&#9;&#9;icon.Rotation = 180
&#9;&#9;if listMenu then listMenu.Visible = true end
&#9;&#9;if scrollingBackground then scrollingBackground.Visible = true end
&#9;&#9;--
&#9;&#9;if scrollingBackground then
&#9;&#9;&#9;scrollingBackground:TweenSize(UDim2.new(1, 0, 0, visibleCount * 24 + 8), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true)
&#9;&#9;end
&#9;&#9;if listMenu then
&#9;&#9;&#9;listMenu:TweenSize(UDim2.new(1, -16, 0, visibleCount * 24), Enum.EasingDirection.InOut, Enum.EasingStyle.Sine, 0.15, true, function()
&#9;&#9;&#9;&#9;listMenu.ScrollBarThickness = 6
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end)

&#9;--[[ Public API ]]--
&#9;dropDownMenu.IsOpen = function()
&#9;&#9;return isOpen
&#9;end

&#9;dropDownMenu.Close = function()
&#9;&#9;onEntrySelected()
&#9;end

&#9;dropDownMenu.Reset = function()
&#9;&#9;isOpen = false
&#9;&#9;icon.Rotation = 0
&#9;&#9;listMenu.ScrollBarThickness = 0
&#9;&#9;listMenu.Size = UDim2.new(1, -16, 0, 24)
&#9;&#9;listMenu.Visible = false
&#9;&#9;scrollingBackground.Visible = false
&#9;end

&#9;dropDownMenu.SetVisible = function(isVisible)
&#9;&#9;if frame then
&#9;&#9;&#9;frame.Visible = isVisible
&#9;&#9;end
&#9;end

&#9;dropDownMenu.UpdateZIndex = function(newZIndexBase)
&#9;&#9;currentSelectionName.ZIndex = newZIndexBase
&#9;&#9;icon.ZIndex = newZIndexBase
&#9;&#9;if scrollingBackground then scrollingBackground.ZIndex = newZIndexBase + 1 end
&#9;&#9;if listMenu then
&#9;&#9;&#9;listMenu.ZIndex = newZIndexBase + 2
&#9;&#9;&#9;for _,child in pairs(listMenu:GetChildren()) do
&#9;&#9;&#9;&#9;child.ZIndex = newZIndexBase + 4
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;dropDownMenu.SetActive = function(isActive)
&#9;&#9;currentSelectionName.Active = isActive
&#9;end

&#9;dropDownMenu.SetSelectionText = function(text)
&#9;&#9;currentSelectionName.Text = text
&#9;end

&#9;dropDownMenu.CreateList = function(list)
&#9;&#9;currentSelectionName.Text = &quot;Choose One&quot;
&#9;&#9;if listMenu then listMenu:Destroy() end
&#9;&#9;if scrollingBackground then scrollingBackground:Destroy() end
&#9;&#9;--
&#9;&#9;currentList = list
&#9;&#9;local length = #list
&#9;&#9;visibleCount = math.min(maxVisibleList, length)
&#9;&#9;local listMenuOffset = visibleCount * 24

&#9;&#9;listMenu = Instance.new(&apos;ScrollingFrame&apos;)
&#9;&#9;listMenu.Name = &quot;ListMenu&quot;
&#9;&#9;listMenu.Size = UDim2.new(1, -16, 0, 24)
&#9;&#9;listMenu.Position = UDim2.new(0, 12, 0, 32)
&#9;&#9;listMenu.CanvasSize = UDim2.new(0, 0, 0, length * 24)
&#9;&#9;listMenu.BackgroundTransparency = 1
&#9;&#9;listMenu.BorderSizePixel = 0
&#9;&#9;listMenu.ZIndex = baseZIndex + 2
&#9;&#9;listMenu.Visible = false
&#9;&#9;listMenu.Active = true
&#9;&#9;listMenu.BottomImage = &apos;rbxasset://textures/ui/scroll-bottom.png&apos;
&#9;&#9;listMenu.MidImage = &apos;rbxasset://textures/ui/scroll-middle.png&apos;
&#9;&#9;listMenu.TopImage = &apos;rbxasset://textures/ui/scroll-top.png&apos;
&#9;&#9;listMenu.ScrollBarThickness = 0
&#9;&#9;listMenu.Parent = frame

&#9;&#9;scrollingBackground = Instance.new(&apos;TextButton&apos;)
&#9;&#9;scrollingBackground.Name = &quot;ScrollingBackground&quot;
&#9;&#9;scrollingBackground.Size = UDim2.new(1, 0, 0, currentSelectionName.AbsoluteSize.y)
&#9;&#9;scrollingBackground.Position = UDim2.new(0, 0, 0, 28)
&#9;&#9;scrollingBackground.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;&#9;scrollingBackground.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;&#9;scrollingBackground.ZIndex = baseZIndex + 1
&#9;&#9;scrollingBackground.Text = &quot;&quot;
&#9;&#9;scrollingBackground.Visible = false
&#9;&#9;scrollingBackground.AutoButtonColor = false
&#9;&#9;scrollingBackground.Parent = frame

&#9;&#9;for i = 1, length do
&#9;&#9;&#9;local entry = list[i]
&#9;&#9;&#9;local btn = Instance.new(&apos;TextButton&apos;)
&#9;&#9;&#9;btn.Name = entry
&#9;&#9;&#9;btn.Size = UDim2.new(1, 0, 0, 24)
&#9;&#9;&#9;btn.Position = UDim2.new(0, 0, 0, (i - 1) * 24)
&#9;&#9;&#9;btn.BackgroundTransparency = 0
&#9;&#9;&#9;btn.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;&#9;&#9;btn.BorderSizePixel = 0
&#9;&#9;&#9;btn.Font = Enum.Font.SourceSans
&#9;&#9;&#9;btn.FontSize = Enum.FontSize.Size18
&#9;&#9;&#9;btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
&#9;&#9;&#9;btn.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;btn.TextYAlignment = Enum.TextYAlignment.Center
&#9;&#9;&#9;btn.Text = entry
&#9;&#9;&#9;btn.ZIndex = baseZIndex + 4
&#9;&#9;&#9;btn.AutoButtonColor = false
&#9;&#9;&#9;btn.Parent = listMenu

&#9;&#9;&#9;btn.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;currentSelectionName.Text = btn.Text
&#9;&#9;&#9;&#9;onEntrySelected()
&#9;&#9;&#9;&#9;btn.Font = Enum.Font.SourceSans
&#9;&#9;&#9;&#9;btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
&#9;&#9;&#9;&#9;btn.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;&#9;&#9;&#9;onSelectedCallback(btn.Text)
&#9;&#9;&#9;end)

&#9;&#9;&#9;btn.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;btn.TextColor3 = Color3.new(1, 1, 1)
&#9;&#9;&#9;&#9;btn.BackgroundColor3 = Color3.new(0.75, 0.75, 0.75)
&#9;&#9;&#9;end)
&#9;&#9;&#9;btn.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;btn.TextColor3 = Color3.new(0.5, 0.5, 0.5)
&#9;&#9;&#9;&#9;btn.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end

&#9;return dropDownMenu
end

t.CreateDropDownMenu = function(items, onSelect, forRoblox, whiteSkin, baseZ)
&#9;local baseZIndex = 0
&#9;if (type(baseZ) == &quot;number&quot;) then
&#9;&#9;baseZIndex = baseZ
&#9;end
&#9;local width = UDim.new(0, 100)
&#9;local height = UDim.new(0, 32)

&#9;local xPos = 0.055
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;local textColor = Color3.new(1,1,1)
&#9;if (whiteSkin) then
&#9;&#9;textColor = Color3.new(0.5, 0.5, 0.5)
&#9;end
&#9;frame.Name = &quot;DropDownMenu&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(width, height)

&#9;local dropDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;dropDownMenu.Name = &quot;DropDownMenuButton&quot;
&#9;dropDownMenu.TextWrap = true
&#9;dropDownMenu.TextColor3 = textColor
&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;dropDownMenu.Font = Enum.Font.ArialBold
&#9;dropDownMenu.FontSize = Enum.FontSize.Size18
&#9;dropDownMenu.TextXAlignment = Enum.TextXAlignment.Left
&#9;dropDownMenu.TextYAlignment = Enum.TextYAlignment.Center
&#9;dropDownMenu.BackgroundTransparency = 1
&#9;dropDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;dropDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;dropDownMenu.Size = UDim2.new(1,0,1,0)
&#9;dropDownMenu.Parent = frame
&#9;dropDownMenu.ZIndex = 2 + baseZIndex

&#9;local dropDownIcon = Instance.new(&quot;ImageLabel&quot;)
&#9;dropDownIcon.Name = &quot;Icon&quot;
&#9;dropDownIcon.Active = false
&#9;if (whiteSkin) then
&#9;&#9;dropDownIcon.Image = &quot;rbxasset://textures/ui/dropdown_arrow.png&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,16,0,12)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-17,0.5, -6)
&#9;else
&#9;&#9;dropDownIcon.Image = &quot;https://www.pengin.xyz/asset/?id=45732894&quot;
&#9;&#9;dropDownIcon.Size = UDim2.new(0,11,0,6)
&#9;&#9;dropDownIcon.Position = UDim2.new(1,-11,0.5, -2)
&#9;end
&#9;dropDownIcon.BackgroundTransparency = 1
&#9;dropDownIcon.Parent = dropDownMenu
&#9;dropDownIcon.ZIndex = 2 + baseZIndex
&#9;
&#9;local itemCount = #items
&#9;local dropDownItemCount = #items
&#9;local useScrollButtons = false
&#9;if dropDownItemCount &gt; 6 then
&#9;&#9;useScrollButtons = true
&#9;&#9;dropDownItemCount = 6
&#9;end
&#9;
&#9;local droppedDownMenu = Instance.new(&quot;TextButton&quot;)
&#9;droppedDownMenu.Name = &quot;List&quot;
&#9;droppedDownMenu.Text = &quot;&quot;
&#9;droppedDownMenu.BackgroundTransparency = 1
&#9;--droppedDownMenu.AutoButtonColor = true
&#9;if (whiteSkin) then
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxRoundDropdownButton
&#9;else
&#9;&#9;droppedDownMenu.Style = Enum.ButtonStyle.RobloxButton
&#9;end
&#9;droppedDownMenu.Visible = false
&#9;droppedDownMenu.Active = true&#9;--Blocks clicks
&#9;droppedDownMenu.Position = UDim2.new(0,0,0,0)
&#9;droppedDownMenu.Size = UDim2.new(1,0, (1 + dropDownItemCount)*.8, 0)
&#9;droppedDownMenu.Parent = frame
&#9;droppedDownMenu.ZIndex = 2 + baseZIndex

&#9;local choiceButton = Instance.new(&quot;TextButton&quot;)
&#9;choiceButton.Name = &quot;ChoiceButton&quot;
&#9;choiceButton.BackgroundTransparency = 1
&#9;choiceButton.BorderSizePixel = 0
&#9;choiceButton.Text = &quot;ReplaceMe&quot;
&#9;choiceButton.TextColor3 = textColor
&#9;choiceButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;choiceButton.TextYAlignment = Enum.TextYAlignment.Center
&#9;choiceButton.BackgroundColor3 = Color3.new(1, 1, 1)
&#9;choiceButton.Font = Enum.Font.Arial
&#9;choiceButton.FontSize = Enum.FontSize.Size18
&#9;if useScrollButtons then
&#9;&#9;choiceButton.Size = UDim2.new(1,-13, .8/((dropDownItemCount + 1)*.8),0) 
&#9;else
&#9;&#9;choiceButton.Size = UDim2.new(1, 0, .8/((dropDownItemCount + 1)*.8),0) 
&#9;end
&#9;choiceButton.TextWrap = true
&#9;choiceButton.ZIndex = 2 + baseZIndex

&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = true
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 3 + baseZIndex

&#9;local dropDownSelected = false

&#9;local scrollUpButton 
&#9;local scrollDownButton
&#9;local scrollMouseCount = 0

&#9;local setZIndex = function(baseZIndex)
&#9;&#9;droppedDownMenu.ZIndex = baseZIndex +1
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.ZIndex = baseZIndex + 3
&#9;&#9;end
&#9;&#9;
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex + 2
&#9;&#9;&#9;&#9;elseif child.Name == &quot;ClickCaptureButton&quot; then
&#9;&#9;&#9;&#9;&#9;child.ZIndex = baseZIndex
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollBarPosition = 1
&#9;local updateScroll = function()
&#9;&#9;if scrollUpButton then
&#9;&#9;&#9;scrollUpButton.Active = scrollBarPosition &gt; 1 
&#9;&#9;end
&#9;&#9;if scrollDownButton then
&#9;&#9;&#9;scrollDownButton.Active = scrollBarPosition + dropDownItemCount &lt;= itemCount 
&#9;&#9;end

&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;if not children then return end

&#9;&#9;local childNum = 1&#9;&#9;&#9;
&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;if childNum &lt; scrollBarPosition or childNum &gt;= scrollBarPosition + dropDownItemCount then
&#9;&#9;&#9;&#9;&#9;obj.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;obj.Position = UDim2.new(0,0,((childNum-scrollBarPosition+1)*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;&#9;&#9;&#9;obj.Visible = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;obj.BackgroundTransparency = 1

&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;local toggleVisibility = function()
&#9;&#9;dropDownSelected = not dropDownSelected

&#9;&#9;areaSoak.Visible = not areaSoak.Visible
&#9;&#9;dropDownMenu.Visible = not dropDownSelected
&#9;&#9;droppedDownMenu.Visible = dropDownSelected
&#9;&#9;if dropDownSelected then
&#9;&#9;&#9;setZIndex(4 + baseZIndex)
&#9;&#9;else
&#9;&#9;&#9;setZIndex(2 + baseZIndex)
&#9;&#9;end
&#9;&#9;if useScrollButtons then
&#9;&#9;&#9;updateScroll()
&#9;&#9;end
&#9;end
&#9;droppedDownMenu.MouseButton1Click:connect(toggleVisibility)

&#9;local updateSelection = function(text)
&#9;&#9;local foundItem = false
&#9;&#9;local children = droppedDownMenu:GetChildren()
&#9;&#9;local childNum = 1
&#9;&#9;if children then
&#9;&#9;&#9;for i, obj in ipairs(children) do
&#9;&#9;&#9;&#9;if obj.Name == &quot;ChoiceButton&quot; then
&#9;&#9;&#9;&#9;&#9;if obj.Text == text then
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;&#9;foundItem = true&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;scrollBarPosition = childNum&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = Color3.new(90/255,142/255,233/255)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;obj.Font = Enum.Font.Arial
&#9;&#9;&#9;&#9;&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;obj.TextColor3 = textColor
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;childNum = childNum + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if not text then
&#9;&#9;&#9;dropDownMenu.Text = &quot;Choose One&quot;
&#9;&#9;&#9;scrollBarPosition = 1
&#9;&#9;else
&#9;&#9;&#9;if not foundItem then
&#9;&#9;&#9;&#9;error(&quot;Invalid Selection Update -- &quot; .. text)
&#9;&#9;&#9;end

&#9;&#9;&#9;if scrollBarPosition + dropDownItemCount &gt; itemCount + 1 then
&#9;&#9;&#9;&#9;scrollBarPosition = itemCount - dropDownItemCount + 1
&#9;&#9;&#9;end

&#9;&#9;&#9;dropDownMenu.Text = text
&#9;&#9;end
&#9;end
&#9;
&#9;local function scrollDown()
&#9;&#9;if scrollBarPosition + dropDownItemCount &lt;= itemCount then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition + 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;local function scrollUp()
&#9;&#9;if scrollBarPosition &gt; 1 then
&#9;&#9;&#9;scrollBarPosition = scrollBarPosition - 1
&#9;&#9;&#9;updateScroll()
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;return false
&#9;end
&#9;
&#9;if useScrollButtons then
&#9;&#9;--Make some scroll buttons
&#9;&#9;scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;&#9;scrollUpButton.BackgroundTransparency = 1
&#9;&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollUpButton.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),0)
&#9;&#9;scrollUpButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;
&#9;&#9;&#9;&#9;scrollUp()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollUp() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)

&#9;&#9;scrollUpButton.Parent = droppedDownMenu

&#9;&#9;scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;&#9;scrollDownButton.BackgroundTransparency = 1
&#9;&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;&#9;scrollDownButton.Position = UDim2.new(1,-11,1,-11)
&#9;&#9;scrollDownButton.Parent = droppedDownMenu
&#9;&#9;scrollDownButton.MouseButton1Click:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseLeave:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1
&#9;&#9;&#9;end)
&#9;&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;scrollMouseCount = scrollMouseCount + 1

&#9;&#9;&#9;&#9;scrollDown()
&#9;&#9;&#9;&#9;local val = scrollMouseCount
&#9;&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;&#9;while val == scrollMouseCount do
&#9;&#9;&#9;&#9;&#9;if scrollDown() == false then
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(0.1)
&#9;&#9;&#9;&#9;end&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)&#9;

&#9;&#9;local scrollbar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;&#9;scrollbar.BackgroundTransparency = 1
&#9;&#9;scrollbar.Size = UDim2.new(0, 18, (dropDownItemCount*.8)/((dropDownItemCount+1)*.8), -(17) - 11 - 4)
&#9;&#9;scrollbar.Position = UDim2.new(1,-11,(1*.8)/((dropDownItemCount+1)*.8),17+2)
&#9;&#9;scrollbar.Parent = droppedDownMenu
&#9;end

&#9;for i,item in ipairs(items) do
&#9;&#9;-- needed to maintain local scope for items in event listeners below
&#9;&#9;local button = choiceButton:clone()
&#9;&#9;if forRoblox then
&#9;&#9;&#9;button.RobloxLocked = true
&#9;&#9;end&#9;&#9;
&#9;&#9;button.Text = item
&#9;&#9;button.Parent = droppedDownMenu
&#9;&#9;if (whiteSkin) then
&#9;&#9;&#9;button.TextColor3 = textColor
&#9;&#9;end

&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1

&#9;&#9;&#9;updateSelection(item)
&#9;&#9;&#9;onSelect(item)

&#9;&#9;&#9;toggleVisibility()
&#9;&#9;end)
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;--Add Highlight&#9;
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)

&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;--Remove Highlight
&#9;&#9;&#9;if (not whiteSkin) then
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)
&#9;end

&#9;--This does the initial layout of the buttons&#9;
&#9;updateScroll()
&#9;
&#9;frame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getLayerCollectorAncestor(frame)
&#9;&#9;end
&#9;end)

&#9;dropDownMenu.MouseButton1Click:connect(toggleVisibility)
&#9;areaSoak.MouseButton1Click:connect(toggleVisibility)
&#9;return frame, updateSelection
end

t.CreatePropertyDropDownMenu = function(instance, property, enum)

&#9;local items = enum:GetEnumItems()
&#9;local names = {}
&#9;local nameToItem = {}
&#9;for i,obj in ipairs(items) do
&#9;&#9;names[i] = obj.Name
&#9;&#9;nameToItem[obj.Name] = obj
&#9;end

&#9;local frame
&#9;local updateSelection
&#9;frame, updateSelection = t.CreateDropDownMenu(names, function(text) instance[property] = nameToItem[text] end)

&#9;ScopedConnect(frame, instance, &quot;Changed&quot;, 
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == property then
&#9;&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;&#9;end
&#9;&#9;end,
&#9;&#9;function()
&#9;&#9;&#9;updateSelection(instance[property].Name)
&#9;&#9;end)

&#9;return frame
end

t.GetFontHeight = function(font, fontSize)
&#9;if font == nil or fontSize == nil then
&#9;&#9;error(&quot;Font and FontSize must be non-nil&quot;)
&#9;end
&#9;
&#9;local fontSizeInt = tonumber(fontSize.Name:match(&quot;%d+&quot;)) -- Clever hack to extract the size from the enum itself.

&#9;if font == Enum.Font.Legacy then -- Legacy has a 50% bigger size.
&#9;&#9;return math.ceil(fontSizeInt*1.5)
&#9;else -- Size is literally just the fontSizeInt
&#9;&#9;return fontSizeInt
&#9;end
end

local function layoutGuiObjectsHelper(frame, guiObjects, settingsTable)
&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;local pixelsRemaining = frame.AbsoluteSize.Y
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if child:IsA(&quot;TextLabel&quot;) or child:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;local isLabel = child:IsA(&quot;TextLabel&quot;)
&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;end
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, pixelsRemaining)

&#9;&#9;&#9;if child.TextFits and child.TextBounds.Y &lt; pixelsRemaining then
&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextLabelSizePadY&quot;])
&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.TextBounds.Y + settingsTable[&quot;TextButtonSizePadY&quot;])
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;while not child.TextFits do
&#9;&#9;&#9;&#9;&#9;child.Size = UDim2.new(child.Size.X.Scale, child.Size.X.Offset, 0, child.AbsoluteSize.Y + 1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y&#9;&#9;

&#9;&#9;&#9;&#9;if isLabel then
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextLabelPositionPadY&quot;]
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - settingsTable[&quot;TextButtonPositionPadY&quot;]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;pixelsRemaining = -1
&#9;&#9;&#9;end&#9;&#9;&#9;

&#9;&#9;else
&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;child.Visible = (pixelsRemaining &gt;= 0)
&#9;&#9;end
&#9;end
end

t.LayoutGuiObjects = function(frame, guiObjects, settingsTable)
&#9;if not frame:IsA(&quot;GuiObject&quot;) then
&#9;&#9;error(&quot;Frame must be a GuiObject&quot;)
&#9;end
&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;if not child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements that are layed out must be of type GuiObject&quot;)
&#9;&#9;end
&#9;end

&#9;if not settingsTable then
&#9;&#9;settingsTable = {}
&#9;end

&#9;if not settingsTable[&quot;TextLabelSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelSizePadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextLabelPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextLabelPositionPadY&quot;] = 0
&#9;end
&#9;if not settingsTable[&quot;TextButtonSizePadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonSizePadY&quot;] = 12
&#9;end
&#9;if not settingsTable[&quot;TextButtonPositionPadY&quot;] then
&#9;&#9;settingsTable[&quot;TextButtonPositionPadY&quot;] = 2
&#9;end

&#9;--Wrapper frame takes care of styled objects
&#9;local wrapperFrame = Instance.new(&quot;Frame&quot;)
&#9;wrapperFrame.Name = &quot;WrapperFrame&quot;
&#9;wrapperFrame.BackgroundTransparency = 1
&#9;wrapperFrame.Size = UDim2.new(1,0,1,0)
&#9;wrapperFrame.Parent = frame

&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;child.Parent = wrapperFrame
&#9;end

&#9;local recalculate = function()
&#9;&#9;wait()
&#9;&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
&#9;end
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(recalculate)

&#9;layoutGuiObjectsHelper(wrapperFrame, guiObjects, settingsTable)
end


t.CreateSlider = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 4
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local bar = Instance.new(&quot;TextButton&quot;)
&#9;bar.Text = &quot;&quot;
&#9;bar.AutoButtonColor = false
&#9;bar.Name = &quot;Bar&quot;
&#9;bar.BackgroundColor3 = Color3.new(0,0,0)
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width,0,5)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,5)
&#9;end
&#9;bar.BorderColor3 = Color3.new(95/255,95/255,95/255)
&#9;bar.ZIndex = 2
&#9;bar.Parent = sliderGui
&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end
&#9;
&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/Slider.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-10)
&#9;slider.Size = UDim2.new(0,20,0,20)
&#9;slider.ZIndex = 3
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)
&#9;
&#9;return sliderGui, sliderPosition, sliderSteps

end



t.CreateSliderNew = function(steps,width,position)
&#9;local sliderGui = Instance.new(&quot;Frame&quot;)
&#9;sliderGui.Size = UDim2.new(1,0,1,0)
&#9;sliderGui.BackgroundTransparency = 1
&#9;sliderGui.Name = &quot;SliderGui&quot;
&#9;
&#9;local sliderSteps = Instance.new(&quot;IntValue&quot;)
&#9;sliderSteps.Name = &quot;SliderSteps&quot;
&#9;sliderSteps.Value = steps
&#9;sliderSteps.Parent = sliderGui
&#9;
&#9;local areaSoak = Instance.new(&quot;TextButton&quot;)
&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;areaSoak.Text = &quot;&quot;
&#9;areaSoak.BackgroundTransparency = 1
&#9;areaSoak.Active = false
&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;areaSoak.Visible = false
&#9;areaSoak.ZIndex = 6
&#9;
&#9;sliderGui.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;areaSoak.Parent = nil
&#9;&#9;else
&#9;&#9;&#9;areaSoak.Parent = getLayerCollectorAncestor(sliderGui)
&#9;&#9;end
&#9;end)
&#9;
&#9;local sliderPosition = Instance.new(&quot;IntValue&quot;)
&#9;sliderPosition.Name = &quot;SliderPosition&quot;
&#9;sliderPosition.Value = 0
&#9;sliderPosition.Parent = sliderGui
&#9;
&#9;local id = math.random(1,100)
&#9;
&#9;local sliderBarImgHeight = 7
&#9;local sliderBarCapImgWidth = 4

&#9;local bar = Instance.new(&quot;ImageButton&quot;)
&#9;bar.BackgroundTransparency = 1
&#9;bar.Image = &quot;rbxasset://textures/ui/Slider-BKG-Center.png&quot;
&#9;bar.Name = &quot;Bar&quot;
&#9;local displayWidth = 200
&#9;if type(width) == &quot;number&quot; then
&#9;&#9;bar.Size = UDim2.new(0,width - (sliderBarCapImgWidth * 2),0,sliderBarImgHeight)
&#9;&#9;displayWidth = width - (sliderBarCapImgWidth * 2)
&#9;else
&#9;&#9;bar.Size = UDim2.new(0,200,0,sliderBarImgHeight)
&#9;end
&#9;bar.ZIndex = 3
&#9;bar.Parent = sliderGui&#9;
&#9;if position[&quot;X&quot;] and position[&quot;X&quot;][&quot;Scale&quot;] and position[&quot;X&quot;][&quot;Offset&quot;] and position[&quot;Y&quot;] and position[&quot;Y&quot;][&quot;Scale&quot;] and position[&quot;Y&quot;][&quot;Offset&quot;] then
&#9;&#9;bar.Position = position
&#9;end

&#9;local barLeft = bar:clone()
&#9;barLeft.Name = &quot;BarLeft&quot;
&#9;barLeft.Image = &quot;rbxasset://textures/ui/Slider-BKG-Left-Cap.png&quot;
&#9;barLeft.Size = UDim2.new(0, sliderBarCapImgWidth, 0, sliderBarImgHeight)
&#9;barLeft.Position = UDim2.new(position.X.Scale, position.X.Offset - sliderBarCapImgWidth, position.Y.Scale, position.Y.Offset)
&#9;barLeft.Parent = sliderGui&#9;
&#9;barLeft.ZIndex = 3

&#9;local barRight = barLeft:clone()
&#9;barRight.Name = &quot;BarRight&quot;
&#9;barRight.Image = &quot;rbxasset://textures/ui/Slider-BKG-Right-Cap.png&quot;
&#9;barRight.Position = UDim2.new(position.X.Scale, position.X.Offset + displayWidth, position.Y.Scale, position.Y.Offset)
&#9;barRight.Parent = sliderGui&#9;

&#9;local fillLeft = barLeft:clone()
&#9;fillLeft.Name = &quot;FillLeft&quot;
&#9;fillLeft.Image = &quot;rbxasset://textures/ui/Slider-Fill-Left-Cap.png&quot;
&#9;fillLeft.Parent = sliderGui&#9;
&#9;fillLeft.ZIndex = 4

&#9;local fill = fillLeft:clone()
&#9;fill.Name = &quot;Fill&quot;
&#9;fill.Image = &quot;rbxasset://textures/ui/Slider-Fill-Center.png&quot;
&#9;fill.Parent = bar&#9;
&#9;fill.ZIndex = 4
&#9;fill.Position = UDim2.new(0, 0, 0, 0)
&#9;fill.Size = UDim2.new(0.5, 0, 1, 0)


--&#9;bar.Visible = false

&#9;local slider = Instance.new(&quot;ImageButton&quot;)
&#9;slider.Name = &quot;Slider&quot;
&#9;slider.BackgroundTransparency = 1
&#9;slider.Image = &quot;rbxasset://textures/ui/slider_new_tab.png&quot;
&#9;slider.Position = UDim2.new(0,0,0.5,-14)
&#9;slider.Size = UDim2.new(0,28,0,28)
&#9;slider.ZIndex = 5
&#9;slider.Parent = bar
&#9;
&#9;local areaSoakMouseMoveCon = nil
&#9;
&#9;areaSoak.MouseLeave:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;areaSoak.MouseButton1Up:connect(function()
&#9;&#9;if areaSoak.Visible then
&#9;&#9;&#9;cancelSlide(areaSoak)
&#9;&#9;end
&#9;end)
&#9;
&#9;slider.MouseButton1Down:connect(function()
&#9;&#9;areaSoak.Visible = true
&#9;&#9;if areaSoakMouseMoveCon then areaSoakMouseMoveCon:disconnect() end
&#9;&#9;areaSoakMouseMoveCon = areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;&#9;end)
&#9;end)
&#9;
&#9;slider.MouseButton1Up:connect(function() cancelSlide(areaSoak) end)
&#9;
&#9;sliderPosition.Changed:connect(function(prop)
&#9;&#9;sliderPosition.Value = math.min(steps, math.max(1,sliderPosition.Value))
&#9;&#9;local relativePosX = (sliderPosition.Value - 1) / (steps - 1)
&#9;&#9;slider.Position = UDim2.new(relativePosX,-slider.AbsoluteSize.X/2,slider.Position.Y.Scale,slider.Position.Y.Offset)
&#9;&#9;fill.Size = UDim2.new(relativePosX, 0, 1, 0)
&#9;end)
&#9;
&#9;bar.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;fill.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)

&#9;fillLeft.MouseButton1Down:connect(function(x,y)
&#9;&#9;setSliderPos(x,slider,sliderPosition,bar,steps)
&#9;end)


&#9;return sliderGui, sliderPosition, sliderSteps

end





t.CreateTrueScrollingFrame = function()
&#9;local lowY = nil
&#9;local highY = nil
&#9;
&#9;local dragCon = nil
&#9;local upCon = nil

&#9;local internalChange = false

&#9;local descendantsChangeConMap = {}

&#9;local scrollingFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollingFrame.Name = &quot;ScrollingFrame&quot;
&#9;scrollingFrame.Active = true
&#9;scrollingFrame.Size = UDim2.new(1,0,1,0)
&#9;scrollingFrame.ClipsDescendants = true

&#9;local controlFrame = Instance.new(&quot;Frame&quot;)
&#9;controlFrame.Name = &quot;ControlFrame&quot;
&#9;controlFrame.BackgroundTransparency = 1
&#9;controlFrame.Size = UDim2.new(0,18,1,0)
&#9;controlFrame.Position = UDim2.new(1,-20,0,0)
&#9;controlFrame.Parent = scrollingFrame
&#9;
&#9;local scrollBottom = Instance.new(&quot;BoolValue&quot;)
&#9;scrollBottom.Value = false
&#9;scrollBottom.Name = &quot;ScrollBottom&quot;
&#9;scrollBottom.Parent = controlFrame
&#9;
&#9;local scrollUp = Instance.new(&quot;BoolValue&quot;)
&#9;scrollUp.Value = false
&#9;scrollUp.Name = &quot;scrollUp&quot;
&#9;scrollUp.Parent = controlFrame

&#9;local scrollUpButton = Instance.new(&quot;TextButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.Text = &quot;&quot;
&#9;scrollUpButton.AutoButtonColor = false
&#9;scrollUpButton.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollUpButton.BorderColor3 = Color3.new(1,1,1)
&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;scrollUpButton.Size = UDim2.new(0,18,0,18)
&#9;scrollUpButton.ZIndex = 2
&#9;scrollUpButton.Parent = controlFrame
&#9;for i = 1, 6 do
&#9;&#9;local triFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;triFrame.BorderColor3 = Color3.new(1,1,1)
&#9;&#9;triFrame.Name = &quot;tri&quot; .. tostring(i)
&#9;&#9;triFrame.ZIndex = 3
&#9;&#9;triFrame.BackgroundTransparency = 0.5
&#9;&#9;triFrame.Size = UDim2.new(0,12 - ((i -1) * 2),0,0)
&#9;&#9;triFrame.Position = UDim2.new(0,3 + (i -1),0.5,2 - (i -1))
&#9;&#9;triFrame.Parent = scrollUpButton
&#9;end
&#9;scrollUpButton.MouseEnter:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.1
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollUpButton.MouseLeave:connect(function()
&#9;&#9;scrollUpButton.BackgroundTransparency = 0.5
&#9;&#9;local upChildren = scrollUpButton:GetChildren()
&#9;&#9;for i = 1, #upChildren do
&#9;&#9;&#9;upChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)

&#9;local scrollDownButton = scrollUpButton:clone()
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-18)
&#9;local downChildren = scrollDownButton:GetChildren()
&#9;for i = 1, #downChildren do
&#9;&#9;downChildren[i].Position = UDim2.new(0,3 + (i -1),0.5,-2 + (i - 1))
&#9;end
&#9;scrollDownButton.MouseEnter:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.1
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.1
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.MouseLeave:connect(function()
&#9;&#9;scrollDownButton.BackgroundTransparency = 0.5
&#9;&#9;local downChildren = scrollDownButton:GetChildren()
&#9;&#9;for i = 1, #downChildren do
&#9;&#9;&#9;downChildren[i].BackgroundTransparency = 0.5
&#9;&#9;end
&#9;end)
&#9;scrollDownButton.Parent = controlFrame
&#9;
&#9;local scrollTrack = Instance.new(&quot;Frame&quot;)
&#9;scrollTrack.Name = &quot;ScrollTrack&quot;
&#9;scrollTrack.BackgroundTransparency = 1
&#9;scrollTrack.Size = UDim2.new(0,18,1,-38)
&#9;scrollTrack.Position = UDim2.new(0,0,0,19)
&#9;scrollTrack.Parent = controlFrame

&#9;local scrollbar = Instance.new(&quot;TextButton&quot;)
&#9;scrollbar.BackgroundColor3 = Color3.new(0,0,0)
&#9;scrollbar.BorderColor3 = Color3.new(1,1,1)
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.AutoButtonColor = false
&#9;scrollbar.Text = &quot;&quot;
&#9;scrollbar.Active = true
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.ZIndex = 2
&#9;scrollbar.BackgroundTransparency = 0.5
&#9;scrollbar.Size = UDim2.new(0, 18, 0.1, 0)
&#9;scrollbar.Position = UDim2.new(0,0,0,0)
&#9;scrollbar.Parent = scrollTrack

&#9;local scrollNub = Instance.new(&quot;Frame&quot;)
&#9;scrollNub.Name = &quot;ScrollNub&quot;
&#9;scrollNub.BorderColor3 = Color3.new(1,1,1)
&#9;scrollNub.Size = UDim2.new(0,10,0,0)
&#9;scrollNub.Position = UDim2.new(0.5,-5,0.5,0)
&#9;scrollNub.ZIndex = 2
&#9;scrollNub.BackgroundTransparency = 0.5
&#9;scrollNub.Parent = scrollbar

&#9;local newNub = scrollNub:clone()
&#9;newNub.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;newNub.Parent = scrollbar
&#9;
&#9;local lastNub = scrollNub:clone()
&#9;lastNub.Position = UDim2.new(0.5,-5,0.5,2)
&#9;lastNub.Parent = scrollbar

&#9;scrollbar.MouseEnter:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.1
&#9;&#9;scrollNub.BackgroundTransparency = 0.1
&#9;&#9;newNub.BackgroundTransparency = 0.1
&#9;&#9;lastNub.BackgroundTransparency = 0.1
&#9;end)
&#9;scrollbar.MouseLeave:connect(function()
&#9;&#9;scrollbar.BackgroundTransparency = 0.5
&#9;&#9;scrollNub.BackgroundTransparency = 0.5
&#9;&#9;newNub.BackgroundTransparency = 0.5
&#9;&#9;lastNub.BackgroundTransparency = 0.5
&#9;end)

&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10
&#9;
&#9;local function positionScrollBar(x,y,offset)
&#9;&#9;local oldPos = scrollbar.Position

&#9;&#9;if y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;
&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y

&#9;&#9;if y &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;&#9;end
&#9;&#9;local newScaleYPos = (y - scrollTrack.AbsolutePosition.y - offset)/scrollTrack.AbsoluteSize.y
&#9;&#9;if newScaleYPos + relativeSize &gt; 1 then
&#9;&#9;&#9;newScaleYPos = 1 - relativeSize
&#9;&#9;&#9;scrollBottom.Value = true
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;elseif newScaleYPos &lt;= 0 then
&#9;&#9;&#9;newScaleYPos = 0
&#9;&#9;&#9;scrollUp.Value = true
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;else
&#9;&#9;&#9;scrollUp.Value = false
&#9;&#9;&#9;scrollBottom.Value = false
&#9;&#9;end
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,newScaleYPos,0)
&#9;&#9;
&#9;&#9;return (oldPos ~= scrollbar.Position)
&#9;end

&#9;local function drillDownSetHighLow(instance)
&#9;&#9;if not instance or not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if instance == controlFrame then return end
&#9;&#9;if instance:IsDescendantOf(controlFrame) then return end
&#9;&#9;if not instance.Visible then return end

&#9;&#9;if lowY and lowY &gt; instance.AbsolutePosition.Y then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;elseif not lowY then
&#9;&#9;&#9;lowY = instance.AbsolutePosition.Y
&#9;&#9;end
&#9;&#9;if highY and highY &lt; (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;local children = instance:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;drillDownSetHighLow(children[i])
&#9;&#9;end
&#9;end

&#9;local function resetHighLow()
&#9;&#9;local firstChildren = scrollingFrame:GetChildren()

&#9;&#9;for i = 1, #firstChildren do
&#9;&#9;&#9;drillDownSetHighLow(firstChildren[i])
&#9;&#9;end
&#9;end

&#9;local function recalculate()
&#9;&#9;internalChange = true

&#9;&#9;local percentFrame = 0
&#9;&#9;if scrollbar.Position.Y.Scale &gt; 0 then
&#9;&#9;&#9;if scrollbar.Visible then
&#9;&#9;&#9;&#9;percentFrame = scrollbar.Position.Y.Scale/((scrollTrack.AbsoluteSize.Y - scrollbar.AbsoluteSize.Y)/scrollTrack.AbsoluteSize.Y)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;percentFrame = 0
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if percentFrame &gt; 0.99 then percentFrame = 1 end

&#9;&#9;local hiddenYAmount = (scrollingFrame.AbsoluteSize.Y - (highY - lowY)) * percentFrame
&#9;&#9;
&#9;&#9;local guiChildren = scrollingFrame:GetChildren()
&#9;&#9;for i = 1, #guiChildren do
&#9;&#9;&#9;if guiChildren[i] ~= controlFrame then
&#9;&#9;&#9;&#9;guiChildren[i].Position = UDim2.new(guiChildren[i].Position.X.Scale,guiChildren[i].Position.X.Offset,
&#9;&#9;&#9;&#9;&#9;0, math.ceil(guiChildren[i].AbsolutePosition.Y) - math.ceil(lowY) + hiddenYAmount)
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()
&#9;&#9;internalChange = false
&#9;end

&#9;local function setSliderSizeAndPosition()
&#9;&#9;if not highY or not lowY then return end

&#9;&#9;local totalYSpan = math.abs(highY - lowY)
&#9;&#9;if totalYSpan == 0 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false

&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local percentShown = scrollingFrame.AbsoluteSize.Y/totalYSpan
&#9;&#9;if percentShown &gt;= 1 then
&#9;&#9;&#9;scrollbar.Visible = false
&#9;&#9;&#9;scrollDownButton.Visible = false
&#9;&#9;&#9;scrollUpButton.Visible = false
&#9;&#9;&#9;recalculate()
&#9;&#9;else
&#9;&#9;&#9;scrollbar.Visible = true
&#9;&#9;&#9;scrollDownButton.Visible = true
&#9;&#9;&#9;scrollUpButton.Visible = true

&#9;&#9;&#9;scrollbar.Size = UDim2.new(scrollbar.Size.X.Scale,scrollbar.Size.X.Offset,percentShown,0)
&#9;&#9;end

&#9;&#9;local percentPosition = (scrollingFrame.AbsolutePosition.Y - lowY)/totalYSpan
&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,percentPosition,-scrollbar.AbsoluteSize.X/2)

&#9;&#9;if scrollbar.AbsolutePosition.y &lt; scrollTrack.AbsolutePosition.y then
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,0,0)
&#9;&#9;end

&#9;&#9;if (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.Y) &gt; (scrollTrack.AbsolutePosition.y + scrollTrack.AbsoluteSize.y) then
&#9;&#9;&#9;local relativeSize = scrollbar.AbsoluteSize.Y/scrollTrack.AbsoluteSize.Y
&#9;&#9;&#9;scrollbar.Position = UDim2.new(scrollbar.Position.X.Scale,scrollbar.Position.X.Offset,1 - relativeSize,0)
&#9;&#9;end
&#9;end
&#9;
&#9;local buttonScrollAmountPixels = 7
&#9;local reentrancyGuardScrollUp = false
&#9;local function doScrollUp()
&#9;&#9;if reentrancyGuardScrollUp then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollUp = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y - buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollUp = false
&#9;end
&#9;
&#9;local reentrancyGuardScrollDown = false
&#9;local function doScrollDown()
&#9;&#9;if reentrancyGuardScrollDown then return end
&#9;&#9;
&#9;&#9;reentrancyGuardScrollDown = true
&#9;&#9;&#9;if positionScrollBar(0,scrollbar.AbsolutePosition.Y + buttonScrollAmountPixels,0) then
&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;end
&#9;&#9;reentrancyGuardScrollDown = false
&#9;end

&#9;local function scrollUp(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollbar.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function scrollDown(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollbar.AbsolutePosition.y + scrollbar.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;scrollbar.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollbar.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollbar.AbsolutePosition.y
&#9;&#9;&#9;if dragCon then dragCon:disconnect() dragCon = nil end
&#9;&#9;&#9;if upCon then upCon:disconnect() upCon = nil end
&#9;&#9;&#9;local prevY = y
&#9;&#9;&#9;local reentrancyGuardMouseScroll = false
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;if reentrancyGuardMouseScroll then return end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = true
&#9;&#9;&#9;&#9;&#9;if positionScrollBar(x,y,mouseOffset) then
&#9;&#9;&#9;&#9;&#9;&#9;recalculate()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;reentrancyGuardMouseScroll = false
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(function()
&#9;&#9;scrollUp()
&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)

&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(function()
&#9;&#9; scrollDown()
&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;
&#9;local function heightCheck(instance)
&#9;&#9;if highY and (instance.AbsolutePosition.Y + instance.AbsoluteSize.Y) &gt; highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;elseif not highY then
&#9;&#9;&#9;highY = instance.AbsolutePosition.Y + instance.AbsoluteSize.Y
&#9;&#9;end
&#9;&#9;setSliderSizeAndPosition()
&#9;end
&#9;
&#9;local function highLowRecheck()
&#9;&#9;local oldLowY = lowY
&#9;&#9;local oldHighY = highY
&#9;&#9;lowY = nil
&#9;&#9;highY = nil
&#9;&#9;resetHighLow()

&#9;&#9;if (lowY ~= oldLowY) or (highY ~= oldHighY) then
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end

&#9;local function descendantChanged(this, prop)
&#9;&#9;if internalChange then return end
&#9;&#9;if not this.Visible then return end

&#9;&#9;if prop == &quot;Size&quot; or prop == &quot;Position&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end
&#9;end

&#9;scrollingFrame.DescendantAdded:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end

&#9;&#9;if instance.Visible then
&#9;&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;&#9;highLowRecheck()
&#9;&#9;end

&#9;&#9;descendantsChangeConMap[instance] = instance.Changed:connect(function(prop) descendantChanged(instance, prop) end)
&#9;end)

&#9;scrollingFrame.DescendantRemoving:connect(function(instance)
&#9;&#9;if not instance:IsA(&quot;GuiObject&quot;) then return end
&#9;&#9;if descendantsChangeConMap[instance] then
&#9;&#9;&#9;descendantsChangeConMap[instance]:disconnect()
&#9;&#9;&#9;descendantsChangeConMap[instance] = nil
&#9;&#9;end
&#9;&#9;wait() -- wait a heartbeat for sizes to reconfig
&#9;&#9;highLowRecheck()
&#9;end)
&#9;
&#9;scrollingFrame.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if not highY or not lowY then return end

&#9;&#9;&#9;highLowRecheck()
&#9;&#9;&#9;setSliderSizeAndPosition()
&#9;&#9;end
&#9;end)

&#9;return scrollingFrame, controlFrame
end

t.CreateScrollingFrame = function(orderList,scrollStyle)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;ScrollingFrame&quot;
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;
&#9;local scrollUpButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollUpButton.Name = &quot;ScrollUpButton&quot;
&#9;scrollUpButton.BackgroundTransparency = 1
&#9;scrollUpButton.Image = &quot;rbxasset://textures/ui/scrollbuttonUp.png&quot;
&#9;scrollUpButton.Size = UDim2.new(0,17,0,17) 

&#9;
&#9;local scrollDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDownButton.Name = &quot;ScrollDownButton&quot;
&#9;scrollDownButton.BackgroundTransparency = 1
&#9;scrollDownButton.Image = &quot;rbxasset://textures/ui/scrollbuttonDown.png&quot;
&#9;scrollDownButton.Size = UDim2.new(0,17,0,17) 
&#9;
&#9;local scrollbar = Instance.new(&quot;ImageButton&quot;)
&#9;scrollbar.Name = &quot;ScrollBar&quot;
&#9;scrollbar.Image = &quot;rbxasset://textures/ui/scrollbar.png&quot;
&#9;scrollbar.BackgroundTransparency = 1
&#9;scrollbar.Size = UDim2.new(0, 18, 0, 150)

&#9;local scrollStamp = 0
&#9;&#9;
&#9;local scrollDrag = Instance.new(&quot;ImageButton&quot;)
&#9;scrollDrag.Image = &quot;https://www.pengin.xyz/asset/?id=61367186&quot;
&#9;scrollDrag.Size = UDim2.new(1, 0, 0, 16)
&#9;scrollDrag.BackgroundTransparency = 1
&#9;scrollDrag.Name = &quot;ScrollDrag&quot;
&#9;scrollDrag.Active = true
&#9;scrollDrag.Parent = scrollbar
&#9;
&#9;local mouseDrag = Instance.new(&quot;ImageButton&quot;)
&#9;mouseDrag.Active = false
&#9;mouseDrag.Size = UDim2.new(1.5, 0, 1.5, 0)
&#9;mouseDrag.AutoButtonColor = false
&#9;mouseDrag.BackgroundTransparency = 1
&#9;mouseDrag.Name = &quot;mouseDrag&quot;
&#9;mouseDrag.Position = UDim2.new(-0.25, 0, -0.25, 0)
&#9;mouseDrag.ZIndex = 10

&#9;local style = &quot;simple&quot;
&#9;if scrollStyle and tostring(scrollStyle) then
&#9;&#9;style = scrollStyle
&#9;end
&#9;
&#9;local scrollPosition = 1
&#9;local rowSize = 0
&#9;local howManyDisplayed = 0
&#9;&#9;
&#9;local layoutGridScrollBar = function()
&#9;&#9;howManyDisplayed = 0
&#9;&#9;local guiObjects = {}
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;
&#9;&#9;local totalPixelsY = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemainingY = frame.AbsoluteSize.Y
&#9;&#9;
&#9;&#9;local totalPixelsX  = frame.AbsoluteSize.X
&#9;&#9;
&#9;&#9;local xCounter = 0
&#9;&#9;local rowSizeCounter = 0
&#9;&#9;local setRowSize = true

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;
&#9;&#9;local currentRowY = 0

&#9;&#9;pos = scrollPosition
&#9;&#9;--count up from current scroll position to fill out grid
&#9;&#9;while pos &lt;= #guiObjects and pixelsBelowScrollbar &lt; totalPixelsY do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;--previous pos was the end of a row
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;end
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos + 1
&#9;&#9;end
&#9;&#9;--Count wherever current row left off
&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;currentRowY = 0
&#9;&#9;
&#9;&#9;pos = scrollPosition - 1
&#9;&#9;xCounter = 0
&#9;&#9;
&#9;&#9;--objects with varying X,Y dimensions can rarely cause minor errors
&#9;&#9;--rechecking every new scrollPosition is necessary to avoid 100% of errors
&#9;&#9;
&#9;&#9;--count backwards from current scrollPosition to see if we can add more rows
&#9;&#9;while pixelsBelowScrollbar + currentRowY &lt; totalPixelsY and pos &gt;= 1 do
&#9;&#9;&#9;xCounter = xCounter + guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;rowSizeCounter = rowSizeCounter + 1
&#9;&#9;&#9;if xCounter &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;rowSizeCounter = 0
&#9;&#9;&#9;&#9;xCounter = guiObjects[pos].AbsoluteSize.X
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + currentRowY
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= rowSize then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1 
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - rowSize
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;currentRowY = 0
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;if guiObjects[pos].AbsoluteSize.Y &gt; currentRowY then
&#9;&#9;&#9;&#9;currentRowY = guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;end

&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end
&#9;&#9;
&#9;&#9;--Do check last time if pos = 0
&#9;&#9;if (pos == 0) and (pixelsBelowScrollbar + currentRowY &lt;= totalPixelsY) then
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;end

&#9;&#9;xCounter = 0
&#9;&#9;--pos = scrollPosition
&#9;&#9;rowSizeCounter = 0
&#9;&#9;setRowSize = true
&#9;&#9;local lastChildSize = 0
&#9;&#9;
&#9;&#9;local xOffset,yOffset = 0
&#9;&#9;if guiObjects[1] then
&#9;&#9;&#9;yOffset = math.ceil(math.floor(math.fmod(totalPixelsY,guiObjects[1].AbsoluteSize.X))/2)
&#9;&#9;&#9;xOffset = math.ceil(math.floor(math.fmod(totalPixelsX,guiObjects[1].AbsoluteSize.Y))/2)
&#9;&#9;end
&#9;&#9;
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemainingY &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;if setRowSize then rowSizeCounter = rowSizeCounter + 1 end
&#9;&#9;&#9;&#9;&#9;if xCounter + child.AbsoluteSize.X &gt;= totalPixelsX then
&#9;&#9;&#9;&#9;&#9;&#9;if setRowSize then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;rowSize = rowSizeCounter - 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;setRowSize = false
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;xCounter = 0
&#9;&#9;&#9;&#9;&#9;&#9;pixelsRemainingY = pixelsRemainingY - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale,xCounter + xOffset, 0, totalPixelsY - pixelsRemainingY + yOffset)
&#9;&#9;&#9;&#9;&#9;xCounter = xCounter + child.AbsoluteSize.X
&#9;&#9;&#9;&#9;&#9;child.Visible = ((pixelsRemainingY - child.AbsoluteSize.Y) &gt;= 0)
&#9;&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;lastChildSize = child.AbsoluteSize&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;if lastChildSize == 0 then 
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;else
&#9;&#9;&#9;scrollDownButton.Active = ((pixelsRemainingY - lastChildSize.Y) &lt; 0)
&#9;&#9;end
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end



&#9;local layoutSimpleScrollBar = function()
&#9;&#9;local guiObjects = {}&#9;
&#9;&#9;howManyDisplayed = 0
&#9;&#9;
&#9;&#9;if orderList then
&#9;&#9;&#9;for i, child in ipairs(orderList) do
&#9;&#9;&#9;&#9;if child.Parent == frame then
&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;table.insert(guiObjects, child)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if #guiObjects == 0 then
&#9;&#9;&#9;scrollUpButton.Active = false
&#9;&#9;&#9;scrollDownButton.Active = false
&#9;&#9;&#9;scrollDrag.Active = false
&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if scrollPosition &gt; #guiObjects then
&#9;&#9;&#9;scrollPosition = #guiObjects
&#9;&#9;end
&#9;&#9;
&#9;&#9;local totalPixels = frame.AbsoluteSize.Y
&#9;&#9;local pixelsRemaining = frame.AbsoluteSize.Y

&#9;&#9;local pixelsBelowScrollbar = 0
&#9;&#9;local pos = #guiObjects
&#9;&#9;while pixelsBelowScrollbar &lt; totalPixels and pos &gt;= 1 do
&#9;&#9;&#9;if pos &gt;= scrollPosition then
&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y &lt;= totalPixels then
&#9;&#9;&#9;&#9;&#9;--It fits, so back up our scroll position
&#9;&#9;&#9;&#9;&#9;pixelsBelowScrollbar = pixelsBelowScrollbar + guiObjects[pos].AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if scrollPosition &lt;= 1 then
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = 1
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;--local (&quot;Backing up ScrollPosition from -- &quot; ..scrollPosition)
&#9;&#9;&#9;&#9;&#9;&#9;scrollPosition = scrollPosition - 1
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;pos = pos - 1
&#9;&#9;end

&#9;&#9;pos = scrollPosition
&#9;&#9;for i, child in ipairs(guiObjects) do
&#9;&#9;&#9;if i &lt; scrollPosition then
&#9;&#9;&#9;&#9;--print(&quot;Hiding &quot; .. child.Name)
&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;if pixelsRemaining &lt; 0 then
&#9;&#9;&#9;&#9;&#9;--print(&quot;Out of Space &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;--print(&quot;Laying out &quot; .. child.Name)
&#9;&#9;&#9;&#9;&#9;--GuiObject
&#9;&#9;&#9;&#9;&#9;child.Position = UDim2.new(child.Position.X.Scale, child.Position.X.Offset, 0, totalPixels - pixelsRemaining)
&#9;&#9;&#9;&#9;&#9;pixelsRemaining = pixelsRemaining - child.AbsoluteSize.Y
&#9;&#9;&#9;&#9;&#9;if  (pixelsRemaining &gt;= 0) then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;howManyDisplayed = howManyDisplayed + 1
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;end&#9;&#9;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;scrollUpButton.Active = (scrollPosition &gt; 1)
&#9;&#9;scrollDownButton.Active = (pixelsRemaining &lt; 0)
&#9;&#9;scrollDrag.Active = #guiObjects &gt; howManyDisplayed
&#9;&#9;scrollDrag.Visible = scrollDrag.Active
&#9;end
&#9;
&#9;&#9;
&#9;local moveDragger = function()&#9;
&#9;&#9;local guiObjects = 0
&#9;&#9;local children = frame:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;if not scrollDrag.Parent then return end
&#9;&#9;
&#9;&#9;local dragSizeY = scrollDrag.Parent.AbsoluteSize.y * (1/(guiObjects - howManyDisplayed + 1))
&#9;&#9;if dragSizeY &lt; 16 then dragSizeY = 16 end
&#9;&#9;scrollDrag.Size = UDim2.new(scrollDrag.Size.X.Scale,scrollDrag.Size.X.Offset,scrollDrag.Size.Y.Scale,dragSizeY)

&#9;&#9;local relativeYPos = (scrollPosition - 1)/(guiObjects - (howManyDisplayed))
&#9;&#9;if relativeYPos &gt; 1 then relativeYPos = 1
&#9;&#9;elseif relativeYPos &lt; 0 then relativeYPos = 0 end
&#9;&#9;local absYPos = 0
&#9;&#9;
&#9;&#9;if relativeYPos ~= 0 then
&#9;&#9;&#9;absYPos = (relativeYPos * scrollbar.AbsoluteSize.y) - (relativeYPos * scrollDrag.AbsoluteSize.y)
&#9;&#9;end
&#9;&#9;
&#9;&#9;scrollDrag.Position = UDim2.new(scrollDrag.Position.X.Scale,scrollDrag.Position.X.Offset,scrollDrag.Position.Y.Scale,absYPos)
&#9;end

&#9;local reentrancyGuard = false
&#9;local recalculate = function()
&#9;&#9;if reentrancyGuard then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;reentrancyGuard = true
&#9;&#9;wait()
&#9;&#9;local success, err = nil
&#9;&#9;if style == &quot;grid&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutGridScrollBar() end)
&#9;&#9;elseif style == &quot;simple&quot; then
&#9;&#9;&#9;success, err = pcall(function() layoutSimpleScrollBar() end)
&#9;&#9;end
&#9;&#9;if not success then print(err) end
&#9;&#9;moveDragger()
&#9;&#9;reentrancyGuard = false
&#9;end
&#9;
&#9;local doScrollUp = function()
&#9;&#9;scrollPosition = (scrollPosition) - rowSize
&#9;&#9;if scrollPosition &lt; 1 then scrollPosition = 1 end
&#9;&#9;recalculate(nil)
&#9;end
&#9;
&#9;local doScrollDown = function()
&#9;&#9;scrollPosition = (scrollPosition) + rowSize
&#9;&#9;recalculate(nil)
&#9;end

&#9;local scrollUp = function(mouseYPos)
&#9;&#9;if scrollUpButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;upCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollUp()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &gt; scrollDrag.AbsolutePosition.y then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollUpButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local scrollDown = function(mouseYPos)
&#9;&#9;if scrollDownButton.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local current = scrollStamp
&#9;&#9;&#9;local downCon
&#9;&#9;&#9;downCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;downCon:disconnect()
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;wait(0.2)
&#9;&#9;&#9;local t = tick()
&#9;&#9;&#9;local w = 0.1
&#9;&#9;&#9;while scrollStamp == current do
&#9;&#9;&#9;&#9;doScrollDown()
&#9;&#9;&#9;&#9;if mouseYPos and mouseYPos &lt; (scrollDrag.AbsolutePosition.y + scrollDrag.AbsoluteSize.x) then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if not scrollDownButton.Active then break end
&#9;&#9;&#9;&#9;if tick()-t &gt; 5 then
&#9;&#9;&#9;&#9;&#9;w = 0
&#9;&#9;&#9;&#9;elseif tick()-t &gt; 2 then
&#9;&#9;&#9;&#9;&#9;w = 0.06
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;wait(w)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local y = 0
&#9;scrollDrag.MouseButton1Down:connect(function(x,y)
&#9;&#9;if scrollDrag.Active then
&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;local mouseOffset = y - scrollDrag.AbsolutePosition.y
&#9;&#9;&#9;local dragCon
&#9;&#9;&#9;local upCon
&#9;&#9;&#9;dragCon = mouseDrag.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;&#9;local barAbsPos = scrollbar.AbsolutePosition.y
&#9;&#9;&#9;&#9;local barAbsSize = scrollbar.AbsoluteSize.y
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local dragAbsSize = scrollDrag.AbsoluteSize.y
&#9;&#9;&#9;&#9;local barAbsOne = barAbsPos + barAbsSize - dragAbsSize
&#9;&#9;&#9;&#9;y = y - mouseOffset
&#9;&#9;&#9;&#9;y = y &lt; barAbsPos and barAbsPos or y &gt; barAbsOne and barAbsOne or y
&#9;&#9;&#9;&#9;y = y - barAbsPos
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local guiObjects = 0
&#9;&#9;&#9;&#9;local children = frame:GetChildren()
&#9;&#9;&#9;&#9;if children then
&#9;&#9;&#9;&#9;&#9;for i, child in ipairs(children) do 
&#9;&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;guiObjects = guiObjects + 1
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local doublePercent = y/(barAbsSize-dragAbsSize)
&#9;&#9;&#9;&#9;local rowDiff = rowSize
&#9;&#9;&#9;&#9;local totalScrollCount = guiObjects - (howManyDisplayed - 1)
&#9;&#9;&#9;&#9;local newScrollPosition = math.floor((doublePercent * totalScrollCount) + 0.5) + rowDiff
&#9;&#9;&#9;&#9;if newScrollPosition &lt; scrollPosition then
&#9;&#9;&#9;&#9;&#9;rowDiff = -rowDiff
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if newScrollPosition &lt; 1 then
&#9;&#9;&#9;&#9;&#9;newScrollPosition = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;scrollPosition = newScrollPosition
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end)
&#9;&#9;&#9;upCon = mouseDrag.MouseButton1Up:connect(function()
&#9;&#9;&#9;&#9;scrollStamp = tick()
&#9;&#9;&#9;&#9;mouseDrag.Parent = nil
&#9;&#9;&#9;&#9;dragCon:disconnect(); dragCon = nil
&#9;&#9;&#9;&#9;upCon:disconnect(); drag = nil
&#9;&#9;&#9;end)
&#9;&#9;&#9;mouseDrag.Parent = getLayerCollectorAncestor(scrollbar)
&#9;&#9;end
&#9;end)

&#9;local scrollMouseCount = 0

&#9;scrollUpButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollUp()
&#9;&#9;end)
&#9;scrollUpButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)


&#9;scrollDownButton.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollDownButton.MouseButton1Down:connect(
&#9;&#9;function()
&#9;&#9;&#9;scrollDown()&#9;
&#9;&#9;end)
&#9;&#9;
&#9;scrollbar.MouseButton1Up:connect(function()
&#9;&#9;scrollStamp = tick()
&#9;end)
&#9;scrollbar.MouseButton1Down:connect(
&#9;&#9;function(x,y)
&#9;&#9;&#9;if y &gt; (scrollDrag.AbsoluteSize.y + scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollDown(y)
&#9;&#9;&#9;elseif y &lt; (scrollDrag.AbsolutePosition.y) then
&#9;&#9;&#9;&#9;scrollUp(y)
&#9;&#9;&#9;end
&#9;&#9;end)


&#9;frame.ChildAdded:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)

&#9;frame.ChildRemoved:connect(function()
&#9;&#9;recalculate(nil)
&#9;end)
&#9;
&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;--Wait a heartbeat for it to sync in
&#9;&#9;&#9;&#9;recalculate(nil)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;frame.AncestryChanged:connect(function() recalculate(nil) end)

&#9;return frame, scrollUpButton, scrollDownButton, recalculate, scrollbar
end
local function binaryGrow(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local biggestLegal = min

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (biggestLegal == nil or biggestLegal &lt; mid) then
&#9;&#9;&#9;biggestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--Try growing
&#9;&#9;&#9;min = mid + 1
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, shrink
&#9;&#9;&#9;max = mid - 1
&#9;&#9;end
&#9;end
&#9;return biggestLegal
end


local function binaryShrink(min, max, fits)
&#9;if min &gt; max then
&#9;&#9;return min
&#9;end
&#9;local smallestLegal = max

&#9;while min &lt;= max do
&#9;&#9;local mid = min + math.floor((max - min) / 2)
&#9;&#9;if fits(mid) and (smallestLegal == nil or smallestLegal &gt; mid) then
&#9;&#9;&#9;smallestLegal = mid
&#9;&#9;&#9;
&#9;&#9;&#9;--It fits, shrink
&#9;&#9;&#9;max = mid - 1&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;--Doesn&apos;t fit, grow
&#9;&#9;&#9;min = mid + 1
&#9;&#9;end
&#9;end
&#9;return smallestLegal
end


local function getGuiOwner(instance)
&#9;while instance ~= nil do
&#9;&#9;if instance:IsA(&quot;ScreenGui&quot;) or instance:IsA(&quot;BillboardGui&quot;)  then
&#9;&#9;&#9;return instance
&#9;&#9;end
&#9;&#9;instance = instance.Parent
&#9;end
&#9;return nil
end

t.AutoTruncateTextObject = function(textLabel)
&#9;local text = textLabel.Text

&#9;local fullLabel = textLabel:Clone()
&#9;fullLabel.Name = &quot;Full&quot; .. textLabel.Name 
&#9;fullLabel.BorderSizePixel = 0
&#9;fullLabel.BackgroundTransparency = 0
&#9;fullLabel.Text = text
&#9;fullLabel.TextXAlignment = Enum.TextXAlignment.Center
&#9;fullLabel.Position = UDim2.new(0,-3,0,0)
&#9;fullLabel.Size = UDim2.new(0,100,1,0)
&#9;fullLabel.Visible = false
&#9;fullLabel.Parent = textLabel

&#9;local shortText = nil
&#9;local mouseEnterConnection = nil
&#9;local mouseLeaveConnection= nil

&#9;local checkForResize = function()
&#9;&#9;if getGuiOwner(textLabel) == nil then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;&#9;textLabel.Text = text
&#9;&#9;if textLabel.TextFits then 
&#9;&#9;&#9;--Tear down the rollover if it is active
&#9;&#9;&#9;if mouseEnterConnection then
&#9;&#9;&#9;&#9;mouseEnterConnection:disconnect()
&#9;&#9;&#9;&#9;mouseEnterConnection = nil
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection then
&#9;&#9;&#9;&#9;mouseLeaveConnection:disconnect()
&#9;&#9;&#9;&#9;mouseLeaveConnection = nil
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;local len = string.len(text)
&#9;&#9;&#9;textLabel.Text = text .. &quot;~&quot;

&#9;&#9;&#9;--Shrink the text
&#9;&#9;&#9;local textSize = binaryGrow(0, len, 
&#9;&#9;&#9;&#9;function(pos)
&#9;&#9;&#9;&#9;&#9;if pos == 0 then
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;textLabel.Text = string.sub(text, 1, pos) .. &quot;~&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;shortText = string.sub(text, 1, textSize) .. &quot;~&quot;
&#9;&#9;&#9;textLabel.Text = shortText
&#9;&#9;&#9;
&#9;&#9;&#9;--Make sure the fullLabel fits
&#9;&#9;&#9;if not fullLabel.TextFits then
&#9;&#9;&#9;&#9;--Already too small, grow it really bit to start
&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, 10000, 1, 0)
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;--Okay, now try to binary shrink it back down
&#9;&#9;&#9;local fullLabelSize = binaryShrink(textLabel.AbsoluteSize.X,fullLabel.AbsoluteSize.X, 
&#9;&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;&#9;fullLabel.Size = UDim2.new(0, size, 1, 0)
&#9;&#9;&#9;&#9;&#9;return fullLabel.TextFits
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;fullLabel.Size = UDim2.new(0,fullLabelSize+6,1,0)

&#9;&#9;&#9;--Now setup the rollover effects, if they are currently off
&#9;&#9;&#9;if mouseEnterConnection == nil then
&#9;&#9;&#9;&#9;mouseEnterConnection = textLabel.MouseEnter:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.ZIndex = textLabel.ZIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = true
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;if mouseLeaveConnection == nil then
&#9;&#9;&#9;&#9;mouseLeaveConnection = textLabel.MouseLeave:connect(
&#9;&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;&#9;fullLabel.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;--textLabel.Text = shortText
&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;textLabel.AncestryChanged:connect(checkForResize)
&#9;textLabel.Changed:connect(
&#9;&#9;function(prop) 
&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then 
&#9;&#9;&#9;&#9;checkForResize() &#9;
&#9;&#9;&#9;end 
&#9;&#9;end)

&#9;checkForResize()

&#9;local function changeText(newText)
&#9;&#9;text = newText
&#9;&#9;fullLabel.Text = text
&#9;&#9;checkForResize()
&#9;end

&#9;return textLabel, changeText
end

local function TransitionTutorialPages(fromPage, toPage, transitionFrame, currentPageValue)&#9;
&#9;if fromPage then
&#9;&#9;fromPage.Visible = false
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = fromPage.Size
&#9;&#9;&#9;transitionFrame.Position = fromPage.Position
&#9;&#9;end
&#9;else
&#9;&#9;if transitionFrame.Visible == false then
&#9;&#9;&#9;transitionFrame.Size = UDim2.new(0.0,50,0.0,50)
&#9;&#9;&#9;transitionFrame.Position = UDim2.new(0.5,-25,0.5,-25)
&#9;&#9;end
&#9;end
&#9;transitionFrame.Visible = true
&#9;currentPageValue.Value = nil

&#9;local newSize, newPosition
&#9;if toPage then
&#9;&#9;--Make it visible so it resizes
&#9;&#9;toPage.Visible = true

&#9;&#9;newSize = toPage.Size
&#9;&#9;newPosition = toPage.Position

&#9;&#9;toPage.Visible = false
&#9;else
&#9;&#9;newSize = UDim2.new(0.0,50,0.0,50)
&#9;&#9;newPosition = UDim2.new(0.5,-25,0.5,-25)
&#9;end
&#9;transitionFrame:TweenSizeAndPosition(newSize, newPosition, Enum.EasingDirection.InOut, Enum.EasingStyle.Quad, 0.3, true,
&#9;&#9;function(state)
&#9;&#9;&#9;if state == Enum.TweenStatus.Completed then
&#9;&#9;&#9;&#9;transitionFrame.Visible = false
&#9;&#9;&#9;&#9;if toPage then
&#9;&#9;&#9;&#9;&#9;toPage.Visible = true
&#9;&#9;&#9;&#9;&#9;currentPageValue.Value = toPage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
end

t.CreateTutorial = function(name, tutorialKey, createButtons)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;Tutorial-&quot; .. name
&#9;frame.BackgroundTransparency = 1
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)

&#9;local transitionFrame = Instance.new(&quot;Frame&quot;)
&#9;transitionFrame.Name = &quot;TransitionFrame&quot;
&#9;transitionFrame.Style = Enum.FrameStyle.RobloxRound
&#9;transitionFrame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;transitionFrame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;transitionFrame.Visible = false
&#9;transitionFrame.Parent = frame

&#9;local currentPageValue = Instance.new(&quot;ObjectValue&quot;)
&#9;currentPageValue.Name = &quot;CurrentTutorialPage&quot;
&#9;currentPageValue.Value = nil
&#9;currentPageValue.Parent = frame

&#9;local boolValue = Instance.new(&quot;BoolValue&quot;)
&#9;boolValue.Name = &quot;Buttons&quot;
&#9;boolValue.Value = createButtons
&#9;boolValue.Parent = frame

&#9;local pages = Instance.new(&quot;Frame&quot;)
&#9;pages.Name = &quot;Pages&quot;
&#9;pages.BackgroundTransparency = 1
&#9;pages.Size = UDim2.new(1,0,1,0)
&#9;pages.Parent = frame

&#9;local function getVisiblePageAndHideOthers()
&#9;&#9;local visiblePage = nil
&#9;&#9;local children = pages:GetChildren()
&#9;&#9;if children then
&#9;&#9;&#9;for i,child in ipairs(children) do
&#9;&#9;&#9;&#9;if child.Visible then
&#9;&#9;&#9;&#9;&#9;if visiblePage then
&#9;&#9;&#9;&#9;&#9;&#9;child.Visible = false
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;visiblePage = child
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return visiblePage
&#9;end

&#9;local showTutorial = function(alwaysShow)
&#9;&#9;if alwaysShow or UserSettings().GameSettings:GetTutorialState(tutorialKey) == false then
&#9;&#9;&#9;print(&quot;Showing tutorial-&quot;,tutorialKey)
&#9;&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;&#9;local firstPage = pages:FindFirstChild(&quot;TutorialPage1&quot;)
&#9;&#9;&#9;if firstPage then
&#9;&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, firstPage, transitionFrame, currentPageValue)&#9;
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;error(&quot;Could not find TutorialPage1&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local dismissTutorial = function()
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()

&#9;&#9;if currentTutorialPage then
&#9;&#9;&#9;TransitionTutorialPages(currentTutorialPage, nil, transitionFrame, currentPageValue)
&#9;&#9;end

&#9;&#9;UserSettings().GameSettings:SetTutorialState(tutorialKey, true)
&#9;end

&#9;local gotoPage = function(pageNum)
&#9;&#9;local page = pages:FindFirstChild(&quot;TutorialPage&quot; .. pageNum)
&#9;&#9;local currentTutorialPage = getVisiblePageAndHideOthers()
&#9;&#9;TransitionTutorialPages(currentTutorialPage, page, transitionFrame, currentPageValue)
&#9;end

&#9;return frame, showTutorial, dismissTutorial, gotoPage
end 

local function CreateBasicTutorialPage(name, handleResize, skipTutorial, giveDoneButton)
&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TutorialPage&quot;
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.Size = UDim2.new(0.6, 0, 0.6, 0)
&#9;frame.Position = UDim2.new(0.2, 0, 0.2, 0)
&#9;frame.Visible = false
&#9;
&#9;local frameHeader = Instance.new(&quot;TextLabel&quot;)
&#9;frameHeader.Name = &quot;Header&quot;
&#9;frameHeader.Text = name
&#9;frameHeader.BackgroundTransparency = 1
&#9;frameHeader.FontSize = Enum.FontSize.Size24
&#9;frameHeader.Font = Enum.Font.ArialBold
&#9;frameHeader.TextColor3 = Color3.new(1,1,1)
&#9;frameHeader.TextXAlignment = Enum.TextXAlignment.Center
&#9;frameHeader.TextWrap = true
&#9;frameHeader.Size = UDim2.new(1,-55, 0, 22)
&#9;frameHeader.Position = UDim2.new(0,0,0,0)
&#9;frameHeader.Parent = frame

&#9;local skipButton = Instance.new(&quot;ImageButton&quot;)
&#9;skipButton.Name = &quot;SkipButton&quot;
&#9;skipButton.AutoButtonColor = false
&#9;skipButton.BackgroundTransparency = 1
&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;skipButton.MouseButton1Click:connect(function()
&#9;&#9;skipTutorial()
&#9;end)
&#9;skipButton.MouseEnter:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton_dn.png&quot;
&#9;end)
&#9;skipButton.MouseLeave:connect(function()
&#9;&#9;skipButton.Image = &quot;rbxasset://textures/ui/closeButton.png&quot;
&#9;end)
&#9;skipButton.Size = UDim2.new(0, 25, 0, 25)
&#9;skipButton.Position = UDim2.new(1, -25, 0, 0)
&#9;skipButton.Parent = frame
&#9;
&#9;
&#9;if giveDoneButton then
&#9;&#9;local doneButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;doneButton.Name = &quot;DoneButton&quot;
&#9;&#9;doneButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;doneButton.Text = &quot;Done&quot;
&#9;&#9;doneButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;doneButton.Font = Enum.Font.ArialBold
&#9;&#9;doneButton.FontSize = Enum.FontSize.Size18
&#9;&#9;doneButton.Size = UDim2.new(0,100,0,50)
&#9;&#9;doneButton.Position = UDim2.new(0.5,-50,1,-50)
&#9;&#9;
&#9;&#9;if skipTutorial then
&#9;&#9;&#9;doneButton.MouseButton1Click:connect(function() skipTutorial() end)
&#9;&#9;end
&#9;&#9;
&#9;&#9;doneButton.Parent = frame
&#9;end

&#9;local innerFrame = Instance.new(&quot;Frame&quot;)
&#9;innerFrame.Name = &quot;ContentFrame&quot;
&#9;innerFrame.BackgroundTransparency = 1
&#9;innerFrame.Position = UDim2.new(0,0,0,25)
&#9;innerFrame.Parent = frame

&#9;local nextButton = Instance.new(&quot;TextButton&quot;)
&#9;nextButton.Name = &quot;NextButton&quot;
&#9;nextButton.Text = &quot;Next&quot;
&#9;nextButton.TextColor3 = Color3.new(1,1,1)
&#9;nextButton.Font = Enum.Font.Arial
&#9;nextButton.FontSize = Enum.FontSize.Size18
&#9;nextButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;nextButton.Size = UDim2.new(0,80, 0, 32)
&#9;nextButton.Position = UDim2.new(0.5, 5, 1, -32)
&#9;nextButton.Active = false
&#9;nextButton.Visible = false
&#9;nextButton.Parent = frame

&#9;local prevButton = Instance.new(&quot;TextButton&quot;)
&#9;prevButton.Name = &quot;PrevButton&quot;
&#9;prevButton.Text = &quot;Previous&quot;
&#9;prevButton.TextColor3 = Color3.new(1,1,1)
&#9;prevButton.Font = Enum.Font.Arial
&#9;prevButton.FontSize = Enum.FontSize.Size18
&#9;prevButton.Style = Enum.ButtonStyle.RobloxButton
&#9;prevButton.Size = UDim2.new(0,80, 0, 32)
&#9;prevButton.Position = UDim2.new(0.5, -85, 1, -32)
&#9;prevButton.Active = false
&#9;prevButton.Visible = false
&#9;prevButton.Parent = frame

&#9;if giveDoneButton then
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-75)
&#9;else
&#9;&#9;innerFrame.Size = UDim2.new(1,0,1,-22)
&#9;end

&#9;local parentConnection = nil

&#9;local function basicHandleResize()
&#9;&#9;if frame.Visible and frame.Parent then
&#9;&#9;&#9;local maxSize = math.min(frame.Parent.AbsoluteSize.X, frame.Parent.AbsoluteSize.Y)
&#9;&#9;&#9;handleResize(200,maxSize)
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(
&#9;&#9;function(prop)
&#9;&#9;&#9;if prop == &quot;Parent&quot; then
&#9;&#9;&#9;&#9;if parentConnection ~= nil then
&#9;&#9;&#9;&#9;&#9;parentConnection:disconnect()
&#9;&#9;&#9;&#9;&#9;parentConnection = nil
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if frame.Parent and frame.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;&#9;parentConnection = frame.Parent.Changed:connect(
&#9;&#9;&#9;&#9;&#9;&#9;function(parentProp)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if parentProp == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;if prop == &quot;Visible&quot; then 
&#9;&#9;&#9;&#9;basicHandleResize()
&#9;&#9;&#9;end
&#9;&#9;end)

&#9;return frame, innerFrame
end

t.CreateTextTutorialPage = function(name, text, skipTutorialFunc)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local textLabel = Instance.new(&quot;TextLabel&quot;)
&#9;textLabel.BackgroundTransparency = 1
&#9;textLabel.TextColor3 = Color3.new(1,1,1)
&#9;textLabel.Text = text
&#9;textLabel.TextWrap = true
&#9;textLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;textLabel.TextYAlignment = Enum.TextYAlignment.Center
&#9;textLabel.Font = Enum.Font.Arial
&#9;textLabel.FontSize = Enum.FontSize.Size14
&#9;textLabel.Size = UDim2.new(1,0,1,0)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;&#9;&#9;return textLabel.TextFits
&#9;&#9;&#9;end)
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc)
&#9;textLabel.Parent = contentFrame

&#9;return frame
end

t.CreateImageTutorialPage = function(name, imageAsset, x, y, skipTutorialFunc, giveDoneButton)
&#9;local frame = nil
&#9;local contentFrame = nil

&#9;local imageLabel = Instance.new(&quot;ImageLabel&quot;)
&#9;imageLabel.BackgroundTransparency = 1
&#9;imageLabel.Image = imageAsset
&#9;imageLabel.Size = UDim2.new(0,x,0,y)
&#9;imageLabel.Position = UDim2.new(0.5,-x/2,0.5,-y/2)

&#9;local function handleResize(minSize, maxSize)
&#9;&#9;size = binaryShrink(minSize, maxSize,
&#9;&#9;&#9;function(size)
&#9;&#9;&#9;&#9;return size &gt;= x and size &gt;= y
&#9;&#9;&#9;end)
&#9;&#9;if size &gt;= x and size &gt;= y then
&#9;&#9;&#9;imageLabel.Size = UDim2.new(0,x, 0,y)
&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5,-x/2, 0.5, -y/2)
&#9;&#9;else
&#9;&#9;&#9;if x &gt; y then
&#9;&#9;&#9;&#9;--X is limiter, so 
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(1,0,y/x,0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0,0, 0.5 - (y/x)/2, 0)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;--Y is limiter
&#9;&#9;&#9;&#9;imageLabel.Size = UDim2.new(x/y,0,1, 0)
&#9;&#9;&#9;&#9;imageLabel.Position = UDim2.new(0.5-(x/y)/2, 0, 0, 0)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;size = size + 50
&#9;&#9;frame.Size = UDim2.new(0, size, 0, size)
&#9;&#9;frame.Position = UDim2.new(0.5, -size/2, 0.5, -size/2)
&#9;end

&#9;frame, contentFrame = CreateBasicTutorialPage(name, handleResize, skipTutorialFunc, giveDoneButton)
&#9;imageLabel.Parent = contentFrame

&#9;return frame
end

t.AddTutorialPage = function(tutorial, tutorialPage)
&#9;local transitionFrame = tutorial.TransitionFrame
&#9;local currentPageValue = tutorial.CurrentTutorialPage

&#9;if not tutorial.Buttons.Value then
&#9;&#9;tutorialPage.NextButton.Parent = nil
&#9;&#9;tutorialPage.PrevButton.Parent = nil
&#9;end

&#9;local children = tutorial.Pages:GetChildren()
&#9;if children and #children &gt; 0 then
&#9;&#9;tutorialPage.Name = &quot;TutorialPage&quot; .. (#children+1)
&#9;&#9;local previousPage = children[#children]
&#9;&#9;if not previousPage:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;error(&quot;All elements under Pages must be GuiObjects&quot;)
&#9;&#9;end

&#9;&#9;if tutorial.Buttons.Value then
&#9;&#9;&#9;if previousPage.NextButton.Active then
&#9;&#9;&#9;&#9;error(&quot;NextButton already Active on previousPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;previousPage.NextButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(previousPage, tutorialPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;previousPage.NextButton.Active = true
&#9;&#9;&#9;previousPage.NextButton.Visible = true

&#9;&#9;&#9;if tutorialPage.PrevButton.Active then
&#9;&#9;&#9;&#9;error(&quot;PrevButton already Active on tutorialPage, please only add pages with RbxGui.AddTutorialPage function&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;tutorialPage.PrevButton.MouseButton1Click:connect(
&#9;&#9;&#9;&#9;function()
&#9;&#9;&#9;&#9;&#9;TransitionTutorialPages(tutorialPage, previousPage, transitionFrame, currentPageValue)
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;tutorialPage.PrevButton.Active = true
&#9;&#9;&#9;tutorialPage.PrevButton.Visible = true
&#9;&#9;end

&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;else
&#9;&#9;--First child
&#9;&#9;tutorialPage.Name = &quot;TutorialPage1&quot;
&#9;&#9;tutorialPage.Parent = tutorial.Pages
&#9;end
end 

t.CreateSetPanel = function(userIdsForSets, objectSelected, dialogClosed, size, position, showAdminCategories, useAssetVersionId)

&#9;if not userIdsForSets then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is nil, should be a table of number ids&quot;)
&#9;end
&#9;if type(userIdsForSets) ~= &quot;table&quot; and type(userIdsForSets) ~= &quot;userdata&quot; then
&#9;&#9;error(&quot;CreateSetPanel: userIdsForSets (first arg) is of type &quot; ..type(userIdsForSets) .. &quot;, should be of type table or userdata&quot;)
&#9;end
&#9;if not objectSelected then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is nil, should be a callback function!&quot;)
&#9;end
&#9;if type(objectSelected) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: objectSelected (second arg) is of type &quot; .. type(objectSelected) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;if dialogClosed and type(dialogClosed) ~= &quot;function&quot; then
&#9;&#9;error(&quot;CreateSetPanel: dialogClosed (third arg) is of type &quot; .. type(dialogClosed) .. &quot;, should be of type function!&quot;)
&#9;end
&#9;
&#9;if showAdminCategories == nil then -- by default, don&apos;t show beta sets
&#9;&#9;showAdminCategories = false
&#9;end

&#9;local arrayPosition = 1
&#9;local insertButtons = {}
&#9;local insertButtonCons = {}
&#9;local contents = nil
&#9;local setGui = nil

&#9;-- used for water selections
&#9;local waterForceDirection = &quot;NegX&quot;
&#9;local waterForce = &quot;None&quot;
&#9;local waterGui, waterTypeChangedEvent = nil
&#9;
&#9;local Data = {}
&#9;Data.CurrentCategory = nil
&#9;Data.Category = {}
&#9;local SetCache = {}
&#9;
&#9;local userCategoryButtons = nil
&#9;
&#9;local buttonWidth = 64
&#9;local buttonHeight = buttonWidth
&#9;
&#9;local SmallThumbnailUrl = nil
&#9;local LargeThumbnailUrl = nil
&#9;local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl:lower()
&#9;local AssetGameUrl = string.gsub(BaseUrl, &quot;www&quot;, &quot;assetgame&quot;)
&#9;
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = AssetGameUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = AssetGameUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = AssetGameUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = AssetGameUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
&#9;&#9;
&#9;local function drillDownSetZIndex(parent, index)
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;if children[i]:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;children[i].ZIndex = index
&#9;&#9;&#9;end
&#9;&#9;&#9;drillDownSetZIndex(children[i], index)
&#9;&#9;end
&#9;end
&#9;
&#9;-- for terrain stamping
&#9;local currTerrainDropDownFrame = nil
&#9;local terrainShapes = {&quot;Block&quot;,&quot;Vertical Ramp&quot;,&quot;Corner Wedge&quot;,&quot;Inverse Corner Wedge&quot;,&quot;Horizontal Ramp&quot;,&quot;Auto-Wedge&quot;}
&#9;local terrainShapeMap = {}
&#9;for i = 1, #terrainShapes do
&#9;&#9;terrainShapeMap[terrainShapes[i]] = i - 1
&#9;end&#9;
&#9;terrainShapeMap[terrainShapes[#terrainShapes]] = 6

&#9;local function createWaterGui()
&#9;&#9;local waterForceDirections = {&quot;NegX&quot;,&quot;X&quot;,&quot;NegY&quot;,&quot;Y&quot;,&quot;NegZ&quot;,&quot;Z&quot;}
&#9;&#9;local waterForces = {&quot;None&quot;, &quot;Small&quot;, &quot;Medium&quot;, &quot;Strong&quot;, &quot;Max&quot;}

&#9;&#9;local waterFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;waterFrame.Name = &quot;WaterFrame&quot;
&#9;&#9;waterFrame.Style = Enum.FrameStyle.RobloxSquare
&#9;&#9;waterFrame.Size = UDim2.new(0,150,0,110)
&#9;&#9;waterFrame.Visible = false

&#9;&#9;local waterForceLabel = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;waterForceLabel.Name = &quot;WaterForceLabel&quot;
&#9;&#9;waterForceLabel.BackgroundTransparency = 1
&#9;&#9;waterForceLabel.Size = UDim2.new(1,0,0,12)
&#9;&#9;waterForceLabel.Font = Enum.Font.ArialBold
&#9;&#9;waterForceLabel.FontSize = Enum.FontSize.Size12
&#9;&#9;waterForceLabel.TextColor3 = Color3.new(1,1,1)
&#9;&#9;waterForceLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;waterForceLabel.Text = &quot;Water Force&quot;
&#9;&#9;waterForceLabel.Parent = waterFrame

&#9;&#9;local waterForceDirLabel = waterForceLabel:Clone()
&#9;&#9;waterForceDirLabel.Name = &quot;WaterForceDirectionLabel&quot;
&#9;&#9;waterForceDirLabel.Text = &quot;Water Force Direction&quot;
&#9;&#9;waterForceDirLabel.Position = UDim2.new(0,0,0,50)
&#9;&#9;waterForceDirLabel.Parent = waterFrame

&#9;&#9;local waterTypeChangedEvent = Instance.new(&quot;BindableEvent&quot;,waterFrame)
&#9;&#9;waterTypeChangedEvent.Name = &quot;WaterTypeChangedEvent&quot;

&#9;&#9;local waterForceDirectionSelectedFunc = function(newForceDirection)
&#9;&#9;&#9;waterForceDirection = newForceDirection
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end
&#9;&#9;local waterForceSelectedFunc = function(newForce)
&#9;&#9;&#9;waterForce = newForce
&#9;&#9;&#9;waterTypeChangedEvent:Fire({waterForce, waterForceDirection})
&#9;&#9;end

&#9;&#9;local waterForceDirectionDropDown, forceWaterDirectionSelection = t.CreateDropDownMenu(waterForceDirections, waterForceDirectionSelectedFunc)
&#9;&#9;waterForceDirectionDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDirectionDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;forceWaterDirectionSelection(&quot;NegX&quot;)
&#9;&#9;waterForceDirectionDropDown.Parent = waterForceDirLabel

&#9;&#9;local waterForceDropDown, forceWaterForceSelection = t.CreateDropDownMenu(waterForces, waterForceSelectedFunc)
&#9;&#9;forceWaterForceSelection(&quot;None&quot;)
&#9;&#9;waterForceDropDown.Size = UDim2.new(1,0,0,25)
&#9;&#9;waterForceDropDown.Position = UDim2.new(0,0,1,3)
&#9;&#9;waterForceDropDown.Parent = waterForceLabel

&#9;&#9;return waterFrame, waterTypeChangedEvent
&#9;end

&#9;-- Helper Function that contructs gui elements
&#9;local function createSetGui()
&#9;
&#9;&#9;local setGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;setGui.Name = &quot;SetGui&quot;
&#9;&#9;
&#9;&#9;local setPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;setPanel.Name = &quot;SetPanel&quot;
&#9;&#9;setPanel.Active = true
&#9;&#9;setPanel.BackgroundTransparency = 1
&#9;&#9;if position then
&#9;&#9;&#9;setPanel.Position = position
&#9;&#9;else
&#9;&#9;&#9;setPanel.Position = UDim2.new(0.2, 29, 0.1, 24)
&#9;&#9;end
&#9;&#9;if size then
&#9;&#9;&#9;setPanel.Size = size
&#9;&#9;else
&#9;&#9;&#9;setPanel.Size = UDim2.new(0.6, -58, 0.64, 0)
&#9;&#9;end
&#9;&#9;setPanel.Style = Enum.FrameStyle.RobloxRound
&#9;&#9;setPanel.ZIndex = 6
&#9;&#9;setPanel.Parent = setGui
&#9;&#9;
&#9;&#9;&#9;-- Children of SetPanel
&#9;&#9;&#9;local itemPreview = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;itemPreview.Name = &quot;ItemPreview&quot;
&#9;&#9;&#9;itemPreview.BackgroundTransparency = 1
&#9;&#9;&#9;itemPreview.Position = UDim2.new(0.8,5,0.085,0)
&#9;&#9;&#9;itemPreview.Size = UDim2.new(0.21,0,0.9,0)
&#9;&#9;&#9;itemPreview.ZIndex = 6
&#9;&#9;&#9;itemPreview.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of ItemPreview
&#9;&#9;&#9;&#9;local textPanel = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;textPanel.Name = &quot;TextPanel&quot;
&#9;&#9;&#9;&#9;textPanel.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;textPanel.Position = UDim2.new(0,0,0.45,0)
&#9;&#9;&#9;&#9;textPanel.Size = UDim2.new(1,0,0.55,0)
&#9;&#9;&#9;&#9;textPanel.ZIndex = 6
&#9;&#9;&#9;&#9;textPanel.Parent = itemPreview
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- Children of TextPanel
&#9;&#9;&#9;&#9;&#9;local rolloverText = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;&#9;rolloverText.Name = &quot;RolloverText&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;rolloverText.Size = UDim2.new(1,0,0,48)
&#9;&#9;&#9;&#9;&#9;rolloverText.ZIndex = 6
&#9;&#9;&#9;&#9;&#9;rolloverText.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;&#9;rolloverText.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;&#9;rolloverText.Text = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;rolloverText.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;&#9;rolloverText.TextWrap = true
&#9;&#9;&#9;&#9;&#9;rolloverText.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;&#9;rolloverText.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;&#9;rolloverText.Parent = textPanel
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local largePreview = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;largePreview.Name = &quot;LargePreview&quot;
&#9;&#9;&#9;&#9;largePreview.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;largePreview.Image = &quot;&quot;
&#9;&#9;&#9;&#9;largePreview.Size = UDim2.new(1,0,0,170)
&#9;&#9;&#9;&#9;largePreview.ZIndex = 6
&#9;&#9;&#9;&#9;largePreview.Parent = itemPreview
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;local sets = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;sets.Name = &quot;Sets&quot;
&#9;&#9;&#9;sets.BackgroundTransparency = 1
&#9;&#9;&#9;sets.Position = UDim2.new(0,0,0,5)
&#9;&#9;&#9;sets.Size = UDim2.new(0.23,0,1,-5)
&#9;&#9;&#9;sets.ZIndex = 6
&#9;&#9;&#9;sets.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Sets
&#9;&#9;&#9;&#9;local line = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;line.Name = &quot;Line&quot;
&#9;&#9;&#9;&#9;line.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;line.BackgroundTransparency = 0.7
&#9;&#9;&#9;&#9;line.BorderSizePixel = 0
&#9;&#9;&#9;&#9;line.Position = UDim2.new(1,-3,0.06,0)
&#9;&#9;&#9;&#9;line.Size = UDim2.new(0,3,0.9,0)
&#9;&#9;&#9;&#9;line.ZIndex = 6
&#9;&#9;&#9;&#9;line.Parent = sets
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsLists, controlFrame = t.CreateTrueScrollingFrame()
&#9;&#9;&#9;&#9;setsLists.Size = UDim2.new(1,-6,0.94,0)
&#9;&#9;&#9;&#9;setsLists.Position = UDim2.new(0,0,0.06,0)
&#9;&#9;&#9;&#9;setsLists.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsLists.Name = &quot;SetsLists&quot;
&#9;&#9;&#9;&#9;setsLists.ZIndex = 6
&#9;&#9;&#9;&#9;setsLists.Parent = sets
&#9;&#9;&#9;&#9;drillDownSetZIndex(controlFrame, 7)
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local setsHeader = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;&#9;&#9;setsHeader.Name = &quot;SetsHeader&quot;
&#9;&#9;&#9;&#9;setsHeader.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setsHeader.Size = UDim2.new(0,47,0,24)
&#9;&#9;&#9;&#9;setsHeader.ZIndex = 6
&#9;&#9;&#9;&#9;setsHeader.Font = Enum.Font.ArialBold
&#9;&#9;&#9;&#9;setsHeader.FontSize = Enum.FontSize.Size24
&#9;&#9;&#9;&#9;setsHeader.Text = &quot;Sets&quot;
&#9;&#9;&#9;&#9;setsHeader.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setsHeader.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;&#9;&#9;setsHeader.TextYAlignment = Enum.TextYAlignment.Top
&#9;&#9;&#9;&#9;setsHeader.Parent = sets
&#9;&#9;&#9;
&#9;&#9;&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;&#9;&#9;cancelButton.Position = UDim2.new(1,-32,0,-2)
&#9;&#9;&#9;cancelButton.Size = UDim2.new(0,34,0,34)
&#9;&#9;&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;&#9;&#9;cancelButton.ZIndex = 6
&#9;&#9;&#9;cancelButton.Text = &quot;&quot;
&#9;&#9;&#9;cancelButton.Modal = true
&#9;&#9;&#9;cancelButton.Parent = setPanel
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- Children of Cancel Button
&#9;&#9;&#9;&#9;local cancelImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;&#9;&#9;cancelImage.Name = &quot;CancelImage&quot;
&#9;&#9;&#9;&#9;cancelImage.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;cancelImage.Image = &quot;https://www.pengin.xyz/asset/?id=54135717&quot;
&#9;&#9;&#9;&#9;cancelImage.Position = UDim2.new(0,-2,0,-2)
&#9;&#9;&#9;&#9;cancelImage.Size = UDim2.new(0,16,0,16)
&#9;&#9;&#9;&#9;cancelImage.ZIndex = 6
&#9;&#9;&#9;&#9;cancelImage.Parent = cancelButton
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;return setGui
&#9;end
&#9;
&#9;local function createSetButton(text)
&#9;&#9;local setButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;
&#9;&#9;if text then setButton.Text = text
&#9;&#9;else setButton.Text = &quot;&quot; end
&#9;&#9;
&#9;&#9;setButton.AutoButtonColor = false
&#9;&#9;setButton.BackgroundTransparency = 1
&#9;&#9;setButton.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.BorderSizePixel = 0
&#9;&#9;setButton.Size = UDim2.new(1,-5,0,18)
&#9;&#9;setButton.ZIndex = 6
&#9;&#9;setButton.Visible = false
&#9;&#9;setButton.Font = Enum.Font.Arial
&#9;&#9;setButton.FontSize = Enum.FontSize.Size18
&#9;&#9;setButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;
&#9;&#9;return setButton
&#9;end
&#9;
&#9;local function buildSetButton(name, setId, setImageId, i,  count)
&#9;&#9;local button = createSetButton(name)
&#9;&#9;button.Text = name
&#9;&#9;button.Name = &quot;SetButton&quot;
&#9;&#9;button.Visible = true
&#9;&#9;
&#9;&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;&#9;setValue.Name = &quot;SetId&quot;
&#9;&#9;setValue.Value = setId
&#9;&#9;setValue.Parent = button

&#9;&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;setName.Name = &quot;SetName&quot;
&#9;&#9;setName.Value = name
&#9;&#9;setName.Parent = button

&#9;&#9;return button
&#9;end
&#9;
&#9;local function processCategory(sets)
&#9;&#9;local setButtons = {}
&#9;&#9;local numSkipped = 0
&#9;&#9;for i = 1, #sets do
&#9;&#9;&#9;if not showAdminCategories and sets[i].Name == &quot;Beta&quot; then
&#9;&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setButtons[i - numSkipped] = buildSetButton(sets[i].Name, sets[i].CategoryId, sets[i].ImageAssetId, i - numSkipped, #sets)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return setButtons
&#9;end
&#9;
&#9;local function handleResize()
&#9;&#9;wait() -- neccessary to insure heartbeat happened
&#9;&#9;
&#9;&#9;local itemPreview = setGui.SetPanel.ItemPreview
&#9;&#9;
&#9;&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
&#9;end
&#9;
&#9;local function makeInsertAssetButton()
&#9;&#9;local insertAssetButtonExample = Instance.new(&quot;Frame&quot;)
&#9;&#9;insertAssetButtonExample.Name = &quot;InsertAssetButtonExample&quot;
&#9;&#9;insertAssetButtonExample.Position = UDim2.new(0,128,0,64)
&#9;&#9;insertAssetButtonExample.Size = UDim2.new(0,64,0,64)
&#9;&#9;insertAssetButtonExample.BackgroundTransparency = 1
&#9;&#9;insertAssetButtonExample.ZIndex = 6
&#9;&#9;insertAssetButtonExample.Visible = false

&#9;&#9;local assetId = Instance.new(&quot;IntValue&quot;)
&#9;&#9;assetId.Name = &quot;AssetId&quot;
&#9;&#9;assetId.Value = 0
&#9;&#9;assetId.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;local assetName = Instance.new(&quot;StringValue&quot;)
&#9;&#9;assetName.Name = &quot;AssetName&quot;
&#9;&#9;assetName.Value = &quot;&quot;
&#9;&#9;assetName.Parent = insertAssetButtonExample

&#9;&#9;local button = Instance.new(&quot;TextButton&quot;)
&#9;&#9;button.Name = &quot;Button&quot;
&#9;&#9;button.Text = &quot;&quot;
&#9;&#9;button.Style = Enum.ButtonStyle.RobloxButton
&#9;&#9;button.Position = UDim2.new(0.025,0,0.025,0)
&#9;&#9;button.Size = UDim2.new(0.95,0,0.95,0)
&#9;&#9;button.ZIndex = 6
&#9;&#9;button.Parent = insertAssetButtonExample

&#9;&#9;local buttonImage = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;buttonImage.Name = &quot;ButtonImage&quot;
&#9;&#9;buttonImage.Image = &quot;&quot;
&#9;&#9;buttonImage.Position = UDim2.new(0,-7,0,-7)
&#9;&#9;buttonImage.Size = UDim2.new(1,14,1,14)
&#9;&#9;buttonImage.BackgroundTransparency = 1
&#9;&#9;buttonImage.ZIndex = 7
&#9;&#9;buttonImage.Parent = button

&#9;&#9;local configIcon = buttonImage:clone()
&#9;&#9;configIcon.Name = &quot;ConfigIcon&quot;
&#9;&#9;configIcon.Visible = false
&#9;&#9;configIcon.Position = UDim2.new(1,-23,1,-24)
&#9;&#9;configIcon.Size = UDim2.new(0,16,0,16)
&#9;&#9;configIcon.Image = &quot;&quot;
&#9;&#9;configIcon.ZIndex = 6
&#9;&#9;configIcon.Parent = insertAssetButtonExample
&#9;&#9;
&#9;&#9;return insertAssetButtonExample
&#9;end
&#9;
&#9;local function showLargePreview(insertButton)
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;&#9;setGui.SetPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;&#9;setGui.SetPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectTerrainShape(shape)
&#9;&#9;if currTerrainDropDownFrame then
&#9;&#9;&#9;objectSelected(tostring(currTerrainDropDownFrame.AssetName.Value), tonumber(currTerrainDropDownFrame.AssetId.Value), shape)
&#9;&#9;end
&#9;end
&#9;
&#9;local function createTerrainTypeButton(name, parent)
&#9;&#9;local dropDownTextButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;dropDownTextButton.Name = name .. &quot;Button&quot;
&#9;&#9;dropDownTextButton.Font = Enum.Font.ArialBold
&#9;&#9;dropDownTextButton.FontSize = Enum.FontSize.Size14
&#9;&#9;dropDownTextButton.BorderSizePixel = 0
&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;dropDownTextButton.Text = name
&#9;&#9;dropDownTextButton.TextXAlignment = Enum.TextXAlignment.Left
&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;dropDownTextButton.ZIndex = parent.ZIndex + 1
&#9;&#9;dropDownTextButton.Size = UDim2.new(0,parent.Size.X.Offset - 2,0,16)
&#9;&#9;dropDownTextButton.Position = UDim2.new(0,1,0,0)

&#9;&#9;dropDownTextButton.MouseEnter:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 0
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(0,0,0)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseLeave:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;end)

&#9;&#9;dropDownTextButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;dropDownTextButton.BackgroundTransparency = 1
&#9;&#9;&#9;dropDownTextButton.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;if dropDownTextButton.Parent and dropDownTextButton.Parent:IsA(&quot;GuiObject&quot;) then
&#9;&#9;&#9;&#9;dropDownTextButton.Parent.Visible = false
&#9;&#9;&#9;end
&#9;&#9;&#9;selectTerrainShape(terrainShapeMap[dropDownTextButton.Text])
&#9;&#9;end)

&#9;&#9;return dropDownTextButton
&#9;end
&#9;
&#9;local function createTerrainDropDownMenu(zIndex)
&#9;&#9;local dropDown = Instance.new(&quot;Frame&quot;)
&#9;&#9;dropDown.Name = &quot;TerrainDropDown&quot;
&#9;&#9;dropDown.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;dropDown.BorderColor3 = Color3.new(1,0,0)
&#9;&#9;dropDown.Size = UDim2.new(0,200,0,0)
&#9;&#9;dropDown.Visible = false
&#9;&#9;dropDown.ZIndex = zIndex
&#9;&#9;dropDown.Parent = setGui

&#9;&#9;for i = 1, #terrainShapes do
&#9;&#9;&#9;local shapeButton = createTerrainTypeButton(terrainShapes[i],dropDown)
&#9;&#9;&#9;shapeButton.Position = UDim2.new(0,1,0,(i - 1) * (shapeButton.Size.Y.Offset))
&#9;&#9;&#9;shapeButton.Parent = dropDown
&#9;&#9;&#9;dropDown.Size = UDim2.new(0,200,0,dropDown.Size.Y.Offset + (shapeButton.Size.Y.Offset))
&#9;&#9;end

&#9;&#9;dropDown.MouseLeave:connect(function()
&#9;&#9;&#9;dropDown.Visible = false
&#9;&#9;end)
&#9;end

&#9;
&#9;local function createDropDownMenuButton(parent)
&#9;&#9;local dropDownButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;dropDownButton.Name = &quot;DropDownButton&quot;
&#9;&#9;dropDownButton.Image = &quot;https://www.pengin.xyz/asset/?id=67581509&quot;
&#9;&#9;dropDownButton.BackgroundTransparency = 1
&#9;&#9;dropDownButton.Size = UDim2.new(0,16,0,16)
&#9;&#9;dropDownButton.Position = UDim2.new(1,-24,0,6)
&#9;&#9;dropDownButton.ZIndex = parent.ZIndex + 2
&#9;&#9;dropDownButton.Parent = parent
&#9;&#9;
&#9;&#9;if not setGui:FindFirstChild(&quot;TerrainDropDown&quot;) then
&#9;&#9;&#9;createTerrainDropDownMenu(8)
&#9;&#9;end
&#9;&#9;
&#9;&#9;dropDownButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;setGui.TerrainDropDown.Visible = true
&#9;&#9;&#9;setGui.TerrainDropDown.Position = UDim2.new(0,parent.AbsolutePosition.X,0,parent.AbsolutePosition.Y)
&#9;&#9;&#9;currTerrainDropDownFrame = parent
&#9;&#9;end)
&#9;end
&#9;
&#9;local function buildInsertButton()
&#9;&#9;local insertButton = makeInsertAssetButton()
&#9;&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;&#9;insertButton.Visible = true

&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;createDropDownMenuButton(insertButton)
&#9;&#9;end

&#9;&#9;local lastEnter = nil
&#9;&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;&#9;lastEnter = insertButton
&#9;&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end)
&#9;&#9;return insertButton, mouseEnterCon
&#9;end
&#9;
&#9;local function realignButtonGrid(columns)
&#9;&#9;local x = 0
&#9;&#9;local y = 0 
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i].Position = UDim2.new(0, buttonWidth * x, 0, buttonHeight * y)
&#9;&#9;&#9;x = x + 1
&#9;&#9;&#9;if x &gt;= columns then
&#9;&#9;&#9;&#9;x = 0
&#9;&#9;&#9;&#9;y = y + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;local function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;&#9;if visible then
&#9;&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;&#9;if insertFrame:findFirstChild(&quot;Button&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;&#9;-- special case for water, show water selection gui
&#9;&#9;&#9;&#9;&#9;local isWaterSelected = (name == &quot;Water&quot;) and (Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot;)
&#9;&#9;&#9;&#9;&#9;waterGui.Visible = isWaterSelected
&#9;&#9;&#9;&#9;&#9;if isWaterSelected then
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId), nil)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;objectSelected(name, tonumber(assetId))
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;)
&#9;&#9;&#9;insertFrame.Visible = true
&#9;&#9;else
&#9;&#9;&#9;insertFrame.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local function loadSectionOfItems(setGui, rows, columns)
&#9;&#9;local pageSize = rows * columns

&#9;&#9;if arrayPosition &gt; #contents then return end

&#9;&#9;local origArrayPos = arrayPosition

&#9;&#9;local yCopy = 0
&#9;&#9;for i = 1, pageSize + 1 do 
&#9;&#9;&#9;if arrayPosition &gt;= #contents + 1 then
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end

&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton()
&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;insertButtons[arrayPosition].Parent = setGui.SetPanel.ItemsFrame
&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;end
&#9;&#9;realignButtonGrid(columns)

&#9;&#9;local indexCopy = origArrayPos
&#9;&#9;for index = origArrayPos, arrayPosition do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index] then

&#9;&#9;&#9;&#9;&#9;-- we don&apos;t want water to have a drop down button
&#9;&#9;&#9;&#9;&#9;if contents[index].Name == &quot;Water&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetName == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;insertButtons[index]:FindFirstChild(&quot;DropDownButton&quot;,true):Destroy()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;&#9;indexCopy = index
&#9;&#9;end
&#9;end
&#9;
&#9;local function setSetIndex()
&#9;&#9;Data.Category[Data.CurrentCategory].Index = 0

&#9;&#9;rows = 7
&#9;&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;&#9;contents = Data.Category[Data.CurrentCategory].Contents
&#9;&#9;if contents then
&#9;&#9;&#9;-- remove our buttons and their connections
&#9;&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;&#9;end
&#9;&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;&#9;if insertButtonCons[i] then insertButtonCons[i]:disconnect() end
&#9;&#9;&#9;end
&#9;&#9;&#9;insertButtonCons = {}
&#9;&#9;&#9;insertButtons = {}

&#9;&#9;&#9;arrayPosition = 1
&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectSet(button, setName, setId, setIndex)
&#9;&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;&#9;end
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategoryPage(buttons, page)
&#9;&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function selectCategory(category)
&#9;&#9;selectCategoryPage(category, 0)
&#9;end
&#9;
&#9;local function resetAllSetButtonSelection()
&#9;&#9;local setButtons = setGui.SetPanel.Sets.SetsLists:GetChildren()
&#9;&#9;for i = 1, #setButtons do
&#9;&#9;&#9;if setButtons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;setButtons[i].Selected = false
&#9;&#9;&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;local function populateSetsFrame()
&#9;&#9;local currRow = 0
&#9;&#9;for i = 1, #userCategoryButtons do
&#9;&#9;&#9;local button = userCategoryButtons[i]
&#9;&#9;&#9;button.Visible = true
&#9;&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.Size.Y.Offset)
&#9;&#9;&#9;button.Parent = setGui.SetPanel.Sets.SetsLists
&#9;&#9;&#9;
&#9;&#9;&#9;if i == 1 then -- we will have this selected by default, so show it
&#9;&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;&#9;button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;selectSet(button, button.Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;end)

&#9;&#9;&#9;currRow = currRow + 1
&#9;&#9;end

&#9;&#9;local buttons =  setGui.SetPanel.Sets.SetsLists:GetChildren()

&#9;&#9;-- set first category as loaded for default
&#9;&#9;if buttons then
&#9;&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;&#9;if buttons[i]:IsA(&quot;TextButton&quot;) then
&#9;&#9;&#9;&#9;&#9;selectSet(buttons[i], buttons[i].Text, userCategoryButtons[i].SetId.Value, 0)
&#9;&#9;&#9;&#9;&#9;selectCategory(userCategoryButtons)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;setGui = createSetGui()
&#9;waterGui, waterTypeChangedEvent = createWaterGui()
&#9;waterGui.Position = UDim2.new(0,55,0,0)
&#9;waterGui.Parent = setGui
&#9;setGui.Changed:connect(function(prop) -- this resizes the preview image to always be the right size
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;handleResize()
&#9;&#9;&#9;setSetIndex()
&#9;&#9;end
&#9;end)
&#9;
&#9;local scrollFrame, controlFrame = t.CreateTrueScrollingFrame()
&#9;scrollFrame.Size = UDim2.new(0.54,0,0.85,0)
&#9;scrollFrame.Position = UDim2.new(0.24,0,0.085,0)
&#9;scrollFrame.Name = &quot;ItemsFrame&quot;
&#9;scrollFrame.ZIndex = 6
&#9;scrollFrame.Parent = setGui.SetPanel
&#9;scrollFrame.BackgroundTransparency = 1

&#9;drillDownSetZIndex(controlFrame,7)

&#9;controlFrame.Parent = setGui.SetPanel
&#9;controlFrame.Position = UDim2.new(0.76, 5, 0, 0)

&#9;local debounce = false
&#9;controlFrame.ScrollBottom.Changed:connect(function(prop)
&#9;&#9;if controlFrame.ScrollBottom.Value == true then
&#9;&#9;&#9;if debounce then return end
&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;loadSectionOfItems(setGui, rows, columns)
&#9;&#9;&#9;debounce = false
&#9;&#9;end
&#9;end)

&#9;local userData = {}
&#9;for id = 1, #userIdsForSets do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserSets(userIdsForSets[id])
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then -- we want high scalability parts to show first
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;
&#9;end
&#9;if userData then
&#9;&#9;userCategoryButtons = processCategory(userData)
&#9;end

&#9;rows = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;columns = math.floor(setGui.SetPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;setGui.SetPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;if dialogClosed then dialogClosed() end
&#9;end)
&#9;
&#9;local setVisibilityFunction = function(visible)
&#9;&#9;if visible then
&#9;&#9;&#9;setGui.SetPanel.Visible = true
&#9;&#9;else
&#9;&#9;&#9;setGui.SetPanel.Visible = false
&#9;&#9;end
&#9;end
&#9;
&#9;local getVisibilityFunction = function()
&#9;&#9;if setGui then
&#9;&#9;&#9;if setGui:FindFirstChild(&quot;SetPanel&quot;) then
&#9;&#9;&#9;&#9;return setGui.SetPanel.Visible
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;
&#9;&#9;return false
&#9;end
&#9;
&#9;return setGui, setVisibilityFunction, getVisibilityFunction, waterTypeChangedEvent
end

t.CreateTerrainMaterialSelector = function(size,position)
&#9;local terrainMaterialSelectionChanged = Instance.new(&quot;BindableEvent&quot;)
&#9;terrainMaterialSelectionChanged.Name = &quot;TerrainMaterialSelectionChanged&quot;

&#9;local selectedButton = nil

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.Name = &quot;TerrainMaterialSelector&quot;
&#9;if size then
&#9;&#9;frame.Size = size
&#9;else
&#9;&#9;frame.Size = UDim2.new(0, 245, 0, 230)
&#9;end
&#9;if position then
&#9;&#9;frame.Position = position
&#9;end
&#9;frame.BorderSizePixel = 0
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.Active = true

&#9;terrainMaterialSelectionChanged.Parent = frame

&#9;local waterEnabled = true -- todo: turn this on when water is ready

&#9;local materialToImageMap = {}
&#9;local materialNames = {&quot;Grass&quot;, &quot;Sand&quot;, &quot;Brick&quot;, &quot;Granite&quot;, &quot;Asphalt&quot;, &quot;Iron&quot;, &quot;Aluminum&quot;, &quot;Gold&quot;, &quot;Plank&quot;, &quot;Log&quot;, &quot;Gravel&quot;, &quot;Cinder Block&quot;, &quot;Stone Wall&quot;, &quot;Concrete&quot;, &quot;Plastic (red)&quot;, &quot;Plastic (blue)&quot;}
&#9;if waterEnabled then
&#9;&#9;table.insert(materialNames,&quot;Water&quot;)
&#9;end
&#9;local currentMaterial = 1

&#9;function getEnumFromName(choice)
&#9;&#9;if choice == &quot;Grass&quot; then return 1 end
&#9;&#9;if choice == &quot;Sand&quot; then return 2 end 
&#9;&#9;if choice == &quot;Erase&quot; then return 0 end
&#9;&#9;if choice == &quot;Brick&quot; then return 3 end
&#9;&#9;if choice == &quot;Granite&quot; then return 4 end
&#9;&#9;if choice == &quot;Asphalt&quot; then return 5 end
&#9;&#9;if choice == &quot;Iron&quot; then return 6 end
&#9;&#9;if choice == &quot;Aluminum&quot; then return 7 end
&#9;&#9;if choice == &quot;Gold&quot; then return 8 end
&#9;&#9;if choice == &quot;Plank&quot; then return 9 end
&#9;&#9;if choice == &quot;Log&quot; then return 10 end
&#9;&#9;if choice == &quot;Gravel&quot; then return 11 end
&#9;&#9;if choice == &quot;Cinder Block&quot; then return 12 end
&#9;&#9;if choice == &quot;Stone Wall&quot; then return 13 end
&#9;&#9;if choice == &quot;Concrete&quot; then return 14 end
&#9;&#9;if choice == &quot;Plastic (red)&quot; then return 15 end
&#9;&#9;if choice == &quot;Plastic (blue)&quot; then return 16 end
&#9;&#9;if choice == &quot;Water&quot; then return 17 end
&#9;end

&#9;function getNameFromEnum(choice)
&#9;&#9;if choice == Enum.CellMaterial.Grass or choice == 1 then return &quot;Grass&quot;end
&#9;&#9;if choice == Enum.CellMaterial.Sand or choice == 2 then return &quot;Sand&quot; end 
&#9;&#9;if choice == Enum.CellMaterial.Empty or choice == 0 then return &quot;Erase&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Brick or choice == 3 then return &quot;Brick&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Granite or choice == 4 then return &quot;Granite&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Asphalt or choice == 5 then return &quot;Asphalt&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Iron or choice == 6 then return &quot;Iron&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Aluminum or choice == 7 then return &quot;Aluminum&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gold or choice == 8 then return &quot;Gold&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodPlank or choice == 9 then return &quot;Plank&quot; end
&#9;&#9;if choice == Enum.CellMaterial.WoodLog or choice == 10 then return &quot;Log&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Gravel or choice == 11 then return &quot;Gravel&quot; end
&#9;&#9;if choice == Enum.CellMaterial.CinderBlock or choice == 12 then return &quot;Cinder Block&quot; end
&#9;&#9;if choice == Enum.CellMaterial.MossyStone or choice == 13 then return &quot;Stone Wall&quot; end
&#9;&#9;if choice == Enum.CellMaterial.Cement or choice == 14 then return &quot;Concrete&quot; end
&#9;&#9;if choice == Enum.CellMaterial.RedPlastic or choice == 15 then return &quot;Plastic (red)&quot; end
&#9;&#9;if choice == Enum.CellMaterial.BluePlastic or choice == 16 then return &quot;Plastic (blue)&quot; end

&#9;&#9;if waterEnabled then
&#9;&#9;&#9;if choice == Enum.CellMaterial.Water or choice == 17 then return &quot;Water&quot; end
&#9;&#9;end
&#9;end


&#9;local function updateMaterialChoice(choice)
&#9;&#9;currentMaterial = getEnumFromName(choice)
&#9;&#9;terrainMaterialSelectionChanged:Fire(currentMaterial)
&#9;end

&#9;-- we so need a better way to do this
&#9;for i,v in pairs(materialNames) do
&#9;&#9;materialToImageMap[v] = {}
&#9;&#9;if v == &quot;Grass&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=56563112&quot;
&#9;&#9;elseif v == &quot;Sand&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=62356652&quot;
&#9;&#9;elseif v == &quot;Brick&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=65961537&quot;
&#9;&#9;elseif v == &quot;Granite&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532153&quot;
&#9;&#9;elseif v == &quot;Asphalt&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532038&quot;
&#9;&#9;elseif v == &quot;Iron&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532093&quot;
&#9;&#9;elseif v == &quot;Aluminum&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67531995&quot;
&#9;&#9;elseif v == &quot;Gold&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532118&quot;
&#9;&#9;elseif v == &quot;Plastic (red)&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67531848&quot;
&#9;&#9;elseif v == &quot;Plastic (blue)&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67531924&quot;
&#9;&#9;elseif v == &quot;Plank&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532015&quot;
&#9;&#9;elseif v == &quot;Log&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532051&quot;
&#9;&#9;elseif v == &quot;Gravel&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532206&quot;
&#9;&#9;elseif v == &quot;Cinder Block&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532103&quot;
&#9;&#9;elseif v == &quot;Stone Wall&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67531804&quot;
&#9;&#9;elseif v == &quot;Concrete&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=67532059&quot;
&#9;&#9;elseif v == &quot;Water&quot; then materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=81407474&quot;
&#9;&#9;else materialToImageMap[v].Regular = &quot;https://www.pengin.xyz/asset/?id=66887593&quot; -- fill in the rest here!!
&#9;&#9;end
&#9;end

&#9;local scrollFrame, scrollUp, scrollDown, recalculateScroll = t.CreateScrollingFrame(nil,&quot;grid&quot;)
&#9;scrollFrame.Size = UDim2.new(0.85,0,1,0)
&#9;scrollFrame.Position = UDim2.new(0,0,0,0)
&#9;scrollFrame.Parent = frame

&#9;scrollUp.Parent = frame
&#9;scrollUp.Visible = true
&#9;scrollUp.Position = UDim2.new(1,-19,0,0)

&#9;scrollDown.Parent = frame
&#9;scrollDown.Visible = true
&#9;scrollDown.Position = UDim2.new(1,-19,1,-17)

&#9;local function goToNewMaterial(buttonWrap, materialName)
&#9;&#9;updateMaterialChoice(materialName)
&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;selectedButton.BackgroundTransparency = 1
&#9;&#9;selectedButton = buttonWrap
&#9;end

&#9;local function createMaterialButton(name)&#9;
&#9;&#9;local buttonWrap = Instance.new(&quot;TextButton&quot;)
&#9;&#9;buttonWrap.Text = &quot;&quot;
&#9;&#9;buttonWrap.Size = UDim2.new(0,32,0,32)
&#9;&#9;buttonWrap.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;buttonWrap.BorderSizePixel = 0
&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;buttonWrap.AutoButtonColor = false
&#9;&#9;buttonWrap.Name = tostring(name)
&#9;&#9;
&#9;&#9;local imageButton = Instance.new(&quot;ImageButton&quot;)
&#9;&#9;imageButton.AutoButtonColor = false
&#9;&#9;imageButton.BackgroundTransparency = 1
&#9;&#9;imageButton.Size = UDim2.new(0,30,0,30)
&#9;&#9;imageButton.Position = UDim2.new(0,1,0,1)
&#9;&#9;imageButton.Name = tostring(name)
&#9;&#9;imageButton.Parent = buttonWrap
&#9;&#9;imageButton.Image = materialToImageMap[name].Regular

&#9;&#9;local enumType = Instance.new(&quot;NumberValue&quot;)
&#9;&#9;enumType.Name = &quot;EnumType&quot;
&#9;&#9;enumType.Parent = buttonWrap
&#9;&#9;enumType.Value = 0
&#9;&#9;
&#9;&#9;imageButton.MouseEnter:connect(function()
&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;imageButton.MouseLeave:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;buttonWrap.BackgroundTransparency = 1
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;imageButton.MouseButton1Click:connect(function()
&#9;&#9;&#9;if selectedButton ~= buttonWrap then
&#9;&#9;&#9;&#9;goToNewMaterial(buttonWrap, tostring(name))
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;
&#9;&#9;return buttonWrap 
&#9;end

&#9;for i = 1, #materialNames do
&#9;&#9;local imageButton = createMaterialButton(materialNames[i])
&#9;&#9;
&#9;&#9;if materialNames[i] == &quot;Grass&quot; then -- always start with grass as the default
&#9;&#9;&#9;selectedButton = imageButton
&#9;&#9;&#9;imageButton.BackgroundTransparency = 0
&#9;&#9;end
&#9;&#9;
&#9;&#9;imageButton.Parent = scrollFrame
&#9;end

&#9;local forceTerrainMaterialSelection = function(newMaterialType)
&#9;&#9;if not newMaterialType then return end
&#9;&#9;if currentMaterial == newMaterialType then return end

&#9;&#9;local matName = getNameFromEnum(newMaterialType)
&#9;&#9;local buttons = scrollFrame:GetChildren()
&#9;&#9;for i = 1, #buttons do
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (blue)&quot; and matName == &quot;Plastic (blue)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if buttons[i].Name == &quot;Plastic (red)&quot; and matName == &quot;Plastic (red)&quot; then goToNewMaterial(buttons[i],matName) return end
&#9;&#9;&#9;if string.find(buttons[i].Name, matName) then
&#9;&#9;&#9;&#9;goToNewMaterial(buttons[i],matName)
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;frame.Changed:connect(function ( prop )
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;recalculateScroll()
&#9;&#9;end
&#9;end)

&#9;recalculateScroll()
&#9;return frame, terrainMaterialSelectionChanged, forceTerrainMaterialSelection
end

t.CreateLoadingFrame = function(name,size,position)
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(&quot;https://www.pengin.xyz/asset/?id=35238053&quot;)

&#9;local loadingFrame = Instance.new(&quot;Frame&quot;)
&#9;loadingFrame.Name = &quot;LoadingFrame&quot;
&#9;loadingFrame.Style = Enum.FrameStyle.RobloxRound

&#9;if size then loadingFrame.Size = size
&#9;else loadingFrame.Size = UDim2.new(0,300,0,160) end
&#9;if position then loadingFrame.Position = position 
&#9;else loadingFrame.Position = UDim2.new(0.5, -150, 0.5,-80) end

&#9;local loadingBar = Instance.new(&quot;Frame&quot;)
&#9;loadingBar.Name = &quot;LoadingBar&quot;
&#9;loadingBar.BackgroundColor3 = Color3.new(0,0,0)
&#9;loadingBar.BorderColor3 = Color3.new(79/255,79/255,79/255)
&#9;loadingBar.Position = UDim2.new(0,0,0,41)
&#9;loadingBar.Size = UDim2.new(1,0,0,30)
&#9;loadingBar.Parent = loadingFrame

&#9;&#9;local loadingGreenBar = Instance.new(&quot;ImageLabel&quot;)
&#9;&#9;loadingGreenBar.Name = &quot;LoadingGreenBar&quot;
&#9;&#9;loadingGreenBar.Image = &quot;https://www.pengin.xyz/asset/?id=35238053&quot;
&#9;&#9;loadingGreenBar.Position = UDim2.new(0,0,0,0)
&#9;&#9;loadingGreenBar.Size = UDim2.new(0,0,1,0)
&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;loadingGreenBar.Parent = loadingBar

&#9;&#9;local loadingPercent = Instance.new(&quot;TextLabel&quot;)
&#9;&#9;loadingPercent.Name = &quot;LoadingPercent&quot;
&#9;&#9;loadingPercent.BackgroundTransparency = 1
&#9;&#9;loadingPercent.Position = UDim2.new(0,0,1,0)
&#9;&#9;loadingPercent.Size = UDim2.new(1,0,0,14)
&#9;&#9;loadingPercent.Font = Enum.Font.Arial
&#9;&#9;loadingPercent.Text = &quot;0%&quot;
&#9;&#9;loadingPercent.FontSize = Enum.FontSize.Size14
&#9;&#9;loadingPercent.TextColor3 = Color3.new(1,1,1)
&#9;&#9;loadingPercent.Parent = loadingBar

&#9;local cancelButton = Instance.new(&quot;TextButton&quot;)
&#9;cancelButton.Name = &quot;CancelButton&quot;
&#9;cancelButton.Position = UDim2.new(0.5,-60,1,-40)
&#9;cancelButton.Size = UDim2.new(0,120,0,40)
&#9;cancelButton.Font = Enum.Font.Arial
&#9;cancelButton.FontSize = Enum.FontSize.Size18
&#9;cancelButton.TextColor3 = Color3.new(1,1,1)
&#9;cancelButton.Text = &quot;Cancel&quot;
&#9;cancelButton.Style = Enum.ButtonStyle.RobloxButton
&#9;cancelButton.Parent = loadingFrame

&#9;local loadingName = Instance.new(&quot;TextLabel&quot;)
&#9;loadingName.Name = &quot;loadingName&quot;
&#9;loadingName.BackgroundTransparency = 1
&#9;loadingName.Size = UDim2.new(1,0,0,18)
&#9;loadingName.Position = UDim2.new(0,0,0,2)
&#9;loadingName.Font = Enum.Font.Arial
&#9;loadingName.Text = name
&#9;loadingName.TextColor3 = Color3.new(1,1,1)
&#9;loadingName.TextStrokeTransparency = 1
&#9;loadingName.FontSize = Enum.FontSize.Size18
&#9;loadingName.Parent = loadingFrame

&#9;local cancelButtonClicked = Instance.new(&quot;BindableEvent&quot;)
&#9;cancelButtonClicked.Name = &quot;CancelButtonClicked&quot;
&#9;cancelButtonClicked.Parent = cancelButton
&#9;cancelButton.MouseButton1Click:connect(function()
&#9;&#9;cancelButtonClicked:Fire()
&#9;end)

&#9;local updateLoadingGuiPercent = function(percent, tweenAction, tweenLength)
&#9;&#9;if percent and type(percent) ~= &quot;number&quot; then
&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent expects number as argument, got&quot;,type(percent),&quot;instead&quot;)
&#9;&#9;end

&#9;&#9;local newSize = nil
&#9;&#9;if percent &lt; 0 then
&#9;&#9;&#9;newSize = UDim2.new(0,0,1,0)
&#9;&#9;elseif percent &gt; 1 then
&#9;&#9;&#9;newSize = UDim2.new(1,0,1,0)
&#9;&#9;else
&#9;&#9;&#9;newSize = UDim2.new(percent,0,1,0)
&#9;&#9;end

&#9;&#9;if tweenAction then
&#9;&#9;&#9;if not tweenLength then
&#9;&#9;&#9;&#9;error(&quot;updateLoadingGuiPercent is set to tween new percentage, but got no tween time length! Please pass this in as third argument&quot;)
&#9;&#9;&#9;end

&#9;&#9;&#9;if (newSize.X.Scale &gt; 0) then
&#9;&#9;&#9;&#9;loadingGreenBar.Visible = true
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;loadingGreenBar:TweenSize(&#9;newSize,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingDirection.Out,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Enum.EasingStyle.Quad,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;tweenLength,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;true,
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;function() 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (newSize.X.Scale &lt; 0) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;loadingGreenBar.Visible = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end

&#9;&#9;else
&#9;&#9;&#9;loadingGreenBar.Size = newSize
&#9;&#9;&#9;loadingGreenBar.Visible = (newSize.X.Scale &gt; 0)
&#9;&#9;end
&#9;end

&#9;loadingGreenBar.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Size&quot; then
&#9;&#9;&#9;loadingPercent.Text = tostring( math.ceil(loadingGreenBar.Size.X.Scale * 100) ) .. &quot;%&quot;
&#9;&#9;end
&#9;end)

&#9;return loadingFrame, updateLoadingGuiPercent, cancelButtonClicked
end

t.CreatePluginFrame = function (name,size,position,scrollable,parent)
&#9;local function createMenuButton(size,position,text,fontsize,name,parent)
&#9;&#9;local button = Instance.new(&quot;TextButton&quot;,parent)
&#9;&#9;button.AutoButtonColor = false
&#9;&#9;button.Name = name
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.Position = position
&#9;&#9;button.Size = size
&#9;&#9;button.Font = Enum.Font.ArialBold
&#9;&#9;button.FontSize = fontsize
&#9;&#9;button.Text =  text
&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;button.BorderSizePixel = 0
&#9;&#9;button.BackgroundColor3 = Color3.new(20/255,20/255,20/255)

&#9;&#9;button.MouseEnter:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function ( )
&#9;&#9;&#9;if button.Selected then return end
&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;end)

&#9;&#9;return button

&#9;end

&#9;local dragBar = Instance.new(&quot;Frame&quot;,parent)
&#9;dragBar.Name = tostring(name) .. &quot;DragBar&quot;
&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;dragBar.BorderColor3 = Color3.new(0,0,0)
&#9;if size then
&#9;&#9;dragBar.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,20)  + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;dragBar.Size = UDim2.new(0,183,0,20)
&#9;end
&#9;if position then
&#9;&#9;dragBar.Position = position
&#9;end
&#9;dragBar.Active = true
&#9;dragBar.Draggable = true
&#9;--dragBar.Visible = false
&#9;dragBar.MouseEnter:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(49/255,49/255,49/255)
&#9;end)
&#9;dragBar.MouseLeave:connect(function (  )
&#9;&#9;dragBar.BackgroundColor3 = Color3.new(39/255,39/255,39/255)
&#9;end)

&#9;-- plugin name label
&#9;local pluginNameLabel = Instance.new(&quot;TextLabel&quot;,dragBar)
&#9;pluginNameLabel.Name = &quot;BarNameLabel&quot;
&#9;pluginNameLabel.Text = &quot; &quot; .. tostring(name)
&#9;pluginNameLabel.TextColor3 = Color3.new(1,1,1)
&#9;pluginNameLabel.TextStrokeTransparency = 0
&#9;pluginNameLabel.Size = UDim2.new(1,0,1,0)
&#9;pluginNameLabel.Font = Enum.Font.ArialBold
&#9;pluginNameLabel.FontSize = Enum.FontSize.Size18
&#9;pluginNameLabel.TextXAlignment = Enum.TextXAlignment.Left
&#9;pluginNameLabel.BackgroundTransparency = 1

&#9;-- close button
&#9;local closeButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-16,0.5,-8),&quot;X&quot;,Enum.FontSize.Size14,&quot;CloseButton&quot;,dragBar)
&#9;local closeEvent = Instance.new(&quot;BindableEvent&quot;)
&#9;closeEvent.Name = &quot;CloseEvent&quot;
&#9;closeEvent.Parent = closeButton
&#9;closeButton.MouseButton1Click:connect(function ()
&#9;&#9;closeEvent:Fire()
&#9;&#9;closeButton.BackgroundTransparency = 1
&#9;end)

&#9;-- help button
&#9;local helpButton = createMenuButton(UDim2.new(0,15,0,17),UDim2.new(1,-51,0.5,-8),&quot;?&quot;,Enum.FontSize.Size14,&quot;HelpButton&quot;,dragBar)
&#9;local helpFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;helpFrame.Name = &quot;HelpFrame&quot;
&#9;helpFrame.BackgroundColor3 = Color3.new(0,0,0)
&#9;helpFrame.Size = UDim2.new(0,300,0,552)
&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;helpFrame.Active = true
&#9;helpFrame.BorderSizePixel = 0
&#9;helpFrame.Visible = false

&#9;helpButton.MouseButton1Click:connect(function(  )
&#9;&#9;helpFrame.Visible = not helpFrame.Visible
&#9;&#9;if helpFrame.Visible then
&#9;&#9;&#9;helpButton.Selected = true
&#9;&#9;&#9;helpButton.BackgroundTransparency = 0
&#9;&#9;&#9;local screenGui = getLayerCollectorAncestor(helpFrame)
&#9;&#9;&#9;if screenGui then
&#9;&#9;&#9;&#9;if helpFrame.AbsolutePosition.X + helpFrame.AbsoluteSize.X &gt; screenGui.AbsoluteSize.X then --position on left hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(0,-5 - helpFrame.AbsoluteSize.X,0,0)
&#9;&#9;&#9;&#9;else -- position on right hand side
&#9;&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;helpFrame.Position = UDim2.new(1,5,0,0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;helpButton.Selected = false
&#9;&#9;&#9;helpButton.BackgroundTransparency = 1
&#9;&#9;end
&#9;end)

&#9;local minimizeButton = createMenuButton(UDim2.new(0,16,0,17),UDim2.new(1,-34,0.5,-8),&quot;-&quot;,Enum.FontSize.Size14,&quot;MinimizeButton&quot;,dragBar)
&#9;minimizeButton.TextYAlignment = Enum.TextYAlignment.Top

&#9;local minimizeFrame = Instance.new(&quot;Frame&quot;,dragBar)
&#9;minimizeFrame.Name = &quot;MinimizeFrame&quot;
&#9;minimizeFrame.BackgroundColor3 = Color3.new(73/255,73/255,73/255)
&#9;minimizeFrame.BorderColor3 = Color3.new(0,0,0)
&#9;minimizeFrame.Position = UDim2.new(0,0,1,0)
&#9;if size then
&#9;&#9;minimizeFrame.Size =  UDim2.new(size.X.Scale,size.X.Offset,0,50) + UDim2.new(0,20,0,0)
&#9;else
&#9;&#9;minimizeFrame.Size = UDim2.new(0,183,0,50)
&#9;end
&#9;minimizeFrame.Visible = false

&#9;local minimizeBigButton = Instance.new(&quot;TextButton&quot;,minimizeFrame)
&#9;minimizeBigButton.Position = UDim2.new(0.5,-50,0.5,-20)
&#9;minimizeBigButton.Name = &quot;MinimizeButton&quot;
&#9;minimizeBigButton.Size = UDim2.new(0,100,0,40)
&#9;minimizeBigButton.Style = Enum.ButtonStyle.RobloxButton
&#9;minimizeBigButton.Font = Enum.Font.ArialBold
&#9;minimizeBigButton.FontSize = Enum.FontSize.Size18
&#9;minimizeBigButton.TextColor3 = Color3.new(1,1,1)
&#9;minimizeBigButton.Text = &quot;Show&quot;

&#9;local separatingLine = Instance.new(&quot;Frame&quot;,dragBar)
&#9;separatingLine.Name = &quot;SeparatingLine&quot;
&#9;separatingLine.BackgroundColor3 = Color3.new(115/255,115/255,115/255)
&#9;separatingLine.BorderSizePixel = 0
&#9;separatingLine.Position = UDim2.new(1,-18,0.5,-7)
&#9;separatingLine.Size = UDim2.new(0,1,0,14)

&#9;local otherSeparatingLine = separatingLine:clone()
&#9;otherSeparatingLine.Position = UDim2.new(1,-35,0.5,-7)
&#9;otherSeparatingLine.Parent = dragBar

&#9;local widgetContainer = Instance.new(&quot;Frame&quot;,dragBar)
&#9;widgetContainer.Name = &quot;WidgetContainer&quot;
&#9;widgetContainer.BackgroundTransparency = 1
&#9;widgetContainer.Position = UDim2.new(0,0,1,0)
&#9;widgetContainer.BorderColor3 = Color3.new(0,0,0)
&#9;if not scrollable then
&#9;&#9;widgetContainer.BackgroundTransparency = 0
&#9;&#9;widgetContainer.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;end

&#9;if size then
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = size
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,size.Y.Scale,size.Y.Offset)
&#9;&#9;end
&#9;else
&#9;&#9;if scrollable then
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,163,0,400)
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Size = UDim2.new(0,dragBar.AbsoluteSize.X,0,400)
&#9;&#9;end
&#9;end
&#9;if position then
&#9;&#9;widgetContainer.Position = position + UDim2.new(0,0,0,20)
&#9;end

&#9;local frame,control,verticalDragger = nil
&#9;if scrollable then
&#9;&#9;--frame for widgets
&#9;&#9;frame,control = t.CreateTrueScrollingFrame()
&#9;&#9;frame.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;frame.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;frame.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;frame.Active = true
&#9;&#9;frame.Parent = widgetContainer
&#9;&#9;control.Parent = dragBar
&#9;&#9;control.BackgroundColor3 = Color3.new(72/255,72/255,72/255)
&#9;&#9;control.BorderSizePixel = 0
&#9;&#9;control.BackgroundTransparency = 0
&#9;&#9;control.Position = UDim2.new(1,-21,1,1)
&#9;&#9;if size then
&#9;&#9;&#9;control.Size = UDim2.new(0,21,size.Y.Scale,size.Y.Offset)
&#9;&#9;else
&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,400)
&#9;&#9;end
&#9;&#9;control:FindFirstChild(&quot;ScrollDownButton&quot;).Position = UDim2.new(0,0,1,-20)

&#9;&#9;local fakeLine = Instance.new(&quot;Frame&quot;,control)
&#9;&#9;fakeLine.Name = &quot;FakeLine&quot;
&#9;&#9;fakeLine.BorderSizePixel = 0
&#9;&#9;fakeLine.BackgroundColor3 = Color3.new(0,0,0)
&#9;&#9;fakeLine.Size = UDim2.new(0,1,1,1)
&#9;&#9;fakeLine.Position = UDim2.new(1,0,0,0)

&#9;&#9;verticalDragger = Instance.new(&quot;TextButton&quot;,widgetContainer)
&#9;&#9;verticalDragger.ZIndex = 2
&#9;&#9;verticalDragger.AutoButtonColor = false
&#9;&#9;verticalDragger.Name = &quot;VerticalDragger&quot;
&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;verticalDragger.BorderColor3 = Color3.new(0,0,0)
&#9;&#9;verticalDragger.Size = UDim2.new(1,20,0,20)
&#9;&#9;verticalDragger.Position = UDim2.new(0,0,1,0)
&#9;&#9;verticalDragger.Active = true
&#9;&#9;verticalDragger.Text = &quot;&quot;

&#9;&#9;local scrubFrame = Instance.new(&quot;Frame&quot;,verticalDragger)
&#9;&#9;scrubFrame.Name = &quot;ScrubFrame&quot;
&#9;&#9;scrubFrame.BackgroundColor3 = Color3.new(1,1,1)
&#9;&#9;scrubFrame.BorderSizePixel = 0
&#9;&#9;scrubFrame.Position = UDim2.new(0.5,-5,0.5,0)
&#9;&#9;scrubFrame.Size = UDim2.new(0,10,0,1)
&#9;&#9;scrubFrame.ZIndex = 5
&#9;&#9;local scrubTwo = scrubFrame:clone()
&#9;&#9;scrubTwo.Position = UDim2.new(0.5,-5,0.5,-2)
&#9;&#9;scrubTwo.Parent = verticalDragger
&#9;&#9;local scrubThree = scrubFrame:clone()
&#9;&#9;scrubThree.Position = UDim2.new(0.5,-5,0.5,2)
&#9;&#9;scrubThree.Parent = verticalDragger

&#9;&#9;local areaSoak = Instance.new(&quot;TextButton&quot;,getLayerCollectorAncestor(parent))
&#9;&#9;areaSoak.Name = &quot;AreaSoak&quot;
&#9;&#9;areaSoak.Size = UDim2.new(1,0,1,0)
&#9;&#9;areaSoak.BackgroundTransparency = 1
&#9;&#9;areaSoak.BorderSizePixel = 0
&#9;&#9;areaSoak.Text = &quot;&quot;
&#9;&#9;areaSoak.ZIndex = 10
&#9;&#9;areaSoak.Visible = false
&#9;&#9;areaSoak.Active = true

&#9;&#9;local draggingVertical = false
&#9;&#9;local startYPos = nil
&#9;&#9;verticalDragger.MouseEnter:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(60/255,60/255,60/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseLeave:connect(function ()
&#9;&#9;&#9;verticalDragger.BackgroundColor3 = Color3.new(50/255,50/255,50/255)
&#9;&#9;end)
&#9;&#9;verticalDragger.MouseButton1Down:connect(function(x,y)
&#9;&#9;&#9;draggingVertical = true
&#9;&#9;&#9;areaSoak.Visible = true
&#9;&#9;&#9;startYPos = y
&#9;&#9;end)
&#9;&#9;areaSoak.MouseButton1Up:connect(function (  )
&#9;&#9;&#9;draggingVertical = false
&#9;&#9;&#9;areaSoak.Visible = false
&#9;&#9;end)
&#9;&#9;areaSoak.MouseMoved:connect(function(x,y)
&#9;&#9;&#9;if not draggingVertical then return end

&#9;&#9;&#9;local yDelta = y - startYPos
&#9;&#9;&#9;if not control.ScrollDownButton.Visible and yDelta &gt; 0 then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;if (widgetContainer.Size.Y.Offset + yDelta) &lt; 150 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,150)
&#9;&#9;&#9;&#9;control.Size = UDim2.new (0,21,0,150)
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end 

&#9;&#9;&#9;startYPos = y

&#9;&#9;&#9;if widgetContainer.Size.Y.Offset + yDelta &gt;= 0 then
&#9;&#9;&#9;&#9;widgetContainer.Size = UDim2.new(widgetContainer.Size.X.Scale, widgetContainer.Size.X.Offset,widgetContainer.Size.Y.Scale,widgetContainer.Size.Y.Offset + yDelta)
&#9;&#9;&#9;&#9;control.Size = UDim2.new(0,21,0,control.Size.Y.Offset + yDelta )
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end

&#9;local function switchMinimize()
&#9;&#9;minimizeFrame.Visible = not minimizeFrame.Visible
&#9;&#9;if scrollable then
&#9;&#9;&#9;frame.Visible = not frame.Visible
&#9;&#9;&#9;verticalDragger.Visible = not verticalDragger.Visible
&#9;&#9;&#9;control.Visible = not control.Visible
&#9;&#9;else
&#9;&#9;&#9;widgetContainer.Visible = not widgetContainer.Visible
&#9;&#9;end

&#9;&#9;if minimizeFrame.Visible then
&#9;&#9;&#9;minimizeButton.Text = &quot;+&quot;
&#9;&#9;else
&#9;&#9;&#9;minimizeButton.Text = &quot;-&quot;
&#9;&#9;end
&#9;end

&#9;minimizeBigButton.MouseButton1Click:connect(function (  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;minimizeButton.MouseButton1Click:connect(function(  )
&#9;&#9;switchMinimize()
&#9;end)

&#9;if scrollable then
&#9;&#9;return dragBar, frame, helpFrame, closeEvent
&#9;else
&#9;&#9;return dragBar, widgetContainer, helpFrame, closeEvent
&#9;end
end

t.Help = 
&#9;function(funcNameOrFunc) 
&#9;&#9;--input argument can be a string or a function.  Should return a description (of arguments and expected side effects)
&#9;&#9;if funcNameOrFunc == &quot;CreatePropertyDropDownMenu&quot; or funcNameOrFunc == t.CreatePropertyDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreatePropertyDropDownMenu.  &quot; ..
&#9;&#9;&#9;&#9;   &quot;Arguments: (instance, propertyName, enumType).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: returns a container with a drop-down-box that is linked to the &apos;property&apos; field of &apos;instance&apos; which is of type &apos;enumType&apos;&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateDropDownMenu&quot; or funcNameOrFunc == t.CreateDropDownMenu then
&#9;&#9;&#9;return &quot;Function CreateDropDownMenu.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (items, onItemSelected).  &quot; .. 
&#9;&#9;&#9;&#9;   &quot;Side effect: Returns 2 results, a container to the gui object and a &apos;updateSelection&apos; function for external updating.  The container is a drop-down-box created around a list of items&quot; 
&#9;&#9;end 
&#9;&#9;if funcNameOrFunc == &quot;CreateMessageDialog&quot; or funcNameOrFunc == t.CreateMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button&quot;
&#9;&#9;end&#9;&#9;
&#9;&#9;if funcNameOrFunc == &quot;CreateStyledMessageDialog&quot; or funcNameOrFunc == t.CreateStyledMessageDialog then
&#9;&#9;&#9;return &quot;Function CreateStyledMessageDialog.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (title, message, style, buttons). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: Returns a gui object of a message box with &apos;title&apos; and &apos;message&apos; as passed in.  &apos;buttons&apos; input is an array of Tables contains a &apos;Text&apos; and &apos;Function&apos; field for the text/callback of each button, &apos;style&apos; is a string, either Error, Notify or Confirm&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;GetFontHeight&quot; or funcNameOrFunc == t.GetFontHeight then
&#9;&#9;&#9;return &quot;Function GetFontHeight.  &quot; .. 
&#9;&#9;&#9;       &quot;Arguments: (font, fontSize). &quot; .. 
&#9;&#9;&#9;       &quot;Side effect: returns the size in pixels of the given font + fontSize&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;LayoutGuiObjects&quot; or funcNameOrFunc == t.LayoutGuiObjects then
&#9;&#9;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateScrollingFrame&quot; or funcNameOrFunc == t.CreateScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (orderList, style) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 4 objects, (scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction).  &apos;scrollFrame&apos; can be filled with GuiObjects.  It will lay them out and allow scrollUpButton/scrollDownButton to interact with them.  Orderlist is optional (and specifies the order to layout the children.  Without orderlist, it uses the children order. style is also optional, and allows for a &apos;grid&apos; styling if style is passed &apos;grid&apos; as a string.  recalculateFunction can be called when a relayout is needed (when orderList changes)&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTrueScrollingFrame&quot; or funcNameOrFunc == t.CreateTrueScrollingFrame then
&#9;&#9;&#9;return &quot;Function CreateTrueScrollingFrame.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (nil) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (scrollFrame, controlFrame).  &apos;scrollFrame&apos; can be filled with GuiObjects, and they will be clipped if not inside the frame&apos;s bounds. controlFrame has children scrollup and scrolldown, as well as a slider.  controlFrame can be parented to any guiobject and it will readjust itself to fit.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;AutoTruncateTextObject&quot; or funcNameOrFunc == t.AutoTruncateTextObject then
&#9;&#9;&#9;return &quot;Function AutoTruncateTextObject.  &quot; .. 
&#9;&#9;&#9;   &quot;Arguments: (textLabel) &quot; .. 
&#9;&#9;&#9;   &quot;Side effect: returns 2 objects, (textLabel, changeText).  The &apos;textLabel&apos; input is modified to automatically truncate text (with ellipsis), if it gets too small to fit.  &apos;changeText&apos; is a function that can be used to change the text, it takes 1 string as an argument&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSlider&quot; or funcNameOrFunc == t.CreateSlider then
&#9;&#9;&#9;return &quot;Function CreateSlider.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateSliderNew&quot; or funcNameOrFunc == t.CreateSliderNew then
&#9;&#9;&#9;return &quot;Function CreateSliderNew.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (steps, width, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: returns 2 objects, (sliderGui, sliderPosition).  The &apos;steps&apos; argument specifies how many different positions the slider can hold along the bar.  &apos;width&apos; specifies in pixels how wide the bar should be (modifiable afterwards if desired). &apos;position&apos; argument should be a UDim2 for slider positioning. &apos;sliderPosition&apos; is an IntValue whose current .Value specifies the specific step the slider is currently on.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateLoadingFrame&quot; or funcNameOrFunc == t.CreateLoadingFrame then
&#9;&#9;&#9;return &quot;Function CreateLoadingFrame.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (name, size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Creates a gui that can be manipulated to show progress for a particular action.  Name appears above the loading bar, and size and position are udim2 values (both size and position are optional arguments).  Returns 3 arguments, the first being the gui created. The second being updateLoadingGuiPercent, which is a bindable function.  This function takes one argument (two optionally), which should be a number between 0 and 1, representing the percentage the loading gui should be at.  The second argument to this function is a boolean value that if set to true will tween the current percentage value to the new percentage value, therefore our third argument is how long this tween should take. Our third returned argument is a BindableEvent, that when fired means that someone clicked the cancel button on the dialog.&quot;
&#9;&#9;end
&#9;&#9;if funcNameOrFunc == &quot;CreateTerrainMaterialSelector&quot; or funcNameOrFunc == t.CreateTerrainMaterialSelector then
&#9;&#9;&#9;return &quot;Function CreateTerrainMaterialSelector.  &quot; ..
&#9;&#9;&#9;&#9;&quot;Arguments: (size, position) &quot; ..
&#9;&#9;&#9;&#9;&quot;Side effect: Size and position are UDim2 values that specifies the selector&apos;s size and position.  Both size and position are optional arguments. This method returns 3 objects (terrainSelectorGui, terrainSelected, forceTerrainSelection).  terrainSelectorGui is just the gui object that we generate with this function, parent it as you like. TerrainSelected is a BindableEvent that is fired whenever a new terrain type is selected in the gui.  ForceTerrainSelection is a function that takes an argument of Enum.CellMaterial and will force the gui to show that material as currently selected.&quot;
&#9;&#9;end
&#9;end
&#9;

RbxGui = t


--All RbxGui funtions here.
local isRestricted = false

print(isRestricted)

local Tool = script.Parent

enabled = true
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.pengin.xyz/asset/?id=59785529&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.pengin.xyz/asset/?id=61423967&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.pengin.xyz/asset/?id=61427382&quot;)

local configIconImage = &quot;http://www.pengin.xyz/asset/?id=59785529&quot;
local configIconOverImage = &quot;http://www.pengin.xyz/asset/?id=61423967&quot;
local configIconHoverImage = &quot;http://www.pengin.xyz/asset/?id=61427382&quot;
local highlightedImage = nil

local STATIC_BASE_PLATE = nil

local ServiceConnections

local guiMain
local screen

local selectionGui

local player
local playerArea

local canTween = true
local gridRecalc
local lastPart

local lastConfig = nil
local lastVehicleSeat = nil
local origValueMap = {}

local valueConnections = {}

local objectValueSelect = {}

local adornmentTable = {}

local colorPaletteSelectMode = false

local needsIconReset = false

local textSize = 5

--Constants
local width = UDim.new(3, 0)
local height = 20 
local transparency = 0.5
local buttonColor = BrickColor.new(&quot;Mid gray&quot;)
local frameColor = BrickColor.new(&quot;Pastel yellow&quot;)


local function isInModel(part)
&#9;if part == game.Workspace then
&#9;&#9;return false, nil
&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;return true, part
&#9;else
&#9;&#9;return isInModel(part.Parent)
&#9;end
end


function constrained(valueObject)
&#9;return (valueObject:IsA(&quot;IntConstrainedValue&quot;) or valueObject:IsA(&quot;DoubleConstrainedValue&quot;))
end

function sharedProcess(name, parentFrame)
&#9;local subFrame = Instance.new(&quot;Frame&quot;)
&#9;subFrame.Name = name
&#9;subFrame.Size = UDim2.new(1.0, 0, 0, height)
&#9;subFrame.BackgroundTransparency = 1.0
&#9;subFrame.BorderSizePixel = 0
&#9;
&#9;local label = Instance.new(&quot;TextLabel&quot;)
&#9;label.Font = Enum.Font.ArialBold
&#9;label.Position = UDim2.new(0.0, 0, 0.0, 0)
&#9;label.Size = UDim2.new(0.5, 0, 1.0, 0)
&#9;label.FontSize = textSize
&#9;label.TextColor = BrickColor.White()
&#9;label.Text = name
&#9;label.Parent = subFrame
&#9;label.BackgroundTransparency = 1.0
&#9;label.BorderSizePixel = 0

&#9;return subFrame
end

function createTextBox(size, text)
&#9;local textBox = Instance.new(&quot;TextBox&quot;)
&#9;textBox.Position = UDim2.new(0.5, 1, 0.0, 1)
&#9;textBox.Size = size
&#9;textBox.BackgroundTransparency = 1
&#9;textBox.FontSize = textSize - 3
&#9;textBox.TextColor3 = Color3.new(1,1,1)
&#9;textBox.Text = text&#9;
&#9;textBox.ZIndex = 2

&#9;local textBoxBacking = Instance.new(&quot;TextButton&quot;)
&#9;textBoxBacking.Text = &quot;&quot;
&#9;textBoxBacking.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;textBoxBacking.Size = UDim2.new(1,0,1,0)
&#9;textBoxBacking.Parent = textBox

&#9;return textBox
end

function setCheckBoxValue(checkBox, value)
&#9;if value then
&#9;&#9;checkBox.Text = &quot;X&quot;
&#9;else
&#9;&#9;checkBox.Text = &quot;&quot;
&#9;end
end
function createCheckBox(value)
&#9;local checkBox = Instance.new(&quot;TextButton&quot;)
&#9;checkBox.Position = UDim2.new(0.75, -(height-4)/2, 0.0, 2)
&#9;checkBox.Size = UDim2.new(0.0, height-4, 0.0, height-4)
&#9;checkBox.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;checkBox.TextColor3 = Color3.new(1,1,1)
&#9;checkBox.FontSize = textSize
&#9;setCheckBoxValue(checkBox, value)
&#9;return checkBox
end



function processBoolValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local checkBox = createCheckBox(value.Value)
&#9;
&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;checkBox.MouseButton1Down:connect(function() value.Value = not(value.Value) end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) setCheckBoxValue(checkBox, newValue) end)&#9;
&#9;checkBox.Parent = subFrame
&#9;return subFrame
end

function processConstrainedNumberValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.ConstrainedValue, function(textBox) value.ConstrainedValue = textBox.Text end)
&#9;textBox.Name = value.Name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;local prevValue = value.ConstrainedValue
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;pcall(function() value.ConstrainedValue = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = value.ConstrainedValue
&#9;&#9;end
&#9;end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame;
end

function processIntValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), value.Value, function(textBox) value.Value = textBox.Text end)
&#9;textBox.Name = value.Name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;local prevValue = value.Value
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;pcall(function() value.Value = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = value.Value
&#9;&#9;end
&#9;end)
&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) textBox.Text = newValue end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame;
end

function processPropertyValue(object, name, field, guiFrame)
&#9;origValueMap[name] = object[field]

&#9;local subFrame = sharedProcess(name, guiFrame)
&#9;local textBox = createTextBox(UDim2.new(0.5,-2, 1.0, -2), object[field], function(textBox) object[field] = textBox.Text end)
&#9;textBox.Name = name

&#9;--Tie the two values together... we&apos;ll need to break these connections later
&#9;textBox.Changed:connect(function(prop) 
&#9;&#9;if prop == &quot;Text&quot; then
&#9;&#9;&#9;if textBox.Text ~= &quot;&quot; then
&#9;&#9;&#9;&#9;local success = pcall(function() object[field] = textBox.Text end)
&#9;&#9;&#9;end
&#9;&#9;&#9;textBox.Text = object[field]
&#9;&#9;end
&#9;end)

&#9;valueConnections[#valueConnections+1] = object.Changed:connect(function(property) if property == field then textBox.Text = object[field] end end)
&#9;
&#9;textBox.Parent = subFrame
&#9;return subFrame
end


function processEnumValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)

&#9;local valueChildren = value:GetChildren()
&#9;local enumNames = {}
&#9;for i = 1, #valueChildren do
&#9;&#9;if valueChildren[i]:IsA(&quot;BoolValue&quot;) and valueChildren[i].Value == true then
&#9;&#9;&#9;table.insert(enumNames,valueChildren[i].Name)
&#9;&#9;end
&#9;end

&#9;local valueToChange = value
&#9;local enumSelect = function(item)
&#9;&#9;valueToChange.Value = tostring(item)
&#9;end

&#9;local dropDownEnumMenu, updateEnumSelection = RbxGui.CreateDropDownMenu(enumNames, enumSelect)
&#9;dropDownEnumMenu.Position = UDim2.new(0.5,0,0,0)
&#9;dropDownEnumMenu.Size = UDim2.new(0.5,0,0,20)
&#9;dropDownEnumMenu.Parent = subFrame

&#9;for i = 1, #valueChildren do
&#9;&#9;if value.Value == valueChildren[i].Name then
&#9;&#9;&#9;dropDownEnumMenu.DropDownMenuButton.Text = valueChildren[i].Name
&#9;&#9;&#9;break
&#9;&#9;end
&#9;end

&#9;return subFrame
end



function processNumberValue(value, guiFrame)
&#9;return processIntValue(value, guiFrame)
end


function processStringValue(value, guiFrame)
&#9;return processIntValue(value, guiFrame)
end

function inBaseplate(instance)
&#9;if instance == STATIC_BASE_PLATE then return true end

&#9;local instanceCopy = instance

&#9;while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
&#9;&#9;if instanceCopy.Parent == STATIC_BASE_PLATE then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;instanceCopy = instanceCopy.Parent
&#9;end

&#9;return false
end

function onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
&#9;if oldButton[0] then
&#9;&#9;local notSelected = true;
&#9;&#9;local selectionText = &quot;&quot;;
&#9;&#9;for key, value in pairs(selectedButtonTable) do
&#9;&#9;&#9;if oldButton[0] == value then
&#9;&#9;&#9;&#9;notSelected = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;selectionText = value.BackgroundColor.Name;
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;if notSelected then
&#9;&#9;&#9;hoverSelection.Text = selectionText;
&#9;&#9;&#9;oldButton[0].Parent.BackgroundColor = BrickColor.Black();
&#9;&#9;end
&#9;end
&#9;oldButton[0] = nil
end

function onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton)
&#9;onMouseLeave(hoverSelection, selectedButtonTable, oldButton)
&#9;hoverSelection.Text = guiButton.BackgroundColor.Name
&#9;if guiButton ~= selectedButton then
&#9;&#9;guiButton.Parent.BackgroundColor = BrickColor.White();
&#9;&#9;oldButton[0] = guiButton
&#9;end
end

function changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)
&#9;if selectedButtonTable[colorHolder] ~= nil then
&#9;&#9;selectedButtonTable[colorHolder].Parent.BackgroundColor = BrickColor.Black();
&#9;end

&#9;guiButton.Parent.BackgroundColor = BrickColor.Yellow();
&#9;colorHolder.BackgroundColor = guiButton.BackgroundColor
&#9;selectedButtonTable[colorHolder] = guiButton
end

function onMouseUp(colorHolder, paletteFrame, guiButton, selectedButtonTable)
&#9;changeColorSelection(colorHolder, paletteFrame, guiButton, selectedButtonTable)

&#9;onMouseLeavePalette(paletteFrame)
end

function onShowColorDialog(paletteFrame)
&#9;paletteFrame.Visible = not(paletteFrame.Visible)
&#9;colorPaletteSelectMode = true
end


function onMouseEnterPalette(mouse)
&#9;colorPaletteSelectMode = true
end
function onMouseLeavePalette(paletteFrame)
&#9;colorPaletteSelectMode = false
&#9;paletteFrame.Visible = false
end

function processBrickColorValue(value, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)

&#9;local sideBar = Instance.new(&quot;Frame&quot;)
&#9;sideBar.Position = UDim2.new(0.5, 0, 0.0, 0)
&#9;sideBar.Size = UDim2.new(0.5, 0, 1.0, 0)
&#9;sideBar.BackgroundTransparency = 1.0
&#9;sideBar.Parent = subFrame
&#9;sideBar.BorderSizePixel = 0

&#9;local primaryColor = Instance.new(&quot;TextButton&quot;)
&#9;primaryColor.Position = UDim2.new(0.0, 1, 0.0, 1)
&#9;primaryColor.Size = UDim2.new(0.0, height-2, 0, height-2)
&#9;primaryColor.Text  = &quot;&quot;&#9;
&#9;primaryColor.FontSize = textSize
&#9;primaryColor.BackgroundColor = value.Value
&#9;primaryColor.BorderColor = BrickColor.Black()
&#9;primaryColor.Parent = sideBar

&#9;local hoverSelection = Instance.new(&quot;TextLabel&quot;)
&#9;hoverSelection.Position = UDim2.new(0.0, height+2, 0.0, 0)
&#9;hoverSelection.Size = UDim2.new(1.0, -height - 4, 1.0, 0)
&#9;hoverSelection.Text = &quot;&quot;
&#9;hoverSelection.Font = Enum.Font.ArialBold
&#9;hoverSelection.FontSize = textSize
&#9;hoverSelection.BackgroundTransparency = 1.0
&#9;hoverSelection.BorderSizePixel = 0
&#9;hoverSelection.TextColor = BrickColor.White()
&#9;hoverSelection.Text = primaryColor.BackgroundColor.Name;
&#9;hoverSelection.Parent = sideBar

&#9;local paletteFrame = Instance.new(&quot;Frame&quot;)
&#9;paletteFrame.Position = UDim2.new(primaryColor.Position.X.Scale, primaryColor.Position.X.Offset + height, primaryColor.Position.Y.Scale, primaryColor.Position.Y.Offset - height*7)
&#9;paletteFrame.Size = UDim2.new(0, height*8, 0, height*8)
&#9;paletteFrame.BackgroundColor = BrickColor.White()
&#9;paletteFrame.BorderColor = BrickColor.White()
&#9;paletteFrame.Visible = false;
&#9;paletteFrame.Parent = sideBar
&#9;paletteFrame.ZIndex = 2
&#9;paletteFrame.MouseEnter:connect(function() onMouseEnterPalette(mouse) end)
&#9;paletteFrame.MouseLeave:connect(function() onMouseLeavePalette(paletteFrame, mouse) end)

&#9;primaryColor.MouseButton1Down:connect(function() onShowColorDialog(paletteFrame) end)

&#9;local selectedButtonTable = {}
&#9;local colorButtonTable = {}
&#9;local oldButton = {}
&#9;for xOffset = 0, 7 do
&#9;&#9;for yOffset = 0,7 do
&#9;&#9;&#9;local guiFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;&#9;guiFrame.Position = UDim2.new(1.0/8 * xOffset, 0, 1.0/8*yOffset, 0)
&#9;&#9;&#9;guiFrame.Size = UDim2.new(1.0/8, 0, 1.0/8, 0)
&#9;&#9;&#9;guiFrame.BackgroundColor = BrickColor.White();
&#9;&#9;&#9;guiFrame.BorderSizePixel = 0
&#9;&#9;&#9;guiFrame.Parent = paletteFrame;
&#9;&#9;&#9;guiFrame.ZIndex = 2
&#9;&#9;
&#9;&#9;&#9;local guiButton = Instance.new(&quot;TextButton&quot;)
&#9;&#9;&#9;guiButton.FontSize = textSize
&#9;&#9;&#9;guiButton.Position = UDim2.new(0.0, 1, 0.0, 1)
&#9;&#9;&#9;guiButton.Size = UDim2.new(1.0, -2, 1.0, -2)
&#9;&#9;&#9;guiButton.Text = &quot;&quot;
&#9;&#9;&#9;guiButton.BorderSizePixel = 0
&#9;&#9;&#9;guiButton.AutoButtonColor = false
&#9;&#9;&#9;local color = BrickColor.palette(xOffset + yOffset*8)
&#9;&#9;&#9;colorButtonTable[color.Number] = guiButton
&#9;&#9;&#9;guiButton.BackgroundColor = color
&#9;&#9;&#9;guiButton.MouseEnter:connect(function() onMouseEnter(hoverSelection, guiButton, selectedButtonTable, oldButton) end)
&#9;&#9;&#9;guiButton.MouseButton1Up:connect(function() onMouseUp(primaryColor, paletteFrame, guiButton, selectedButtonTable, oldButton) end)
&#9;&#9;&#9;guiButton.MouseButton1Up:connect(function() value.Value = guiButton.BackgroundColor end)
&#9;&#9;&#9;guiButton.Parent = guiFrame
&#9;&#9;&#9;guiButton.ZIndex = 2

&#9;&#9;&#9;if guiButton.BackgroundColor == primaryColor.BackgroundColor then
&#9;&#9;&#9;&#9;guiFrame.BackgroundColor = BrickColor.White()
&#9;&#9;&#9;&#9;selectedButtonTable[primaryColor] = guiButton
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newValue) changeColorSelection(primaryColor, paletteFrame, colorButtonTable[newValue.Number], selectedButtonTable) end)&#9;
&#9;return subFrame
end


function onObjectValueMouseClick(guiFrame, value, objectButton)
&#9;objectValueSelect[&quot;Value&quot;] = value
&#9;objectValueSelect[&quot;Frame&quot;] = guiFrame
&#9;objectValueSelect[&quot;Enabled&quot;] = true

&#9;onObjectValueMouseLeave(value, objectButton)
end

function onObjectValueMouseEnter(value, objectButton)
&#9;objectValueSelect[&quot;HoverValue&quot;] = value
&#9;if value.Value then
&#9;&#9;objectButton.BackgroundColor = BrickColor.Blue()
&#9;else
&#9;&#9;objectButton.BackgroundColor = BrickColor.White()
&#9;end
end
&#9;
function onObjectValueMouseLeave(value, objectButton)
&#9;if objectValueSelect[&quot;HoverValue&quot;] == value then
&#9;&#9;objectValueSelect[&quot;HoverValue&quot;] = nil
&#9;end
&#9;objectButton.BackgroundColor = buttonColor
end

function onObjectValueCancel()
&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false

&#9;&#9;objectValueSelect[&quot;Frame&quot;].Visible = true
&#9;&#9;objectValueSelect[&quot;Frame&quot;] = nil
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end
end

function on3dObjectValueButton1Up(mouse, guiMain)
&#9;local part = mouse.Target
&#9;if part ~= nil then
&#9;&#9;objectValueSelect[&quot;Value&quot;].Value = part

&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false

&#9;&#9;objectValueSelect[&quot;Frame&quot;].Visible = true

&#9;&#9;objectValueSelect[&quot;Frame&quot;] = nil
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end
end

function on3dObjectValueMouseMove(mouse, guiMain)
end

function setObjectButtonText(guiFrame, objectButton, objectValue)
&#9;if objectValueSelect[&quot;Enabled&quot;] and objectValue == objectValueSelect[&quot;Value&quot;] then
&#9;&#9;guiFrame.Visible = true
&#9;&#9;objectValueSelect[&quot;Enabled&quot;] = false
&#9;&#9;objectValueSelect[&quot;Value&quot;] = nil
&#9;end

&#9;if  objectValue.Value ~= nil then
&#9;&#9;objectButton.Text = objectValue.Value.Name
&#9;else
&#9;&#9;objectButton.Text = &quot;[nil]&quot;
&#9;end
&#9;objectButton.BackgroundColor = buttonColor
end

function processObjectValue(value, playerGui, guiFrame)
&#9;local subFrame = sharedProcess(value.Name, guiFrame)
&#9;local objectButton = Instance.new(&quot;TextButton&quot;)
&#9;objectButton.FontSize = textSize
&#9;objectButton.Position = UDim2.new(0.5, 2, 0.0, 2)
&#9;objectButton.Size = UDim2.new(0.5, -4, 1.0, -4)
&#9;objectButton.BackgroundColor = BrickColor.White()
&#9;objectButton.TextColor = BrickColor.Black()
&#9;objectButton.Parent = subFrame
&#9;objectButton.AutoButtonColor = false

&#9;objectButton.MouseButton1Click:connect(function() onObjectValueMouseClick(guiFrame, value, objectButton) end)
&#9;objectButton.MouseEnter:connect(function() onObjectValueMouseEnter(value, objectButton) end)
&#9;objectButton.MouseLeave:connect(function() onObjectValueMouseLeave(value, objectButton) end)

&#9;valueConnections[#valueConnections+1] = value.Changed:connect(function(newObjectValue) setObjectButtonText(guiFrame, objectButton, value) end)&#9;

&#9;setObjectButtonText(guiFrame, objectButton, value)
&#9;return subFrame
end


function processValue(value, playerGui, guiFrame)
&#9;if constrained(value) then origValueMap[value.Name] = value.ConstrainedValue
&#9;else origValueMap[value.Name] = value.Value end

&#9;if #value:GetChildren() &gt; 0 and value:IsA(&quot;StringValue&quot;) then
&#9;&#9;return processEnumValue(value, guiFrame)
&#9;else
&#9;&#9;if value.className == &quot;BoolValue&quot; then
&#9;&#9;&#9;return processBoolValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;IntValue&quot; then
&#9;&#9;&#9;return processIntValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;NumberValue&quot; then
&#9;&#9;&#9;return processNumberValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;StringValue&quot; then
&#9;&#9;&#9;return processStringValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;ObjectValue&quot; then
&#9;&#9;&#9;return processObjectValue(value, playerGui, guiFrame)
&#9;&#9;elseif value.className == &quot;BrickColorValue&quot; then
&#9;&#9;&#9;return processBrickColorValue(value, guiFrame)
&#9;&#9;elseif value.className == &quot;IntConstrainedValue&quot; or value.className == &quot;DoubleConstrainedValue&quot; then
&#9;&#9;&#9;return processConstrainedNumberValue(value, guiFrame)
&#9;&#9;else
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;end
end

function killFrame(frame)
&#9;screen.Enabled = false
&#9;frame:remove()
end

function closeFrame(frame)
&#9;lastPart = nil
&#9;if frame.Parent == nil then return end
&#9;frame:TweenSizeAndPosition(UDim2.new(0,0,0,0),UDim2.new(0.5,0,0.5,0),Enum.EasingDirection.In,Enum.EasingStyle.Back,0.5, true, function() killFrame(frame) end)
end

function allowTween()
&#9;canTween = true
end

function openFrame(frame,size)
&#9;if not canTween then return end
&#9;canTween = false
&#9;screen.Enabled = true
&#9;frame.Size = UDim2.new(0,0,0,0)
&#9;frame.Position = UDim2.new(0.5,0,0.5,0)
&#9;frame:TweenSizeAndPosition(size,UDim2.new(0,0,0,0),Enum.EasingDirection.Out,Enum.EasingStyle.Back,0.5,true, function() allowTween() end)
end

function sharedMain(name, playerGui)
&#9;local parentFrame = Instance.new(&quot;Frame&quot;)
&#9;parentFrame.Style = Enum.FrameStyle.RobloxRound
&#9;parentFrame.Active = true
&#9;parentFrame.Name = &quot;MainFrame&quot;
&#9;parentFrame.Size = UDim2.new(1, 0, 1, 0)
&#9;parentFrame.BackgroundTransparency = 1

&#9;local titleLabel = Instance.new(&quot;TextLabel&quot;)
&#9;titleLabel.Name = &quot;TitleLabel&quot;
&#9;titleLabel.Font = Enum.Font.ArialBold
&#9;titleLabel.FontSize = textSize + 2
&#9;titleLabel.Size = UDim2.new(1.0, 0.0, 0.0, height)
&#9;titleLabel.TextColor = BrickColor.White()
&#9;titleLabel.BackgroundColor = BrickColor.new(&quot;Cool yellow&quot;)
&#9;titleLabel.BackgroundTransparency = 1
&#9;titleLabel.Text = name
&#9;titleLabel.Parent = parentFrame

&#9;local closeButton = Instance.new(&quot;TextButton&quot;)
&#9;closeButton.Name = &quot;CloseButton&quot;
&#9;closeButton.Style = Enum.ButtonStyle.RobloxButtonDefault
&#9;closeButton.Size = UDim2.new(0,20,0,20)
&#9;closeButton.Position = UDim2.new(1,-16,0,-5)
&#9;closeButton.Text = &quot;X&quot;
&#9;closeButton.TextColor3 = Color3.new(1,1,1)
&#9;closeButton.Font = Enum.Font.ArialBold
&#9;closeButton.FontSize = Enum.FontSize.Size18
&#9;closeButton.Parent = parentFrame

&#9;local closeCon = nil
&#9;closeCon = closeButton.MouseButton1Click:connect(function()
&#9;&#9;closeCon:disconnect()
&#9;&#9;removeBillboards()
&#9;&#9;screen.Enabled = false
&#9;&#9;cancelSelectionGui()
&#9;end)

&#9;local scrollFrame, scrollUpButton, scrollDownButton, recalculateFunction = RbxGui.CreateScrollingFrame()
&#9;gridRecalc = recalculateFunction
&#9;scrollFrame.Name = &quot;ValueContainer&quot;
&#9;scrollFrame.Size = UDim2.new(1,-17,1,-50)
&#9;scrollFrame.Position = UDim2.new(0,0,0,25)
&#9;scrollFrame.Parent = parentFrame

&#9;local changerCon = nil
&#9;delay(1,function()
&#9;&#9;if scrollFrame and scrollFrame.Parent then
&#9;&#9;&#9;changerCon = scrollFrame.Changed:connect(function(prop)
&#9;&#9;&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;&#9;&#9;if scrollFrame.AbsoluteSize.Y &lt; 38 then
&#9;&#9;&#9;&#9;&#9;&#9;changerCon:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;closeFrame(parentFrame)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;gridRecalc()
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;end)

&#9;local dieCon
&#9;dieCon = scrollFrame.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;dieCon:disconnect()
&#9;&#9;&#9;if changerCon then changerCon:disconnect() end
&#9;&#9;end
&#9;end)

&#9;local scrollButtonFrame = Instance.new(&quot;Frame&quot;)
&#9;scrollButtonFrame.Name = &quot;ScrollButtonFrame&quot;
&#9;scrollButtonFrame.Position = UDim2.new(1,-17,0,25)
&#9;scrollButtonFrame.Size = UDim2.new(0,17,1,-50)
&#9;scrollButtonFrame.BackgroundTransparency = 1
&#9;scrollButtonFrame.Parent = parentFrame

&#9;scrollUpButton.Parent = scrollButtonFrame
&#9;scrollDownButton.Parent = scrollButtonFrame
&#9;scrollDownButton.Position = UDim2.new(0,0,1,-17)
&#9;

&#9;return parentFrame
end

function sharedButtons(parentFrame, valueChildren)
&#9;local buttonFrame = Instance.new(&quot;Frame&quot;)
&#9;buttonFrame.Name = &quot;Buttons&quot;
&#9;buttonFrame.BackgroundTransparency = 1.0
&#9;buttonFrame.Size = UDim2.new(1.0, 0.0, 0.0, height)
&#9;buttonFrame.Position = UDim2.new(0.0, 0, 1, -25)
&#9;buttonFrame.Parent = parentFrame
&#9;valueChildren = valueChildren + 1

&#9;local okButton = Instance.new(&quot;TextButton&quot;)
&#9;okButton.FontSize = textSize
&#9;okButton.Name = &quot;OkButton&quot;
&#9;okButton.Font = Enum.Font.ArialBold
&#9;okButton.TextColor = BrickColor.White()
&#9;okButton.Style = Enum.ButtonStyle.RobloxButton
&#9;okButton.Text = &quot;Ok&quot;
&#9;okButton.Size = UDim2.new(.25, -4, 0.0, height + 5)
&#9;okButton.Position = UDim2.new(0.55, 2, 0.0, 2)
&#9;okButton.BackgroundColor = buttonColor
&#9;okButton.MouseButton1Click:connect(function() removeSelectionGui() end)
&#9;okButton.Parent = buttonFrame

&#9;local cancelButton = okButton:clone()
&#9;cancelButton.Name = &quot;cancelButton&quot;
&#9;cancelButton.Text  = &quot;Cancel&quot;
&#9;cancelButton.Position = UDim2.new(0.200000003, 2, 0, 2)
&#9;cancelButton.MouseButton1Click:connect(function() cancelSelectionGui() end)
&#9;cancelButton.Parent = buttonFrame
end

function processVehicleSeat(vehicleSeat, playerGui, valueChildren)
&#9;local parentFrame = sharedMain(vehicleSeat.Name, playerGui)
&#9;lastVehicleSeat = vehicleSeat

&#9;local valueChildren = 1
&#9;local fields = {&quot;MaxSpeed&quot;, &quot;Steer&quot;, &quot;Torque&quot;, &quot;TurnSpeed&quot;}
&#9;for pos, field in pairs(fields) do
&#9;&#9;local newFrame = processPropertyValue(vehicleSeat, field, field, guiFrame)
&#9;&#9;if newFrame then
&#9;&#9;&#9;newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
&#9;&#9;&#9;newFrame.Parent = parentFrame.ValueContainer
&#9;&#9;&#9;valueChildren = valueChildren + 1
&#9;&#9;end

&#9;end

&#9;sharedButtons(parentFrame, valueChildren)
&#9;return parentFrame
end

function processConfiguration(config, playerGui)
&#9;local parentFrame = sharedMain(config.Name, playerGui)
&#9;lastConfig = config

&#9;local valueChildren = 1
&#9;local children = config:GetChildren() 
&#9;if children then
&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;local newFrame = processValue(child, playerGui, parentFrame)
&#9;&#9;&#9;if newFrame then
&#9;&#9;&#9;&#9;newFrame.Position = UDim2.new(0.0, 0, 0.0, (valueChildren*height) - height)
&#9;&#9;&#9;&#9;newFrame.Parent = parentFrame.ValueContainer
&#9;&#9;&#9;&#9;valueChildren = valueChildren + 1
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;sharedButtons(parentFrame, valueChildren)
&#9;return parentFrame
end

function on3dMouseMove(mouse, guiMain)
&#9;if mouse.Target and canSelectObject(mouse.Target) then

&#9;&#9;local part = mouse.Target
&#9;&#9;if part:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;foundPart = part
&#9;&#9;else
&#9;&#9;&#9;foundPart = findConfiguration(part)
&#9;&#9;end

&#9;&#9;if foundPart then
&#9;&#9;&#9;mouse.Icon = &quot;rbxasset://textures\\DragCursor.png&quot;
&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then 
&#9;&#9;&#9;&#9;local isModel, model = isInModel(part)
&#9;&#9;&#9;&#9;local adornee = part
&#9;&#9;&#9;&#9;if isModel then
&#9;&#9;&#9;&#9;&#9;adornee = model
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;objectValueSelect[&quot;HoverBox&quot;].Adornee = adornee
&#9;&#9;&#9;&#9;local billboard = getBillboard(adornee)

&#9;&#9;&#9;&#9;local configBadge = billboard:FindFirstChild(&quot;ConfigBadge&quot;,true)
&#9;&#9;&#9;&#9;if configBadge then
&#9;&#9;&#9;&#9;&#9;configBadge.Image = configIconOverImage
&#9;&#9;&#9;&#9;&#9;highlightedImage = configBadge
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;needsIconReset = true
&#9;&#9;else
&#9;&#9;&#9;if needsIconReset then
&#9;&#9;&#9;&#9;mouse.Icon = &quot;&quot;
&#9;&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end
&#9;&#9;&#9;&#9;needsIconReset = false

&#9;&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;if needsIconReset then
&#9;&#9;&#9;mouse.Icon = &quot;&quot;
&#9;&#9;&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end
&#9;&#9;&#9;needsIconReset = false

&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;on3dObjectValueMouseMove(mouse, guiMain)
&#9;end
end

function cancelSelectionGui()
&#9;lastPart = nil

&#9;if selectionGui ~= nil then
&#9;&#9;closeFrame(selectionGui)
&#9;&#9;selectionGui = nil
&#9;&#9;for pos, connection in pairs(valueConnections) do
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;end
&#9;&#9;valueConnections = {}
&#9;end

&#9;showConfigurationAnnotations()

&#9;if lastConfig then
&#9;&#9;local configValues = lastConfig:GetChildren()
&#9;&#9;for i = 1, #configValues do
&#9;&#9;&#9;if origValueMap[configValues[i].Name] ~= nil then
&#9;&#9;&#9;&#9;if constrained(configValues[i]) then configValues[i].ConstrainedValue = origValueMap[configValues[i].Name]
&#9;&#9;&#9;&#9;else configValues[i].Value = origValueMap[configValues[i].Name] end

&#9;&#9;&#9;&#9;origValueMap[configValues[i].Name] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif lastVehicleSeat then
&#9;&#9;lastVehicleSeat.MaxSpeed = origValueMap[&quot;MaxSpeed&quot;]
&#9;&#9;origValueMap[&quot;MaxSpeed&quot;] = nil
&#9;&#9;lastVehicleSeat.Steer = origValueMap[&quot;Steer&quot;]
&#9;&#9;origValueMap[&quot;Steer&quot;] = nil
&#9;&#9;lastVehicleSeat.Torque = origValueMap[&quot;Torque&quot;]
&#9;&#9;origValueMap[&quot;Torque&quot;] = nil
&#9;&#9;lastVehicleSeat.TurnSpeed = origValueMap[&quot;TurnSpeed&quot;]
&#9;&#9;origValueMap[&quot;TurnSpeed&quot;] = nil
&#9;end
end

function removeSelectionGui()
&#9;if selectionGui ~= nil then
&#9;&#9;closeFrame(selectionGui)
&#9;&#9;for pos, connection in pairs(valueConnections) do
&#9;&#9;&#9;connection:disconnect()
&#9;&#9;end
&#9;&#9;valueConnections = {}
&#9;end

&#9;if objectValueSelect[&quot;HoverBox&quot;] then objectValueSelect[&quot;HoverBox&quot;].Adornee = nil end

&#9;showConfigurationAnnotations()

&#9;if lastConfig then
&#9;&#9;local configValues = lastConfig:GetChildren()
&#9;&#9;for i = 1, #configValues do
&#9;&#9;&#9;if origValueMap[configValues[i].Name] ~= nil then
&#9;&#9;&#9;&#9;origValueMap[configValues[i].Name] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function canSelectObject(part)
&#9;if isRestricted then
&#9;&#9;waitForChild(playerArea,&quot;PlayerArea&quot;)
&#9;&#9;if isRestricted and playerArea:FindFirstChild(&quot;PlayerArea&quot;) and part:IsDescendantOf(playerArea.PlayerArea) then
&#9;&#9;&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

local function findConfigInModel(model)
&#9;local children = model:GetChildren()
&#9;for i = 1, #children do
&#9;&#9;if children[i]:IsA(&quot;Configuration&quot;) or children[i]:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;return children[i]
&#9;&#9;end
&#9;end
&#9;for i = 1, #children do
&#9;&#9;if #children[i]:GetChildren() &gt; 0 then
&#9;&#9;&#9;local returnValue = findConfigInModel(children[i])
&#9;&#9;&#9;if returnValue ~= nil then
&#9;&#9;&#9;&#9;return returnValue
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return nil
end

function findConfiguration(part)
&#9;print(&quot;findConfiguration on&quot;,part)
&#9;local partInModel, model = isInModel(part)
&#9;if partInModel then
&#9;&#9;local isModelConfig = findConfigInModel(model)
&#9;&#9;return isModelConfig
&#9;else
&#9;&#9;local children = part:GetChildren() &#9;&#9;
&#9;&#9;if children then
&#9;&#9;&#9;for pos, child in pairs(children) do
&#9;&#9;&#9;&#9;if child:IsA(&quot;Configuration&quot;) or child:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;return child
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return nil
end

function removeBillboards()
&#9;local guis = guiMain:GetChildren()
&#9;for i = 1, #guis do
&#9;&#9;if guis[i]:IsA(&quot;Frame&quot;) then
&#9;&#9;&#9;guis[i]:remove()
&#9;&#9;end
&#9;end
end

function on3dButton1Up(mouse, guiMain, playerGui)
&#9;if objectValueSelect[&quot;Enabled&quot;] then
&#9;&#9;on3dObjectValueButton1Up(mouse, guiMain)
&#9;&#9;return
&#9;elseif canSelectObject(mouse.Target) then
&#9;&#9;local part = mouse.Target
&#9;&#9;local foundPart = nil
&#9;&#9;if part:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;foundPart = part
&#9;&#9;else
&#9;&#9;&#9;foundPart = findConfiguration(part)
&#9;&#9;end
&#9;
&#9;&#9;if foundPart then
&#9;&#9;&#9;
&#9;&#9;&#9;if foundPart == lastPart then
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end
&#9;&#9;&#9;lastPart = foundPart

&#9;&#9;&#9;removeBillboards()
&#9;&#9;&#9;screen.Enabled = true

&#9;&#9;&#9;if foundPart:IsA(&quot;Configuration&quot;) then
&#9;&#9;&#9;&#9;selectionGui = processConfiguration(foundPart, playerGui)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;selectionGui = processVehicleSeat(foundPart, playerGui)&#9;
&#9;&#9;&#9;end
&#9;&#9;&#9;selectionGui.Parent = guiMain
&#9;&#9;&#9;openFrame(selectionGui, selectionGui.Size)

&#9;&#9;&#9;local hasModel, model = isInModel(part)
&#9;&#9;&#9;if hasModel then
&#9;&#9;&#9;&#9;screen.Adornee = model
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;screen.Adornee = part
&#9;&#9;&#9;end

&#9;&#9;&#9;if highlightedImage then 
&#9;&#9;&#9;&#9;highlightedImage.Image = configIconImage
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;cancelSelectionGui()
&#9;end
end

function onEquippedLocal(mouse)
&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)

&#9;if player == nil then return end

&#9;print(&quot;isRestricted = &quot;,isRestricted)
&#9;if isRestricted then
&#9;&#9;waitForChild(game.Workspace,&quot;BuildingAreas&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas,&quot;Area1&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas.Area1,&quot;Player&quot;)
&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == player.Name then
&#9;&#9;&#9;&#9;playerArea = areas[i]
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;print(&quot;player area is&quot;,playerArea)
&#9;&#9;STATIC_BASE_PLATE = playerArea
&#9;end

&#9;if not screen then
&#9;&#9;screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = &quot;ConfigGui&quot;
&#9;&#9;screen.Size = UDim2.new(0,360,0,180)
&#9;&#9;screen.Enabled = false
&#9;&#9;screen.Active = true
&#9;&#9;screen.Parent = player.PlayerGui
&#9;&#9;screen.AlwaysOnTop = true

&#9;&#9;guiMain = Instance.new(&quot;Frame&quot;)
&#9;&#9;guiMain.BackgroundTransparency = 1
&#9;&#9;guiMain.Size = UDim2.new(1,0,1,0)
&#9;&#9;guiMain.Parent = screen
&#9;else
&#9;&#9;removeBillboards()
&#9;&#9;lastPart = nil
&#9;&#9;screen.Parent = player.PlayerGui
&#9;end

&#9;setUpConfigurationService(guiMain)
&#9;showConfigurationAnnotations()

&#9;mouse.Button1Up:connect(function() on3dButton1Up(mouse, guiMain, player.PlayerGui) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse, guiMain) end)

&#9;objectValueSelect.HoverBox = Instance.new(&quot;SelectionBox&quot;)
&#9;objectValueSelect.HoverBox.Name = &quot;HoverBox&quot;
&#9;objectValueSelect.HoverBox.Color = BrickColor.new(&quot;Really blue&quot;)
&#9;objectValueSelect.HoverBox.Transparency = 0.5
&#9;objectValueSelect.HoverBox.Adornee = nil
&#9;objectValueSelect.HoverBox.Parent = player.PlayerGui;
end

function onUnequippedLocal()

&#9;local guiChildren = game.Players.LocalPlayer.PlayerGui:GetChildren()
&#9;for i = 1, #guiChildren do
&#9;&#9;if guiChildren[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;guiChildren[i].Parent = nil
&#9;&#9;end
&#9;end

&#9;destroyConfigurationService()

&#9;objectValueSelect.HoverBox:Remove()

&#9;if screen then
&#9;&#9;screen.Parent = nil
&#9;end

&#9;player = nil

&#9;hideConfigurationAnnotations()

&#9;objectValueSelect = {}
end


local configTable = {}

function createVisualAnnotation(config, guiMain)
&#9;local selection = Instance.new(&quot;SelectionBox&quot;)
&#9;selection.Name = &quot;Annotation&quot;
&#9;selection.Color = BrickColor.new(&quot;Really blue&quot;)
&#9;selection.Transparency = 0.5
&#9;selection.Parent = guiMain.Parent
&#9;return selection
end

function configurationParentChanged(data, part)
&#9;local isModel, model = isInModel(part)
&#9;if not isModel then
&#9;&#9;data[&quot;VisualAnnotation&quot;].Adornee = part
&#9;else
&#9;&#9;data[&quot;VisualAnnotation&quot;].Adornee = model
&#9;end
end

function showConfigurationAnnotations()
&#9;for config, data in pairs(configTable) do
&#9;&#9;data[&quot;VisualAnnotation&quot;].Visible = true
&#9;end
end


function hideConfigurationAnnotations()
&#9;for config, data in pairs(configTable) do
&#9;&#9;data[&quot;VisualAnnotation&quot;].Visible = false
&#9;end
end

local function isInMyArea(part)
&#9;if part.Parent == nil then return false end
&#9;if part.Parent:FindFirstChild(&quot;Player&quot;) and part.Parent.Player:IsA(&quot;StringValue&quot;) then
&#9;&#9;if part.Parent.Player.Value == player.Name then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;elseif part.Parent == game.Workspace.BuildingAreas or part.Parent == game.Workspace then
&#9;&#9;return false
&#9;else
&#9;&#9;return isInMyArea(part.Parent)
&#9;end
end

function findBillboard(guiTable)
&#9;if not guiTable then return end

&#9;for i = 1, #guiTable do
&#9;&#9;if guiTable[i] and guiTable[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;return guiTable[i]
&#9;&#9;end
&#9;end
end

function getBillboard(adornee)
&#9;local guiKey = adornee
&#9;
&#9;local billboard = findBillboard(adornmentTable[guiKey])
&#9;if not billboard then
&#9;&#9;local screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = adornee.Name .. &quot;BadgeGUI&quot;
&#9;&#9;screen.Size = UDim2.new(1.5,0,1.5,0)
&#9;&#9;screen.Enabled = true
&#9;&#9;screen.Active = true
&#9;&#9;screen.AlwaysOnTop = true
&#9;&#9;screen.ExtentsOffset = Vector3.new(0,0,0)
&#9;&#9;screen.Adornee = adornee
&#9;&#9;screen.Parent = game.Players.LocalPlayer.PlayerGui

&#9;&#9;if not adornmentTable[guiKey] then 
&#9;&#9;&#9;adornmentTable[guiKey] = {}
&#9;&#9;end
&#9;&#9;table.insert(adornmentTable[guiKey],screen)

&#9;&#9;return screen
&#9;end

&#9;return billboard
end

function hasBadge(adornee)
&#9;local screen = getBillboard(adornee)
&#9;if not screen then return false end
&#9;return screen:FindFirstChild(&quot;Badge&quot;,true)
end

function removeBadge(adornee)
&#9;local screen = getBillboard(adornee)
&#9;local badge = screen:FindFirstChild(&quot;ConfigBadge&quot;,true)
&#9;if badge then badge:remove() end
end

function giveConfigBadge(adornee)
&#9;local billboard = getBillboard(adornee)

&#9;local configBadge = Instance.new(&quot;ImageLabel&quot;)
&#9;configBadge.Name = &quot;ConfigBadge&quot;
&#9;configBadge.BackgroundTransparency = 1
&#9;configBadge.Image = configIconImage
&#9;configBadge.Size = UDim2.new(1,0,1,0)
&#9;configBadge.Parent = billboard

&#9;billboard.Parent =  game.Players.LocalPlayer.PlayerGui

&#9;local badgeCon = configBadge.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;configBadge.Visible = (configBadge.AbsoluteSize.X &gt; 10)
&#9;&#9;end
&#9;end)

&#9;local enterCon = configBadge.MouseEnter:connect(function()
&#9;&#9;configBadge.Image = configIconHoverImage
&#9;end)

&#9;local leaveCon = configBadge.MouseLeave:connect(function()
&#9;&#9;configBadge.Image = configIconImage
&#9;end)

&#9;local killCon = nil
&#9;killCon = configBadge.AncestryChanged:connect(function(child,parent)
&#9;&#9;if parent == nil then
&#9;&#9;&#9;killCon:disconnect()
&#9;&#9;&#9;badgeCon:disconnect()
&#9;&#9;&#9;enterCon:disconnect()
&#9;&#9;&#9;leaveCon:disconnect()
&#9;&#9;end
&#9;end)
end

function configurationAdded(config, guiMain)
&#9;if configTable[config] then
&#9;&#9;return
&#9;end

&#9;if isRestricted and not inBaseplate(config) then return end
&#9;
&#9;local data = {}
&#9;data.Configuration = config
&#9;data.VisualAnnotation = createVisualAnnotation(config, guiMain)
&#9;if config:IsA(&quot;Configuration&quot;) then
&#9;&#9;data.Connection = config.AncestryChanged:connect(function(child, newParent)
&#9;&#9;&#9;if child == config then
&#9;&#9;&#9;&#9;configurationParentChanged(data, newParent)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;configurationParentChanged(data, config.Parent)
&#9;else
&#9;&#9;configurationParentChanged(data, config)
&#9;end

&#9;local partInModel, model = isInModel(config.Parent)
&#9;if partInModel then
&#9;&#9;if not hasBadge(model) then
&#9;&#9;&#9;giveConfigBadge(model)
&#9;&#9;end
&#9;else
&#9;&#9;if not hasBadge(config.Parent) then
&#9;&#9;&#9;giveConfigBadge(config.Parent)
&#9;&#9;end
&#9;end

&#9;configTable[config] = data
end

function configurationRemoved(config)

&#9;local data = configTable[config]&#9;
&#9;if not(data) then
&#9;&#9;--I have no opinion about this
&#9;&#9;return
&#9;end

&#9;if data.Connection then
&#9;&#9;data.Connection:disconnect()
&#9;end

&#9;data.VisualAnnotation:Remove()
&#9;removeBadge(config.Parent)
&#9;
&#9;configTable[config] = nil
end

function findVehicleSeats(object, guiMain)
&#9;if object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;configurationAdded(object, guiMain)
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;findVehicleSeats(child, guiMain)
&#9;end
end

function setUpConfigurationService(guiMain)
&#9;ServiceConnections = {}
&#9;local collectionService = game:GetService(&quot;CollectionService&quot;)

&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance) if instance:IsA(&quot;Configuration&quot;) then configurationAdded(instance, guiMain) end end)
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance) if instance:IsA(&quot;Configuration&quot;) then configurationRemoved(instance) end end)

&#9;local configs = collectionService:GetCollection(&quot;Configuration&quot;)
&#9;if configs then
&#9;&#9;for pos, config in pairs(configs) do
&#9;&#9;&#9;configurationAdded(config, guiMain)
&#9;&#9;end
&#9;end

&#9;ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantAdded:connect(function(instance) if instance:IsA(&quot;VehicleSeat&quot;) then configurationAdded(instance, guiMain) end end)
&#9;ServiceConnections[#ServiceConnections+1] = game.workspace.DescendantRemoving:connect(function(instance) if instance:IsA(&quot;VehicleSeat&quot;) then configurationRemoved(instance) end end)
&#9;findVehicleSeats(game.workspace, guiMain)

end

function destroyConfigurationService()
&#9;for config, data in pairs(configTable) do
&#9;&#9;configurationRemoved(config)
&#9;end
&#9;for index, connection in pairs(ServiceConnections) do
&#9;&#9;connection:disconnect()
&#9;end
&#9;ServiceConnections = {}
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX15">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>0</R11>
					<R12>-0</R12>
					<R20>-0</R20>
					<R21>1</R21>
					<R22>-0</R22>
				</CoordinateFrame>
				<string name="Name">WiringTool</string>
				<Content name="TextureId"><url>http://www.pengin.xyz/asset?id=56954008</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="LocalScript" referent="RBX16">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">WiringScript</string>
					<ProtectedString name="Source">function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do
&#9;&#9;parent.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
local mouseMoveCon, mouseButtonDownCon = nil

local eventTable = {}
local receiverTable = {}
local ServiceConnections = {}
local adornmentTable = {}

local eventBadgeCount = {}
local receiverBadgeCount = {}

local root = nil

local isRestricted = false
if tostring(game.PlaceId) == &quot;41324860&quot; then
&#9;isRestricted = true
end

local CONNECT_BILLBOARD_GUI = &quot;ConnectBillboardGui&quot;
local WIRE_LASSO = &quot;WireLasso&quot;
local WIRE_TEXTURE = &quot;http://www.pengin.xyz/asset?id=56954045&quot;
--local WIRE_TEXTURE = &quot;rbxasset://Textures/ui/playerlist_small_hide_dn.png&quot;
local KILL_WIRE_TEXTURE = &quot;rbxasset://Textures/ui/CloseButton_dn.png&quot;
local STATIC_PLAYER_GUI = nil
local STATIC_BASE_PLATE = nil
local SELECTED_SOURCE = nil
local SELECTED_SINK = nil
local WIRE_LASSO_MAP = {}
local WIRING_PANEL_MAP = {}
local LAST_HOVERED_PART = nil
local SCREEN_MESSAGE = nil
local ANNOTATIONS = {}
local KNOWN_SOURCE_PARTS = {}
local KNOWN_SINK_PARTS = {}
local BASE_ANNOTATION_TRANSPARENCY = 0.5
local BASE_WIRE_TRANSPARENCY = 0.5
local BASE_WIRE_RADIUS = .06
local ENHANCED_WIRE_RADIUS = .12
local SOURCE_BUTTON_TEXT_COLOR = Color3.new(1, .5, 0)
local SOURCE_BUTTON_ICON_TEXTURE = &quot;http://www.pengin.xyz/asset?id=61334830&quot;
local SOURCE_BUTTON_ICON_HOVER_TEXTURE = &quot;http://www.pengin.xyz/asset?id=61335012&quot;
local SINK_BUTTON_TEXT_COLOR = Color3.new(0, 1, 0)
local SINK_BUTTON_ICON_TEXTURE = &quot;http://www.pengin.xyz/asset?id=60730993&quot;
local SINK_BUTTON_ICON_HOVER_TEXTURE = &quot;http://www.pengin.xyz/asset?id=61335025&quot;
local BUTTON_HOVER_TEXT_COLOR = Color3.new(1, 1, 1)
local BUTTON_ICON_WIDTH = 50
local DISCONNECT_ICON_HOVER_TEXTURE = &quot;http://www.pengin.xyz/asset?id=55130256&quot;
local DISCONNECT_SOURCE_ICON_TEXTURE = &quot;http://www.pengin.xyz/asset?id=55130237&quot;
local DISCONNECT_SINK_ICON_TEXTURE = &quot;http://www.pengin.xyz/asset?id=55130219&quot;
local TAIL_TEXTURE = &quot;http://www.pengin.xyz/asset?id=55134078&quot;
local USE_BILLBOARD_GUI = true
local LAST_CLICK_TIME = 0
local CLICK_HELP_TIME_DELTA = .8
local SOURCE_BADGE_TEXTURE = &quot;http://www.pengin.xyz/asset?id=60730993&quot;
local SINK_BADGE_TEXTURE = &quot;http://www.pengin.xyz/asset?id=61334830&quot;

local ALL_TEXTURES = { SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;DISCONNECT_ICON_HOVER_TEXTURE, DISCONNECT_SOURCE_ICON_TEXTURE,
&#9;&#9;DISCONNECT_SINK_ICON_TEXTURE, TAIL_TEXTURE, WIRE_TEXTURE, SOURCE_BADGE_TEXTURE, SINK_BADGE_TEXTURE}

for idx, asset in ipairs(ALL_TEXTURES) do
&#9;game:GetService(&quot;ContentProvider&quot;):Preload(asset)
end

function clearSelection()
&#9;SELECTED_SOURCE = nil
&#9;SELECTED_SINK = nil
&#9;getLocalLasso().From = nil
&#9;getLocalLasso().To = nil
end

function clearScreenMessage()
&#9;if SCREEN_MESSAGE ~= nil then
&#9;&#9;SCREEN_MESSAGE:Remove()
&#9;&#9;SCREEN_MESSAGE = nil
&#9;end
end

function clearHover()
&#9;if LAST_HOVERED_PART ~= nil then
&#9;&#9;local lastHover = LAST_HOVERED_PART
&#9;&#9;if not ANNOTATIONS[lastHover] then
&#9;&#9;&#9;lastHover = findModel(lastHover)
&#9;&#9;end

&#9;&#9;ANNOTATIONS[lastHover].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;if WIRING_PANEL_MAP[lastHover] ~= nil then
&#9;&#9;&#9;WIRING_PANEL_MAP[lastHover]:Remove()
&#9;&#9;&#9;WIRING_PANEL_MAP[lastHover] = nil
&#9;&#9;end
&#9;&#9;setPartWireTransparency(LAST_HOVERED_PART, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)
&#9;end
end

function getPlayerGui()
&#9;if STATIC_PLAYER_GUI == nil then
&#9;&#9;STATIC_PLAYER_GUI = game.Players:GetPlayerFromCharacter(Tool.Parent).PlayerGui
&#9;end
&#9;return STATIC_PLAYER_GUI
end

function findMyBasePlate()
&#9;if isRestricted then
&#9;&#9;if STATIC_BASE_PLATE == nil then
&#9;&#9;&#9;local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;&#9;for i = 1, #buildingAreas do
&#9;&#9;&#9;&#9;if buildingAreas[i].Player.Value == script.Parent.Parent.Name then
&#9;&#9;&#9;&#9;&#9;waitForChild(buildingAreas[i],&quot;PlayerArea&quot;)
&#9;&#9;&#9;&#9;&#9;STATIC_BASE_PLATE = buildingAreas[i].PlayerArea
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;return STATIC_BASE_PLATE
&#9;end

&#9;return nil
end

function getLocalLasso()
&#9;if not game.Players.LocalPlayer.PlayerGui:FindFirstChild(&quot;lasso&quot;) then
&#9;&#9;local lasso = Instance.new(&quot;FloorWire&quot;)
&#9;&#9;lasso.Name = &quot;lasso&quot;
&#9;&#9;lasso.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;lasso.Color = BrickColor.new(&quot;Really black&quot;)
&#9;end

&#9;return game.Players.LocalPlayer.PlayerGui.lasso
end

function findModel(part)
&#9;if isRestricted then
&#9;&#9;local basePlate = findMyBasePlate()
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= basePlate.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == basePlate.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;else
&#9;&#9;local origPart = part
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == &quot;Workspace&quot; or part.Name == &quot;game&quot; then
&#9;&#9;&#9;&#9;return origPart
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;end

&#9;return nil
end

function createVisualAnnotation(part, guiMain)
&#9;local selection = Instance.new(&quot;SelectionBox&quot;, guiMain)
&#9;selection.Name = &quot;Annotation&quot;
&#9;selection.Color = BrickColor.new(&quot;Lime green&quot;)
&#9;selection.Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;selection.Adornee = part
&#9;return selection
end

function isInteractivePart(obj)
&#9;if obj == nil then return false end
&#9;if obj:IsA(&quot;Part&quot;) then
&#9;&#9;for idx, child in ipairs(obj:GetChildren()) do
&#9;&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) or child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;return false
end

function applyToConnectorsWires(sourceOrSink, fn)
&#9;if sourceOrSink:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;for idx, recv in ipairs(sourceOrSink:GetAttachedReceivers()) do
&#9;&#9;&#9;fn(WIRE_LASSO_MAP[sourceOrSink][recv])
&#9;&#9;end
&#9;else
&#9;&#9;local source = sourceOrSink.Source
&#9;&#9;if source ~= nil then
&#9;&#9;&#9;fn(WIRE_LASSO_MAP[source][sourceOrSink])
&#9;&#9;end
&#9;end
end

function warnNoWireableParts()
&#9;local topHint = nil
&#9;pcall(function() topHint = getPlayerGui().Gui.Hints.CenterHint end)
&#9;
&#9;if topHint then
&#9;&#9;topHint.Add.Label.Value = &quot;No Wiring Parts!  Add Wiring Parts using the Stamper Tool.&quot;
&#9;&#9;topHint.Add.Width.Value = 580
&#9;&#9;topHint.Add.Time.Value = 10
&#9;&#9;topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end

function warnNotClickingWireablePart()
&#9;if getPlayerGui():FindFirstChild(&quot;CenterHint&quot;, true) then
&#9;&#9;local topHint = getPlayerGui().Gui.Hints.CenterHint
&#9;&#9;topHint.Add.Label.Value = &quot;This part isn&apos;t wireable :(&quot;
&#9;&#9;topHint.Add.Width.Value = 580
&#9;&#9;topHint.Add.Time.Value = 2
&#9;&#9;topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end

--------------------------------------------------------------------------------
-- Screen messages (when source/sink is selected)

function stylizeScreenMessageLabel(label, text)
&#9;label.Text = text
&#9;label.FontSize = Enum.FontSize.Size24
&#9;label.Font = Enum.Font.ArialBold
&#9;label.BackgroundTransparency = 1
&#9;label.BorderSizePixel = 0
&#9;label.Size = UDim2.new(0, label.TextBounds.x, 0, label.TextBounds.y)
&#9;label.TextColor3 = Color3.new(1, 1, 1)
end

function createSourceIcon(parent, precedingText)
&#9;local sourceIcon = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;sourceIcon.Archivable = false
&#9;sourceIcon.Image = SOURCE_BUTTON_ICON_TEXTURE
&#9;sourceIcon.Size = UDim2.new(0, 30, 0, 30)
&#9;sourceIcon.BackgroundTransparency = 1
&#9;sourceIcon.BorderSizePixel = 0
&#9;sourceIcon.Position = UDim2.new(0,
&#9;&#9;&#9;precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
&#9;&#9;&#9;0, precedingText.Position.Y.Offset +
&#9;&#9;&#9;&#9;((precedingText.Size.Y.Offset - sourceIcon.Size.Y.Offset) / 2))
&#9;return sourceIcon
end

function createSinkIcon(parent, precedingText)
&#9;local sinkIcon = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;sinkIcon.Archivable = false
&#9;sinkIcon.Image = SINK_BUTTON_ICON_TEXTURE
&#9;sinkIcon.Size = UDim2.new(0, 30, 0, 30)
&#9;sinkIcon.BackgroundTransparency = 1
&#9;sinkIcon.BorderSizePixel = 0
&#9;sinkIcon.Position = UDim2.new(0,
&#9;&#9;&#9;precedingText.Position.X.Offset + precedingText.TextBounds.x + 5,
&#9;&#9;&#9;0, precedingText.Position.Y.Offset +
&#9;&#9;&#9;&#9;((precedingText.Size.Y.Offset - sinkIcon.Size.Y.Offset) / 2))
&#9;return sinkIcon
end

function addToAllXPositions(objs, offset)
&#9;for idx, obj in ipairs(objs) do
&#9;&#9;pos = obj.Position
&#9;&#9;obj.Position = UDim2.new(0, pos.X.Offset + offset, 0, pos.Y.Offset)
&#9;end
end

function showSourceScreenMessage(source)
&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;gui.Archivable = false
&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Archivable = false
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local line1part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line1part1.Archivable = false
&#9;stylizeScreenMessageLabel(line1part1, &quot;Choose a&quot;)

&#9;sinkIcon = createSinkIcon(frame, line1part1)
&#9;
&#9;line1part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line1part2.Archivable = false
&#9;stylizeScreenMessageLabel(line1part2, &quot;receiver to trigger when&quot;)
&#9;line1part2.Position = UDim2.new(0,
&#9;&#9;sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset + 5, 0, 0)

&#9;line1height = math.max(sinkIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

&#9;line2part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;line2part1.Archivable = false
&#9;stylizeScreenMessageLabel(line2part1, source.Parent.Name)
&#9;line2part1.Position = UDim2.new(0, 0, 0, line1height)
&#9;
&#9;sourceIcon = createSourceIcon(frame, line2part1)

&#9;line2part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part2, &quot;signals &quot;)
&#9;line2part2.Position = UDim2.new(0,
&#9;&#9;sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;line2part3 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part3, source.Name)
&#9;line2part3.TextColor3 = SOURCE_BUTTON_TEXT_COLOR
&#9;line2part3.Position = UDim2.new(0,
&#9;&#9;line2part2.Position.X.Offset + line2part2.Size.X.Offset,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;-- re-center
&#9;line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
&#9;line2width = line2part3.Position.X.Offset + line2part3.Size.X.Offset

&#9;if line1width &gt; line2width then
&#9;&#9;local halfDelta = (line1width - line2width) / 2
&#9;&#9;addToAllXPositions({line2part1, sourceIcon, line2part2, line2part3}, halfDelta)
&#9;else
&#9;&#9;local halfDelta = (line2width - line1width) / 2
&#9;&#9;addToAllXPositions({line1part1, sinkIcon, line1part2}, halfDelta)
&#9;end

&#9;frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
&#9;&#9;&#9;0, 2 * line1height + 5)
&#9;frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

&#9;clearScreenMessage()
&#9;SCREEN_MESSAGE = gui
end

function showSinkScreenMessage(sink)
&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Style = Enum.FrameStyle.RobloxRound

&#9;local line1part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line1part1, &quot;Choose which&quot;)

&#9;local sourceIcon = createSourceIcon(frame, line1part1)
&#9;
&#9;line1part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line1part2, &quot;signal will cause&quot;)
&#9;line1part2.Position = UDim2.new(0,
&#9;&#9;sourceIcon.Position.X.Offset + sourceIcon.Size.X.Offset + 5, 0, 0)

&#9;local line1height = math.max(sourceIcon.Size.Y.Offset, line1part1.Size.Y.Offset)

&#9;line2part1 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part1, sink.Parent.Name .. &quot; to&quot;)
&#9;line2part1.Position = UDim2.new(0, 0, 0, line1height)
&#9;
&#9;local sinkIcon = createSinkIcon(frame, line2part1)

&#9;line2part2 = Instance.new(&quot;TextLabel&quot;, frame)
&#9;stylizeScreenMessageLabel(line2part2, sink.Name)
&#9;line2part2.TextColor3 = SINK_BUTTON_TEXT_COLOR
&#9;line2part2.Position = UDim2.new(0,
&#9;&#9;sinkIcon.Position.X.Offset + sinkIcon.Size.X.Offset,
&#9;&#9;0, line2part1.Position.Y.Offset)

&#9;-- re-center
&#9;line1width = line1part2.Position.X.Offset + line1part2.Size.X.Offset
&#9;line2width = line2part2.Position.X.Offset + line2part2.Size.X.Offset

&#9;if line1width &gt; line2width then
&#9;&#9;local halfDelta = (line1width - line2width) / 2
&#9;&#9;addToAllXPositions({line2part1, sinkIcon, line2part2}, halfDelta)
&#9;else
&#9;&#9;local halfDelta = (line2width - line1width) / 2
&#9;&#9;addToAllXPositions({line1part1, sourceIcon, line1part2}, halfDelta)
&#9;end

&#9;frame.Size = UDim2.new(0, math.max(line1width, line2width) + 15,
&#9;&#9;&#9;0, 2 * line1height + 5)
&#9;frame.Position = UDim2.new(.5, -frame.Size.X.Offset/2, 0, 0)

&#9;clearScreenMessage()
&#9;SCREEN_MESSAGE = gui
end

--------------------------------------------------------------------------------
-- Hover

function setPartWireTransparency(part, transparency, wireRadius, texture)
&#9;for idx, child in ipairs(part:GetChildren()) do
&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;for idx2, recv in ipairs(child:GetAttachedReceivers()) do
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(child, recv)
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Transparency = transparency
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].WireRadius = wireRadius
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Texture = texture
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[child][recv].Color = BrickColor.new(&quot;Really black&quot;)
&#9;&#9;&#9;end
&#9;&#9;elseif child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;local source = child.Source
&#9;&#9;&#9;if source ~= nil then
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(source, child)
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Transparency = transparency
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].WireRadius = wireRadius
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Texture = texture
&#9;&#9;&#9;&#9;WIRE_LASSO_MAP[source][child].Color = BrickColor.new(&quot;Really black&quot;)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function canHighlight(part,model)
&#9;if (KNOWN_SOURCE_PARTS[part] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[part] and SELECTED_SINK == nil) then
&#9;&#9;return true, part
&#9;elseif (KNOWN_SOURCE_PARTS[model] and SELECTED_SOURCE == nil) or (KNOWN_SINK_PARTS[model] and SELECTED_SINK == nil) then
&#9;&#9;return true, model
&#9;end

&#9;return false, nil
end

function hoverListener(mouse)
&#9;if mouse.Target == nil then return end

&#9;local part = mouse.Target
&#9;local model = findModel(part)
&#9;if LAST_HOVERED_PART ~= part and findModel(LAST_HOVERED_PART) ~= model then
&#9;&#9;clearHover()
&#9;&#9;local highlight, instance = canHighlight(part,model)
&#9;&#9;if highlight then
&#9;&#9;&#9;LAST_HOVERED_PART = part
&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 0
&#9;&#9;&#9;buildScreenPanel(model, mouse.X, mouse.Y)
&#9;&#9;&#9;setPartWireTransparency(part, 0, ENHANCED_WIRE_RADIUS, &quot;&quot;)
&#9;&#9;else
&#9;&#9;&#9;LAST_HOVERED_PART = nil
&#9;&#9;end

&#9;&#9;-- Point the temporary wire to the LAST_HOVERED_PART if not nil,
&#9;&#9;-- otherwise point it at the character
&#9;&#9;local otherEndOfWire = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;if LAST_HOVERED_PART ~= nil then
&#9;&#9;&#9;otherEndOfWire = LAST_HOVERED_PART
&#9;&#9;end
&#9;&#9;if SELECTED_SOURCE ~= nil then
&#9;&#9;&#9;getLocalLasso().To = otherEndOfWire
&#9;&#9;end
&#9;&#9;if SELECTED_SINK ~= nil then
&#9;&#9;&#9;getLocalLasso().From = otherEndOfWire
&#9;&#9;end
&#9;end
end

--------------------------------------------------------------------------------
-- Connect / Disconnect dialog

function addWireUiIfNotAlreadyThere(source, sink)
&#9;if WIRE_LASSO_MAP[source] == nil then
&#9;&#9;WIRE_LASSO_MAP[source] = {}
&#9;end
&#9;if WIRE_LASSO_MAP[source][sink] ~= nil then
&#9;&#9;return
&#9;end

&#9;pairLasso = Instance.new(&quot;FloorWire&quot;, getPlayerGui())
&#9;pairLasso.From = source.Parent
&#9;pairLasso.To = sink.Parent
&#9;pairLasso.Transparency = BASE_WIRE_TRANSPARENCY
&#9;pairLasso.Texture = &quot;&quot;
&#9;pairLasso.Name = WIRE_LASSO
&#9;pairLasso.Color = BrickColor.new(&quot;Really black&quot;)
&#9;WIRE_LASSO_MAP[source][sink] = pairLasso
end

function connectHelper(source, sink)
&#9;-- clear wires coming to sink
&#9;local old_source = sink.Source
&#9;if old_source ~= nil then
&#9;&#9;wire = WIRE_LASSO_MAP[old_source][sink]
&#9;&#9;if wire ~= nil then
&#9;&#9;&#9;wire:Remove()
&#9;&#9;&#9;WIRE_LASSO_MAP[old_source][sink] = nil
&#9;&#9;end
&#9;&#9;sink.Source = nil
&#9;end

&#9;sink.Source = source
&#9;addWireUiIfNotAlreadyThere(source, sink)
end

function makeSourceConnectCallback(source)
&#9;return function()
&#9;&#9;clearHover()
&#9;&#9;if SELECTED_SINK ~= nil then
&#9;&#9;&#9;connectHelper(source, SELECTED_SINK)
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;clearScreenMessage()
&#9;&#9;&#9;for part, val in pairs(KNOWN_SINK_PARTS) do
&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;SELECTED_SOURCE = source
&#9;&#9;&#9;getLocalLasso().From = source.Parent
&#9;&#9;&#9;getLocalLasso().To = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;&#9;showSourceScreenMessage(SELECTED_SOURCE)
&#9;&#9;&#9;for part, val in pairs(KNOWN_SOURCE_PARTS) do
&#9;&#9;&#9;&#9;if not KNOWN_SINK_PARTS[part] then
&#9;&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function makeSinkConnectCallback(sink)
&#9;return function()
&#9;&#9;clearHover()
&#9;&#9;if SELECTED_SOURCE ~= nil then
&#9;&#9;&#9;connectHelper(SELECTED_SOURCE, sink)
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;clearScreenMessage()
&#9;&#9;&#9;for part, val in pairs(KNOWN_SOURCE_PARTS) do
&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;SELECTED_SINK = sink
&#9;&#9;&#9;getLocalLasso().From = game.Players.LocalPlayer.Character.Humanoid.Torso
&#9;&#9;&#9;getLocalLasso().To = sink.Parent
&#9;&#9;&#9;showSinkScreenMessage(SELECTED_SINK)
&#9;&#9;&#9;for part, val in pairs(KNOWN_SINK_PARTS) do
&#9;&#9;&#9;&#9;if not KNOWN_SOURCE_PARTS[part] then
&#9;&#9;&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;&#9;&#9;ANNOTATIONS[model].Transparency = 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function makeControlButton(y_position, frame, sourceOrSink, textColor, iconImage, iconHoverImage, callbackBuilder)
&#9;local button = Instance.new(&quot;TextButton&quot;, frame)
&#9;button.Position = UDim2.new(.025, 0, 0, y_position)
&#9;button.Text = sourceOrSink.Name
&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;button.Style = Enum.ButtonStyle.Custom
&#9;button.BorderSizePixel = 0
&#9;button.BackgroundTransparency = 1
&#9;button.BackgroundColor3 = Color3.new(0, 0 ,0)
&#9;button.TextColor3 = textColor
&#9;button.Font = Enum.Font.ArialBold
&#9;button.FontSize = Enum.FontSize.Size18
&#9;button.ZIndex = 2
&#9;button.Size = UDim2.new(.95, 0, 0, button.TextBounds.y)
&#9;
&#9;local icon = Instance.new(&quot;ImageLabel&quot;, button)
&#9;icon.Image = iconImage
&#9;icon.ZIndex = 2
&#9;icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, -8)
&#9;icon.Size = UDim2.new(0, 30, 0 , 30)
&#9;icon.BackgroundTransparency = 1

&#9;button.MouseEnter:connect(function()
&#9;&#9;applyToConnectorsWires(sourceOrSink, function(wire)
&#9;&#9;&#9;wire.Texture = WIRE_TEXTURE
&#9;&#9;&#9;wire.Velocity = 2
&#9;&#9;end)
&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
&#9;&#9;icon.Image = iconHoverImage
&#9;end)
&#9;local leaveCallback = function()
&#9;&#9;applyToConnectorsWires(sourceOrSink, function(wire)
&#9;&#9;&#9;wire.Texture = &quot;&quot;
&#9;&#9;end)
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.TextColor3 = textColor
&#9;&#9;icon.Image = iconImage
&#9;end
&#9;button.MouseLeave:connect(leaveCallback)
&#9;button.MouseButton1Click:connect(function()
&#9;&#9;callbackBuilder(sourceOrSink)()
&#9;&#9;leaveCallback()
&#9;end)
&#9;return button
end

function makeDisconnectCallback(source, sink)
&#9;clearHover()
&#9;sink.Source = nil
&#9;if WIRE_LASSO_MAP[source] ~= nil then
&#9;&#9;lassoUi = WIRE_LASSO_MAP[source][sink]
&#9;&#9;if lassoUi ~= nil then
&#9;&#9;&#9;lassoUi:Remove()
&#9;&#9;&#9;WIRE_LASSO_MAP[source][sink] = nil
&#9;&#9;end
&#9;end
end

function makeDisconnectButton(y_position, frame, localConnector, foreignConnector, textColor, iconImage)
&#9;local source = nil
&#9;local sink = nil
&#9;if localConnector:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;source = localConnector
&#9;&#9;sink = foreignConnector
&#9;else
&#9;&#9;source = foreignConnector
&#9;&#9;sink = localConnector
&#9;end

&#9;local button = Instance.new(&quot;TextButton&quot;, frame)
&#9;button.Position = UDim2.new(0, 17, 0, y_position)
&#9;button.Text = foreignConnector.Name .. &quot; (&quot; .. foreignConnector.Parent.Name .. &quot;)&quot; 
&#9;button.TextXAlignment = Enum.TextXAlignment.Left
&#9;button.Style = Enum.ButtonStyle.Custom
&#9;button.BackgroundTransparency = 1
&#9;button.BackgroundColor3 = Color3.new(0, 0 ,0)
&#9;button.TextColor3 = textColor
&#9;button.BorderSizePixel = 0
&#9;button.Font = Enum.Font.Arial
&#9;button.FontSize = Enum.FontSize.Size18
&#9;button.ZIndex = 3
&#9;button.Size = UDim2.new(.95, -10, 0, button.TextBounds.y + 2)
&#9;
&#9;local icon = Instance.new(&quot;ImageLabel&quot;, button)
&#9;icon.Image = iconImage
&#9;icon.Parent = button
&#9;icon.Position = UDim2.new(0, button.TextBounds.x + 10, 0, 2)
&#9;icon.Size = UDim2.new(0, 15, 0 , 15)
&#9;icon.BackgroundTransparency = 1

&#9;local buttonCons = {}

&#9;table.insert(buttonCons,
&#9;&#9;button.MouseButton1Click:connect(function() 
&#9;&#9;&#9;makeDisconnectCallback(source, sink)
&#9;&#9;end)
&#9;)
&#9;table.insert(buttonCons,
&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;button.TextColor3 = BUTTON_HOVER_TEXT_COLOR
&#9;&#9;&#9;icon.Image = DISCONNECT_ICON_HOVER_TEXTURE
&#9;&#9;&#9;WIRE_LASSO_MAP[source][sink].Color = BrickColor.new(&quot;Really red&quot;)
&#9;&#9;end)
&#9;)
&#9;table.insert(buttonCons,
&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;button.TextColor3 = textColor
&#9;&#9;icon.Image = iconImage
&#9;&#9;WIRE_LASSO_MAP[source][sink].Color = BrickColor.new(&quot;Really black&quot;)
&#9;end)
&#9;)

&#9;table.insert(buttonCons,
&#9;&#9;button.AncestryChanged:connect(function(child,parent)
&#9;&#9;&#9;if parent == nil then
&#9;&#9;&#9;&#9;for i = 1, #buttonCons do
&#9;&#9;&#9;&#9;&#9;buttonCons[i]:disconnect()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;)

&#9;return button
end

function getPartSourcesAndSinks(part, sources,sinks)
&#9;for idx, child in ipairs(part:GetChildren()) do
&#9;&#9;if child:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;table.insert(sources, child)
&#9;&#9;elseif child:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;table.insert(sinks, child)
&#9;&#9;end
&#9;end
end

function getSourcesAndSinks(instance,sources,sinks)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;getPartSourcesAndSinks(instance, sources,sinks)
&#9;elseif instance:IsA(&quot;Model&quot;) then
&#9;&#9;local modelChildren = instance:GetChildren()
&#9;&#9;for i = 1, #modelChildren do
&#9;&#9;&#9;if modelChildren[i]:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;getPartSourcesAndSinks(modelChildren[i],sources,sinks)
&#9;&#9;&#9;elseif modelChildren[i]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;getSourcesAndSinks(modelChildren[i],sources,sinks)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

local function findFirstConnector(node)
&#9;if node:IsA(&quot;BasePart&quot;) then
&#9;&#9;for idx, child in ipairs(node:GetChildren()) do
&#9;&#9;&#9;if connector == nil and (child:IsA(&quot;CustomEvent&quot;) or child:IsA(&quot;CustomEventReceiver&quot;)) then
&#9;&#9;&#9;&#9;return child
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;local children = node:GetChildren()
&#9;&#9;if #children == 0 then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;local subConnector = findFirstConnector(children[i])
&#9;&#9;&#9;if subConnector then return subConnector end
&#9;&#9;end
&#9;end
end

function buildScreenPanel(part, x, y)
&#9;sources = {}
&#9;sinks = {}
&#9;getSourcesAndSinks(part,sources,sinks)

&#9;local gui = nil
&#9;local mouseFrame = nil
&#9;if USE_BILLBOARD_GUI then
&#9;&#9;gui = Instance.new(&quot;BillboardGui&quot;, getPlayerGui())
&#9;&#9;gui.Name = &quot;WiringGui&quot;
&#9;&#9;gui.StudsOffset = Vector3.new(0, 1.5, 0)
&#9;&#9;gui.ExtentsOffset = Vector3.new(0,0, 0)
&#9;&#9;gui.Adornee = part
&#9;&#9;gui.Active = true
&#9;&#9;gui.AlwaysOnTop = true
&#9;else 
&#9;&#9;gui = Instance.new(&quot;ScreenGui&quot;, getPlayerGui())
&#9;end

&#9;frame = Instance.new(&quot;Frame&quot;, gui)
&#9;frame.Style = Enum.FrameStyle.RobloxRound
&#9;frame.ZIndex = 1
&#9;frame.Active = true

&#9;local maxWidth = 0
&#9;local y_position = 5

&#9;if SELECTED_SOURCE == nil then
&#9;&#9;for idx, source in ipairs(sources) do
&#9;&#9;&#9;local button = makeControlButton(y_position, frame, source, SOURCE_BUTTON_TEXT_COLOR,
&#9;&#9;&#9;&#9;&#9;SOURCE_BUTTON_ICON_TEXTURE, SOURCE_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;&#9;&#9;&#9;makeSourceConnectCallback)
&#9;&#9;&#9;maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
&#9;&#9;&#9;y_position = y_position + button.TextBounds.y

&#9;&#9;&#9;receivers = source:GetAttachedReceivers()
&#9;&#9;&#9;for sub_idx, receiver in ipairs(receivers) do
&#9;&#9;&#9;&#9;y_position = y_position + 2
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(source, receiver)
&#9;&#9;&#9;&#9;local button = makeDisconnectButton(y_position, frame, source, receiver,
&#9;&#9;&#9;&#9;&#9;SOURCE_BUTTON_TEXT_COLOR, DISCONNECT_SOURCE_ICON_TEXTURE)
&#9;&#9;&#9;&#9;y_position = y_position + button.TextBounds.y
&#9;&#9;&#9;&#9;maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
&#9;&#9;&#9;end
&#9;&#9;&#9;y_position = y_position + 5
&#9;&#9;end
&#9;end

&#9;if SELECTED_SINK == nil then
&#9;&#9;for idx, sink in ipairs(sinks) do
&#9;&#9;&#9;local button = makeControlButton(y_position, frame, sink, SINK_BUTTON_TEXT_COLOR,
&#9;&#9;&#9;&#9;&#9;SINK_BUTTON_ICON_TEXTURE, SINK_BUTTON_ICON_HOVER_TEXTURE,
&#9;&#9;&#9;&#9;&#9;makeSinkConnectCallback)
&#9;&#9;&#9;maxWidth = math.max(1.25 * (button.TextBounds.x + BUTTON_ICON_WIDTH), maxWidth)
&#9;&#9;&#9;y_position = y_position + button.TextBounds.y

&#9;&#9;&#9;local sender = sink.Source
&#9;&#9;&#9;if sender ~= nil then
&#9;&#9;&#9;&#9;y_position = y_position + 2
&#9;&#9;&#9;&#9;-- addWire takes source first
&#9;&#9;&#9;&#9;addWireUiIfNotAlreadyThere(sender, sink)
&#9;&#9;&#9;&#9;local button = makeDisconnectButton(y_position, frame, sink, sender,
&#9;&#9;&#9;&#9;&#9;SINK_BUTTON_TEXT_COLOR, DISCONNECT_SINK_ICON_TEXTURE)
&#9;&#9;&#9;&#9;y_position = y_position + button.TextBounds.y
&#9;&#9;&#9;&#9;maxWidth = math.max(1.15 * (button.TextBounds.x + 17 + 25), maxWidth)
&#9;&#9;&#9;end
&#9;&#9;&#9;y_position = y_position + 5
&#9;&#9;end
&#9;end

&#9;-- set size and position
&#9;if not getPlayerGui():FindFirstChild(&quot;ScreenGui&quot;) then
&#9;&#9;local screenGui = Instance.new(&quot;ScreenGui&quot;)
&#9;&#9;screenGui.Parent = getPlayerGui()
&#9;end

&#9;local screenSize = getPlayerGui().ScreenGui.AbsoluteSize
&#9;local menuWidth = maxWidth
&#9;local menuHeight = y_position + 17.5
&#9;if USE_BILLBOARD_GUI then

&#9;&#9;
&#9;&#9;local size = Vector3.new(0,0,0)
&#9;&#9;if gui.Adornee:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;size = gui.Adornee.Size
&#9;&#9;elseif gui.Adornee:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;size = gui.Adornee:GetModelSize()
&#9;&#9;end

&#9;&#9;local xSize= size.X
&#9;&#9;if size.Y &gt; xSize then
&#9;&#9;&#9;xSize = size.Y
&#9;&#9;end

&#9;&#9;gui.Size = UDim2.new(0, menuWidth,0,menuHeight + 150)
&#9;&#9;gui.SizeOffset = Vector2.new(0, -50.0 / (menuHeight + 150));
&#9;&#9;
&#9;&#9;local tail = Instance.new(&quot;ImageLabel&quot;, frame)
&#9;&#9;tail.Size = UDim2.new(0, 32, 0, 32)
&#9;&#9;tail.Position = UDim2.new(.5, -16, 1, 8)
&#9;&#9;tail.Image = TAIL_TEXTURE
&#9;&#9;tail.BackgroundTransparency = 1
&#9;&#9;tail.Visible = true

&#9;&#9;f = Instance.new(&quot;Frame&quot;, gui)
&#9;&#9;f.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;f.BackgroundTransparency = 1
&#9;&#9;f.ZIndex = 1
&#9;&#9;f.Active = true
&#9;&#9;b = Instance.new(&quot;TextButton&quot;, f)
&#9;&#9;b.ZIndex = 1
&#9;&#9;b.BackgroundTransparency = 1
&#9;&#9;b.Text = &quot;&quot;
&#9;&#9;b.BorderSizePixel = 0
&#9;&#9;b.Size = UDim2.new(1, 0, 1, 0)
&#9;&#9;b.MouseButton1Click:connect(function ()
&#9;&#9;&#9;print(&quot;Clicker&quot;)
&#9;&#9;&#9;local foundConnector = findFirstConnector(findModel(LAST_HOVERED_PART))
&#9;&#9;&#9;if foundConnector ~= nil and foundConnector:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;&#9;makeSourceConnectCallback(foundConnector)()
&#9;&#9;&#9;elseif foundConnector ~= nil and foundConnector:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;&#9;makeSinkConnectCallback(foundConnector)()
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;else
&#9;&#9;x = math.min(x - 9, screenSize.x - menuWidth) 
&#9;&#9;y = math.min(y - 9, screenSize.y - menuHeight)
&#9;&#9;frame.Position = UDim2.new(0, x, 0, y)
&#9;end

&#9;frame.Size = UDim2.new(0, menuWidth, 0, menuHeight)
&#9;frame.Position = UDim2.new(0.5,-menuWidth/2,0.05,0)
&#9;WIRING_PANEL_MAP[part] = gui
end

function inBaseplate(instance)
&#9;if instance == STATIC_BASE_PLATE then return true end

&#9;local instanceCopy = instance
&#9;print(&quot;instanceCopy init =&quot;,instanceCopy)

&#9;while instanceCopy and (instanceCopy.Parent ~= nil or instanceCopy.Parent ~= game.Workspace) do
&#9;&#9;if instanceCopy.Parent == STATIC_BASE_PLATE then
&#9;&#9;&#9;print(&quot;in baseplate&quot;)
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;&#9;print(&quot;instanceCopy =&quot;,instanceCopy)
&#9;&#9;instanceCopy = instanceCopy.Parent
&#9;end

&#9;return false
end

--------------------------------------------------------------------------------
-- Tool.Equipped/Unequipped

Tool.Equipped:connect(function(mouse)
&#9;playerGui = getPlayerGui()
&#9;LAST_HOVERED_PART = nil

&#9;if isRestricted then
&#9;&#9;root = findMyBasePlate()
&#9;else
&#9;&#9;root = game.Workspace
&#9;end

&#9;local interactiveCount = setUpConfigurationService()

&#9;if not interactiveCount or interactiveCount == 0 then
&#9;&#9;warnNoWireableParts()
&#9;end

&#9;getLocalLasso().Texture = WIRE_TEXTURE
&#9;getLocalLasso().WireRadius = ENHANCED_WIRE_RADIUS
&#9;clearSelection()

&#9;if isRestricted then
&#9;&#9;mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;end

&#9;mouseMoveCon = mouse.Move:connect(function() hoverListener(mouse) end)
&#9;mouseButtonDownCon = mouse.Button1Down:connect(function()
&#9;&#9;if LAST_HOVERED_PART ~= nil then return end

&#9;&#9;clearSelection()
&#9;&#9;clearScreenMessage()
&#9;&#9;clearHover()
&#9;&#9;local annotationCount = 0
&#9;&#9;for part, annotation in pairs(ANNOTATIONS) do
&#9;&#9;&#9;annotation.Transparency = BASE_ANNOTATION_TRANSPARENCY
&#9;&#9;&#9;annotationCount = annotationCount + 1
&#9;&#9;end
&#9;&#9;if annotationCount == 0 then
&#9;&#9;&#9;warnNoWireableParts()
&#9;&#9;elseif time() - LAST_CLICK_TIME &lt; CLICK_HELP_TIME_DELTA then
&#9;&#9;&#9;warnNotClickingWireablePart()
&#9;&#9;end
&#9;&#9;LAST_CLICK_TIME = time()
&#9;end)
&#9;-- TODO: onkeydown/onmouse2down, prevent hover from triggering
&#9;-- until the up event comes
end)

Tool.Unequipped:connect(function()
&#9;playerGui = getPlayerGui()

&#9;destroyConfigurationService()

&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if mouseButtonDownCon then mouseButtonDownCon:disconnect() end

&#9;if playerGui:FindFirstChild(&quot;CenterHint&quot;, true) then
&#9;&#9;local centerHint = getPlayerGui().Gui.Hints.CenterHint
&#9;&#9;centerHint.Delete.Disabled = false
&#9;end

&#9;-- TODO: simplify these side effects
&#9;-- call clearHover before removing annotations, because
&#9;-- clear hover resets annotation boxes. Also before clearing
&#9;-- lassos because this may create lassos
&#9;clearHover()

&#9;for part, gui in pairs(WIRING_PANEL_MAP) do
&#9;&#9;if gui then gui:Remove() end
&#9;end
&#9;WIRING_PANEL_MAP = {}

&#9;for source, submap in pairs(WIRE_LASSO_MAP) do
&#9;&#9;for sink, wire in pairs(submap) do
&#9;&#9;&#9;wire:Remove()
&#9;&#9;end
&#9;end
&#9;WIRE_LASSO_MAP = {}

&#9;for k,box in pairs(ANNOTATIONS) do
&#9;&#9;box:Remove()
&#9;end
&#9;ANNOTATIONS = {}

&#9;KNOWN_SOURCE_PARTS = {}
&#9;KNOWN_SINK_PARTS = {}

&#9;clearSelection()
&#9;clearScreenMessage()
&#9;LAST_HOVERED_PART = nil
end)

function findBillboard(guiTable)
&#9;if not guiTable then return end

&#9;for i = 1, #guiTable do
&#9;&#9;if guiTable[i] and guiTable[i]:IsA(&quot;BillboardGui&quot;) then
&#9;&#9;&#9;return guiTable[i]
&#9;&#9;end
&#9;end
end

function getBillboard(adornee)
&#9;local guiKey = adornee

&#9;
&#9;local billboard = findBillboard(adornmentTable[guiKey])
&#9;if not billboard then
&#9;&#9;local screen = Instance.new(&quot;BillboardGui&quot;)
&#9;&#9;screen.Name = adornee.Name .. &quot;BadgeGUI&quot;
&#9;&#9;screen.Size = UDim2.new(1.5,0,1.5,0)
&#9;&#9;screen.Enabled = true
&#9;&#9;screen.Active = true
&#9;&#9;screen.AlwaysOnTop = true
&#9;&#9;screen.ExtentsOffset = Vector3.new(0,0,0)
&#9;&#9;screen.Adornee = adornee
&#9;&#9;screen.Parent = game.Players.LocalPlayer.PlayerGui

&#9;&#9;if not adornmentTable[guiKey] then return end
&#9;&#9;table.insert(adornmentTable[guiKey],screen)

&#9;&#9;local badgeFrame = Instance.new(&quot;Frame&quot;)
&#9;&#9;badgeFrame.Name = &quot;BadgeFrame&quot;
&#9;&#9;badgeFrame.Size = UDim2.new(2,0,1,0)
&#9;&#9;badgeFrame.Position = UDim2.new(-0.5,0,0,0)
&#9;&#9;badgeFrame.BackgroundTransparency = 1
&#9;&#9;badgeFrame.Parent = screen

&#9;&#9;return screen
&#9;end

&#9;return billboard
end

function repositionBadges(badgeFrame)
&#9;local badges = badgeFrame:GetChildren()
&#9;if #badges == 1 then
&#9;&#9;badges[1].Position = UDim2.new(0.25,0,0,0)
&#9;elseif #badges == 2 then
&#9;&#9;badges[1].Position = UDim2.new(0,0,0,0)
&#9;&#9;badges[2].Position = UDim2.new(0.5,0,0)
&#9;end
end

function hasBadge(adornee, type)
&#9;local screen = getBillboard(adornee)
&#9;return screen:FindFirstChild(type .. &quot;Badge&quot;,true)
end

function removeBadge(adornee, type)
&#9;local screen = getBillboard(adornee)
&#9;local badge = screen:FindFirstChild(type .. &quot;Badge&quot;,true)
&#9;if badge then badge:remove() end
end

function createBadge(adornee,type)
&#9;local screen = getBillboard(adornee)

&#9;local wiringBadge = Instance.new(&quot;ImageLabel&quot;)
&#9;wiringBadge.Name = type .. &quot;Badge&quot;
&#9;wiringBadge.BackgroundTransparency = 1
&#9;if type == &quot;Receiver&quot; then
&#9;&#9;wiringBadge.Image = SOURCE_BADGE_TEXTURE
&#9;else
&#9;&#9;wiringBadge.Image = SINK_BADGE_TEXTURE
&#9;end

&#9;wiringBadge.Position = UDim2.new(0.25,0,0,0)
&#9;wiringBadge.Size = UDim2.new(0.5,0,1,0)
&#9;wiringBadge.Parent = screen.BadgeFrame
&#9;wiringBadge.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;if wiringBadge.AbsoluteSize.X &lt; 10 then
&#9;&#9;&#9;&#9;wiringBadge.Visible = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;wiringBadge.Visible = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end)

&#9;repositionBadges(screen.BadgeFrame)
end

function upAdorneeCount(adornee,type)
&#9;local typeLower = string.lower(type)
&#9;if typeLower == &quot;receiver&quot; then
&#9;&#9;if not receiverBadgeCount[adornee] then
&#9;&#9;&#9;receiverBadgeCount[adornee] = 1
&#9;&#9;else
&#9;&#9;&#9;receiverBadgeCount[adornee] = receiverBadgeCount[adornee] + 1
&#9;&#9;end
&#9;elseif typeLower == &quot;event&quot; then
&#9;&#9;if not eventBadgeCount[adornee] then
&#9;&#9;&#9;eventBadgeCount[adornee] = 1
&#9;&#9;else
&#9;&#9;&#9;eventBadgeCount[adornee] = eventBadgeCount[adornee] + 1
&#9;&#9;end
&#9;end
end

function downAdorneeCount(adornee,type)
&#9;local typeLower = string.lower(type)
&#9;if typeLower == &quot;receiver&quot; then
&#9;&#9;if receiverBadgeCount[adornee] then
&#9;&#9;&#9;receiverBadgeCount[adornee] = receiverBadgeCount[adornee] - 1
&#9;&#9;&#9;if receiverBadgeCount[adornee] &lt; 1 then
&#9;&#9;&#9;&#9;receiverBadgeCount[adornee] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif typeLower == &quot;event&quot; then
&#9;&#9;if eventBadgeCount[adornee] then
&#9;&#9;&#9;eventBadgeCount[adornee] = eventBadgeCount[adornee] - 1
&#9;&#9;&#9;if eventBadgeCount[adornee] &lt; 1 then
&#9;&#9;&#9;&#9;eventBadgeCount[adornee] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function createAdornment(adornee,adornColor,type)
&#9;upAdorneeCount(adornee,type)

&#9;if receiverBadgeCount[adornee] == 1 or eventBadgeCount[adornee] == 1 then
&#9;&#9;local box = Instance.new(&quot;SelectionBox&quot;)
&#9;&#9;box.Color = adornColor
&#9;&#9;box.Name = adornee.Name .. &quot;Selection&quot; .. tostring(type)
&#9;&#9;box.Adornee = adornee
&#9;&#9;box.Transparency = 0.5
&#9;&#9;box.Parent = game.Players.LocalPlayer.PlayerGui
&#9;&#9;if not adornmentTable[adornee] then
&#9;&#9;&#9;adornmentTable[adornee] = {}
&#9;&#9;end

&#9;&#9;ANNOTATIONS[adornee] = box
&#9;&#9;table.insert(adornmentTable[adornee],box)

&#9;&#9;if not hasBadge(adornee,type) then
&#9;&#9;&#9;createBadge(adornee,type)
&#9;&#9;end
&#9;end
end

function doRemoveAdornment(adornee, type)
&#9;local key = adornee
&#9;if not adornmentTable[key] then return end
&#9;for i = 1, #adornmentTable[key] do
&#9;&#9;if adornmentTable[key] and adornmentTable[key][i] then
&#9;&#9;&#9;if string.find(adornmentTable[key][i].Name,type) then
&#9;&#9;&#9;&#9;adornmentTable[key][i]:remove()
&#9;&#9;&#9;&#9;adornmentTable[key][i] = nil
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function removeAdornment(adornee, type)
&#9;downAdorneeCount(adornee,type)

&#9;if type == &quot;Receiver&quot; then
&#9;&#9;if not receiverBadgeCount[adornee]then
&#9;&#9;&#9;removeBadge(adornee, type)
&#9;&#9;&#9;doRemoveAdornment(adornee, type)
&#9;&#9;end
&#9;elseif type == &quot;Event&quot; then
&#9;&#9;if not eventBadgeCount[adornee] then
&#9;&#9;&#9;removeBadge(adornee, type)
&#9;&#9;&#9;doRemoveAdornment(adornee, type)
&#9;&#9;end
&#9;end
end

function eventReceiverAdded(receiver,wirePartCount)
&#9;if isRestricted then
&#9;&#9;if not inBaseplate(receiver) then return wirePartCount end
&#9;end
&#9;receiverTable[receiver] = findModel(receiver.Parent)
&#9;createAdornment(receiverTable[receiver], BrickColor.new(&quot;Lime green&quot;), &quot;Receiver&quot;)
&#9;setPartWireTransparency(receiver.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)

&#9;KNOWN_SINK_PARTS[receiver.Parent] = true
&#9;KNOWN_SINK_PARTS[receiverTable[receiver]]= true

&#9;if wirePartCount then
&#9;&#9;return wirePartCount + 1
&#9;else
&#9;&#9;return 0
&#9;end

end

function eventAdded(event,wirePartCount)
&#9;if isRestricted then
&#9;&#9;if not inBaseplate(event) then return wirePartCount end
&#9;end
&#9;eventTable[event] = findModel(event.Parent)
&#9;createAdornment(eventTable[event], BrickColor.new(&quot;Bright orange&quot;), &quot;Event&quot;)
&#9;setPartWireTransparency(event.Parent, BASE_WIRE_TRANSPARENCY, BASE_WIRE_RADIUS, &quot;&quot;)

&#9;KNOWN_SOURCE_PARTS[event.Parent] = true
&#9;KNOWN_SOURCE_PARTS[eventTable[event]]= true

&#9;if wirePartCount then
&#9;&#9;return wirePartCount + 1
&#9;else
&#9;&#9;return 0
&#9;end
end

function eventReceiverRemoved(receiver)
&#9;if not receiverTable[receiver] then return end

&#9;KNOWN_SINK_PARTS[receiver.Parent] = false
&#9;KNOWN_SINK_PARTS[receiverTable[receiver]]= false

&#9;removeAdornment(receiverTable[receiver],&quot;Receiver&quot;)
&#9;receiverTable[receiver] = nil
end

function eventRemoved(event)
&#9;if not eventTable[event] then return end

&#9;KNOWN_SOURCE_PARTS[event.Parent] = false
&#9;KNOWN_SOURCE_PARTS[eventTable[event]]= false

&#9;removeAdornment(eventTable[event], &quot;Event&quot;)
&#9;eventTable[event] = nil
end

function setUpConfigurationService()
&#9;local wirePartCount = 0
&#9;ServiceConnections = {}
&#9;local collectionService = game:GetService(&quot;CollectionService&quot;)

&#9;-- first lets check if anything already exists
&#9;local receivers = collectionService:GetCollection(&quot;CustomEventReceiver&quot;)
&#9;if receivers then
&#9;&#9;for pos, receiver in pairs(receivers) do
&#9;&#9;&#9;wirePartCount = eventReceiverAdded(receiver, wirePartCount)
&#9;&#9;end
&#9;end

&#9;local events = collectionService:GetCollection(&quot;CustomEvent&quot;)
&#9;if events then
&#9;&#9;for pos, event in pairs(events) do
&#9;&#9;&#9;wirePartCount = eventAdded(event, wirePartCount)
&#9;&#9;end
&#9;end

&#9;-- Now lets listen for any future additions/removals
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemAdded:connect(function(instance)
&#9;&#9;if instance:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;eventReceiverAdded(instance)
&#9;&#9;elseif instance:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;eventAdded(instance)
&#9;&#9;end 
&#9;end)
&#9;ServiceConnections[#ServiceConnections+1] = collectionService.ItemRemoved:connect(function(instance)
&#9;&#9;if instance:IsA(&quot;CustomEventReceiver&quot;) then
&#9;&#9;&#9;eventReceiverRemoved(instance)
&#9;&#9;elseif instance:IsA(&quot;CustomEvent&quot;) then
&#9;&#9;&#9;eventRemoved(instance)
&#9;&#9;end
&#9;end)

&#9;return wirePartCount
end

function destroyConfigurationService()
&#9;-- first lets destroy the collection service
&#9;for index, connection in pairs(ServiceConnections) do
&#9;&#9;connection:disconnect()
&#9;end
&#9;ServiceConnections = {}

&#9;-- now lets remove all of our collection service objects that were generated
&#9;for event, object in pairs(eventTable) do
&#9;&#9;eventRemoved(event)
&#9;end
&#9;for eventReceiver, object in pairs(receiverTable) do
&#9;&#9;eventReceiverRemoved(eventReceiver)
&#9;end
end

</ProtectedString>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX17">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.5</Z>
					<R00>0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">DeleteTool</string>
				<Content name="TextureId"><url>http://www.pengin.xyz/asset?id=55212908</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="BoolValue" referent="RBX18">
				<Properties>
					<string name="Name">AutoWedgeClusterParts</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="Part" referent="RBX19">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">0</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">199</int>
					<CoordinateFrame name="CFrame">
						<X>-523.400024</X>
						<Y>96.5999985</Y>
						<Z>631.5</Z>
						<R00>-0</R00>
						<R01>-1</R01>
						<R02>0</R02>
						<R10>-0</R10>
						<R11>-0</R11>
						<R12>1</R12>
						<R20>-1</R20>
						<R21>-0</R21>
						<R22>0</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0.400000006</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">0</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">2</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.800000012</Y>
						<Z>3</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX20">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.pengin.xyz/asset/?id=16198309</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>1.20000005</X>
							<Y>1.20000005</Y>
							<Z>1.20000005</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.pengin.xyz/asset/?id=16198294</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
				<Item class="Sound" referent="RBX21">
					<Properties>
						<bool name="Looped">false</bool>
						<string name="Name">Sound</string>
						<float name="Pitch">1</float>
						<bool name="PlayOnRemove">false</bool>
						<Content name="SoundId"><url>http://www.pengin.xyz/Asset/?ID=12135982</url></Content>
						<float name="Volume">0.699999988</float>
					</Properties>
				</Item>
			</Item>
			<Item class="BoolValue" referent="RBX22">
				<Properties>
					<string name="Name">IsRestricted</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX23">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<ProtectedString name="Source">script.Parent.Userr.Value = script.Parent.Parent.Parent.Name</ProtectedString>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX24">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">SwordScript</string>
					<ProtectedString name="Source">-------- OMG HAX

r = game:service(&quot;RunService&quot;)


local damage = 0


local slash_damage = 0


sword = script.Parent.Handle
Tool = script.Parent



function attack()
&#9;local anim = Instance.new(&quot;StringValue&quot;)
&#9;anim.Name = &quot;toolanim&quot;
&#9;anim.Value = &quot;Slash&quot;
&#9;anim.Parent = Tool
end


function swordUp()
&#9;Tool.GripForward = Vector3.new(-1,0,0)
&#9;Tool.GripRight = Vector3.new(0,1,0)
&#9;Tool.GripUp = Vector3.new(0,0,1)
end

function swordOut()
&#9;Tool.GripForward = Vector3.new(0,0,1)
&#9;Tool.GripRight = Vector3.new(0,-1,0)
&#9;Tool.GripUp = Vector3.new(-1,0,0)
end



Tool.Enabled = true

function onActivated()

&#9;if not Tool.Enabled then
&#9;&#9;return
&#9;end

&#9;Tool.Enabled = false

&#9;local character = Tool.Parent;
&#9;local humanoid = character.Humanoid
&#9;if humanoid == nil then
&#9;&#9;return 
&#9;end

&#9;

&#9;attack()

&#9;wait(1)

&#9;Tool.Enabled = true
end


script.Parent.Activated:connect(onActivated)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX25">
				<Properties>
					<string name="Name">Userr</string>
					<string name="Value"></string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX26">
				<Properties>
					<string name="Name">toolanim</string>
					<string name="Value">Slash</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX27">
				<Properties>
					<string name="Name">toolanim</string>
					<string name="Value">Slash</string>
				</Properties>
			</Item>
			<Item class="StringValue" referent="RBX28">
				<Properties>
					<string name="Name">toolanim</string>
					<string name="Value">Slash</string>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX29">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Model Delete Local</string>
					<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end


local Tool = script.Parent

enabled = true
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/delete_sel.png&quot;)

local cluster = nil

local selectionBox
local currentSelection
local currentSelectionColors = {}
local selectionLasso

local deleteDistance = 100
local player = nil
--local playerModel = nil
local playerModel = game.Workspace
local buildingPlate = nil

local highlight = false

local megaClusterSelectionBox = Instance.new(&quot;Part&quot;)
megaClusterSelectionBox.FormFactor = &quot;Custom&quot;
megaClusterSelectionBox.Size = Vector3.new(4, 4, 4) -- a little thicker than 4x4x4 unit clusterpart; just so selection box is more easily seen
megaClusterSelectionBox.Transparency = 1
megaClusterSelectionBox.Anchored = true
megaClusterSelectionBox.CanCollide = false
megaClusterSelectionBox.Parent = nil

waitForChild(Tool, &quot;IsRestricted&quot;)
local isRestricted = Tool.IsRestricted.Value

waitForChild(Tool, &quot;AutoWedgeClusterParts&quot;)
local autoWedgeClusterParts = Tool.AutoWedgeClusterParts.Value

function hint(label)

&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player ~= nil and _player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end

end

function canDeleteObject(part)
&#9;-- let them delete anything that they created *or* anything on their baseplate
&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; deleteDistance and (isChildOfMyModel(part) or partInBounds(part))
end

-- For Restricting Stamper Tool (isRestricted)
function inBounds(part)

&#9;if part == nil then return false end

&#9;if part:IsA(&quot;Part&quot;) or part:IsA(&quot;WedgePart&quot;) or part:IsA(&quot;TrussPart&quot;) then
&#9;&#9;if not partInBounds(part) then return false end
&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;local primPart = object.PrimaryPart
&#9;&#9;if not partInBounds(primPart) then return false end
&#9;end

&#9;return true

end

function partInBounds(part)

&#9;local xOne = buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

&#9;return true

end


function findModel(part)
&#9;while part ~= nil do
&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= playerModel.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;return part
&#9;&#9;elseif part.Name == playerModel.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;return nil
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end

&#9;return nil
end

function cleanOrphanedModel(parent)
&#9;if not parent then return end
&#9;if parent.className == &quot;Model&quot; then
&#9;&#9;local children = parent:GetChildren()
&#9;&#9;if #children == 0 and parent.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;local oldParent = parent.Parent
&#9;&#9;&#9;parent:Remove()
&#9;&#9;&#9;cleanOrphanedModel(oldParent)
&#9;&#9;end
&#9;end
end

function isChildOfMyModel(part)
&#9;&#9;if not playerModel then return true end
&#9;&#9;if playerModel:IsAncestorOf(part) then
&#9;&#9;&#9;return true
&#9;&#9;else return false end
end


-- Cyrion&apos;s auto-wedge fcn:
--sets cell x, y, z to default material if parameter is provided, if not sets cell x, y, z to be whatever material it previously was
--returns true if made a wedge, false if the cell remains a block
function MakeWedge(x, y, z, defaultmaterial)
&#9;local c = game.Workspace.Terrain
&#9;--gather info about all the cells around x, y, z
&#9;surroundings = {} --surroundings is a 3 x 3 x 3 array of the material of the cells adjacent to x, y, z
&#9;for i = x - 1, x + 1 do
&#9;&#9;surroundings[i] = {}
&#9;&#9;for j = y - 1, y + 1 do
&#9;&#9;&#9;surroundings[i][j] = {}
&#9;&#9;&#9;for k = z - 1, z + 1 do
&#9;&#9;&#9;&#9;local material, wedge, rotation = c:GetCell(i, j, k)
&#9;&#9;&#9;&#9;surroundings[i][j][k] = material.Value
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--make some useful arrays and counters
&#9;local sides = {} --sides is an array of the material of the 4 adjacent sides
&#9;sides[0] = surroundings[x - 1][y][z]
&#9;sides[1] = surroundings[x][y][z + 1]
&#9;sides[2] = surroundings[x + 1][y][z]
&#9;sides[3] = surroundings[x][y][z - 1]
&#9;local adjacentSides = 0
&#9;for n = 0, 3 do
&#9;&#9;if sides[n] &gt; 0 then
&#9;&#9;&#9;adjacentSides = adjacentSides + 1
&#9;&#9;end
&#9;end
&#9;local sidesAbove = {} --sides is an array of the material of the 4 adjacent sides 1 height above
&#9;sidesAbove[0] = surroundings[x - 1][y + 1][z]
&#9;sidesAbove[1] = surroundings[x][y + 1][z + 1]
&#9;sidesAbove[2] = surroundings[x + 1][y + 1][z]
&#9;sidesAbove[3] = surroundings[x][y + 1][z - 1]
&#9;local adjacentSidesAbove = 0
&#9;for n = 0, 3 do
&#9;&#9;if sidesAbove[n] &gt; 0 then
&#9;&#9;&#9;adjacentSidesAbove = adjacentSidesAbove + 1
&#9;&#9;end
&#9;end
&#9;local corners = {} --corners is an array of the material of the 4 adjacent corners
&#9;corners[0] = surroundings[x - 1][y][z - 1]
&#9;corners[1] = surroundings[x - 1][y][z + 1]
&#9;corners[2] = surroundings[x + 1][y][z + 1]
&#9;corners[3] = surroundings[x + 1][y][z - 1]
&#9;local adjacentCorners = 0
&#9;for n = 0, 3 do
&#9;&#9;if corners[n] &gt; 0 then
&#9;&#9;&#9;adjacentCorners = adjacentCorners + 1
&#9;&#9;end
&#9;end
&#9;local cornersAbove = {} --corners is an array of the material of the 4 adjacent corners 1 height above
&#9;cornersAbove[0] = surroundings[x - 1][y + 1][z - 1]
&#9;cornersAbove[1] = surroundings[x - 1][y + 1][z + 1]
&#9;cornersAbove[2] = surroundings[x + 1][y + 1][z + 1]
&#9;cornersAbove[3] = surroundings[x + 1][y + 1][z - 1]
&#9;local adjacentCornersAbove = 0
&#9;for n = 0, 3 do
&#9;&#9;if cornersAbove[n] &gt; 0 then
&#9;&#9;&#9;adjacentCornersAbove = adjacentCornersAbove + 1
&#9;&#9;end
&#9;end
&#9;--determine what type of wedge to make
&#9;local material = nil
&#9;local wedge = nil
&#9;local rotation = nil 
&#9;if defaultmaterial then
&#9;&#9;material = defaultmaterial
&#9;else
&#9;&#9;material, wedge, rotation = c:GetCell(x, y, z) --start with the existing material, wedge, and rotation
&#9;end
&#9;wedge = 0 --default wedge is a block
&#9;rotation = 0 --default rotation is 0
&#9;--type 1: 45 degree ramp //must not have a block on top and must have a block under, and be surrounded by 1 side; or 3 sides and the 2 corners between them
&#9;if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
&#9;&#9;if adjacentSides == 1 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if sides[n] &gt; 0 then
&#9;&#9;&#9;&#9;&#9;wedge = 1
&#9;&#9;&#9;&#9;&#9;rotation = (n + 1) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;elseif  adjacentSides == 3 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0 and sides[(n + 2) % 4] &gt; 0 then
&#9;&#9;&#9;&#9;&#9;wedge = 1
&#9;&#9;&#9;&#9;&#9;rotation = (n + 2) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 2: 45 degree corner //must not have a block on top and must have a block under, and be surrounded by 2 sides and the 1 corner between them; or 3 sides and 1 corner between 2 of them (facing towards that corner)
&#9;if surroundings[x][y + 1][z] == 0 and surroundings[x][y - 1][z] &gt; 0 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if sides[n] &gt; 0 and corners[(n + 1) % 4] &gt; 0 and sides[(n + 1) % 4] &gt; 0 and (adjacentSides == 2 or (adjacentSides == 3 and (corners[(n + 3) % 4] &gt; 0 or (sides[(n + 2) % 4] &gt; 0 and corners[(n + 2) % 4] &gt; 0) or (sides[(n + 3) % 4] &gt; 0 and corners[n] &gt; 0)))) then
&#9;&#9;&#9;&#9;wedge = 2
&#9;&#9;&#9;&#9;rotation = (n + 2) % 4
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 3: 45 degree inverse corner //surrounded by three sides or 4 sides and 3 corners, with nothing above or else a block on top surrounded on 2 sides and the corner between them
&#9;if adjacentSides == 3 and surroundings[x][y + 1][z] &gt; 0 then
&#9;&#9;if adjacentCorners &gt; 1 then
&#9;&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;&#9;if (corners[n] == 0 or cornersAbove[n] == 0) and (sides[(n - 1) % 4] == 0 or sides[n] == 0) and (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0) then 
&#9;&#9;&#9;&#9;&#9;wedge = 3
&#9;&#9;&#9;&#9;&#9;rotation = (n + 3) % 4
&#9;&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;elseif adjacentSides == 4 and adjacentCorners == 3 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if corners[n] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] &gt; 0 and cornersAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] == 0)) then
&#9;&#9;&#9;&#9;wedge = 3
&#9;&#9;&#9;&#9;rotation = (n + 3) % 4
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;--type 4: half a cube, as if it were cut diagonally from front to back //surrounded by 2 sides
&#9;if adjacentSides == 2 and adjacentCorners &lt; 4 then
&#9;&#9;for n = 0, 3 do
&#9;&#9;&#9;if sides[n] == 0 and sides[(n + 1) % 4] == 0 and (surroundings[x][y + 1][z] == 0 or (sidesAbove[n] == 0 and sidesAbove[(n + 1) % 4] == 0 and sidesAbove[(n + 2) % 4] &gt; 0 and sidesAbove[(n + 3) % 4] &gt; 0)) then
&#9;&#9;&#9;&#9;wedge = 4
&#9;&#9;&#9;&#9;rotation = n
&#9;&#9;&#9;&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;&#9;&#9;&#9;return true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;c:SetCell(x, y, z, material, wedge, rotation)
&#9;return false
end

function on3dButton1Down(mouse)
&#9;local part = mouse.Target

&#9;if part == nil then 
&#9;&#9;return
&#9;elseif part:IsA(&quot;Terrain&quot;) then
&#9;&#9;if cluster ~= nil then
&#9;&#9;&#9;local cellPos = cluster:WorldToCellPreferSolid(Vector3.new(mouse.Hit.x, mouse.Hit.y, mouse.Hit.z))
&#9;&#9;&#9;local x = cellPos.x
&#9;&#9;&#9;local y = cellPos.y
&#9;&#9;&#9;local z = cellPos.z

&#9;&#9;&#9;cluster:SetCell(x, y, z, 0, 0, 0)
&#9;&#9;&#9;
&#9;&#9;&#9;if (autoWedgeClusterParts) then

&#9;&#9;&#9;&#9;for i = x - 1, x + 1 do
&#9;&#9;&#9;&#9;&#9;for j = y - 1, y + 1 do
&#9;&#9;&#9;&#9;&#9;&#9;for k = z - 1, z + 1 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;MakeWedge(i, j, k)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;end

&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;on3dMouseMove(mouse)

&#9;&#9;end
&#9;elseif canDeleteObject(part) then
&#9;&#9;local model = findModel(part)
&#9;&#9;local oldParent
&#9;&#9;if model then 
&#9;&#9;&#9;if currentSelection == model then
&#9;&#9;&#9;&#9;currentSelection = nil
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;&#9;for _,v in pairs(model:GetChildren()) do
&#9;&#9;&#9;&#9;if v:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;&#9;positionnn = v.Position
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
model:Remove()
&#9;&#9;&#9;local greif = game.Lighting.AntiGreif:Clone()
&#9;&#9;&#9;greif.Head.Position = positionnn
&#9;&#9;&#9;local plrrr = script.Parent.Parent.Parent.Name
&#9;&#9;&#9;greif.Name = (&quot;Deleted by: &quot; .. (script.Parent.Userr.Value))
&#9;&#9;&#9;greif.Parent = game.Workspace
&#9;&#9;&#9;wait (4)
&#9;&#9;&#9;greif:Remove()
&#9;&#9;&#9;oldParent = model.Parent
&#9;&#9;&#9;
&#9;&#9;else
&#9;&#9;&#9;if currentSelection == part then
&#9;&#9;&#9;&#9;currentSelection = nil
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;&#9;local positionnn = part.Position
&#9;part:Remove()
&#9;&#9;&#9;local greif = game.Lighting.AntiGreif:Clone()
&#9;&#9;&#9;greif.Head.Position = positionnn
&#9;&#9;&#9;local plrrr = script.Parent.Parent.Parent.Name
&#9;&#9;&#9;greif.Name = (&quot;Deleted by: &quot; .. (script.Parent.Userr.Value))
&#9;&#9;&#9;greif.Parent = game.Workspace
&#9;&#9;&#9;wait (4)
&#9;&#9;&#9;greif:Remove()
&#9;&#9;&#9;oldParent = part.Parent
&#9;&#9;
&#9;&#9;end
&#9;&#9;cleanOrphanedModel(oldParent)
&#9;end
end

function saveSelectionColor(instance)
&#9;if instance:IsA(&quot;BasePart&quot;) then
&#9;&#9;currentSelectionColors[instance] = instance.BrickColor
&#9;&#9;if instance.BrickColor == BrickColor.Red() then
&#9;&#9;&#9;instance.BrickColor = BrickColor.new(&quot;Really red&quot;)
&#9;&#9;else
&#9;&#9;&#9;instance.BrickColor = BrickColor.Red()
&#9;&#9;end
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;end
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;if currentSelection then currentSelection = nil end
&#9;if selectionBox then selectionBox.Adornee = nil end
&#9;megaClusterSelectionBox.Parent = nil
end


function on3dMouseMove(mouse) 
&#9;if isRestricted then
&#9;&#9;mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;else
&#9;&#9;mouse.TargetFilter = megaClusterSelectionBox
&#9;end
&#9;local part = mouse.Target

&#9;if not part then
&#9;&#9;clearSelection() 
&#9;&#9;return
&#9;elseif part:IsA(&quot;Terrain&quot;) then
&#9;&#9;if not cluster then cluster = game.Workspace.Terrain end
&#9;&#9;local hitCell = cluster:WorldToCellPreferSolid(mouse.Hit.p)
&#9;&#9;if cluster:GetCell(hitCell.x, hitCell.y, hitCell.z).Value &gt; 0 then
&#9;&#9;&#9;megaClusterSelectionBox.CFrame = CFrame.new(cluster:CellCenterToWorld(hitCell.x, hitCell.y, hitCell.z))

&#9;&#9;&#9;if isRestricted then megaClusterSelectionBox.Parent = game.Workspace.BaseplateBumpers else megaClusterSelectionBox.Parent = game.Workspace end
&#9;&#9;&#9;selectionBox.Adornee = megaClusterSelectionBox
&#9;&#9;else
&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;return
&#9;&#9;end
&#9;elseif canDeleteObject(part) then
&#9;&#9;local model = findModel(part)
&#9;&#9;if model then &#9;&#9;
&#9;&#9;&#9;selectionBox.Color = BrickColor.Red()
&#9;&#9;&#9;setSelection(model)
&#9;&#9;else
&#9;&#9;&#9;selectionBox.Color = BrickColor.Red()
&#9;&#9;&#9;setSelection(part)
&#9;&#9;end
&#9;else
&#9;&#9;clearSelection()
&#9;end
end

local equipCount = 0
function onEquippedLocal(mouse) --Fix implemented by Luckymaxer
&#9;equipCount = equipCount + 1
&#9;local val = equipCount
&#9;
&#9;if isRestricted then
&#9;&#9;mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;else
&#9;&#9;mouse.TargetFilter = megaClusterSelectionBox
&#9;end

&#9;if isRestricted then
&#9;&#9;waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;&#9;if val ~= equipCount then
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)
&#9;
&#9;if not player then return end

&#9;if isRestricted then
&#9;&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #takenAreas do
&#9;&#9;&#9;&#9;if takenAreas[i]:FindFirstChild(&quot;Player&quot;) ~= nil then  -- Test if child exists (to fix current bug: &quot;Player&quot; child is omitted from 1 baseplate at random, when played online.)
&#9;&#9;&#9;&#9;&#9;if takenAreas[i].Player.Value == Tool.Parent.Name then
&#9;&#9;&#9;&#9;&#9;&#9;buildingPlate = takenAreas[i].PlayerArea.BasePlate
&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

   if buildingPlate then
&#9;&#9;playerModel  = buildingPlate.Parent
&#9;else
&#9;&#9;--playerModel  = nil
&#9;&#9;playerModel = game.Workspace
&#9;end

&#9;mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;mouse.Icon =&quot;rbxasset://textures\\HammerCursor.png&quot;

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Red()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;selectionLasso = Instance.new(&quot;SelectionPartLasso&quot;)
&#9;selectionLasso.Name = &quot;Model Delete Lasso&quot;
&#9;selectionLasso.Humanoid = character.Humanoid
&#9;selectionLasso.archivable = false
&#9;selectionLasso.Visible = true
&#9;selectionLasso.Parent = game.workspace
&#9;selectionLasso.Color = BrickColor.Red()

&#9;highlight = true
end

function onUnequippedLocal()
&#9;highlight = false
&#9;if selectionBox then
&#9;&#9;clearSelection()
&#9;&#9;selectionBox:Remove()
&#9;end
&#9;if selectionLasso then selectionLasso:Remove() end
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
</ProtectedString>
				</Properties>
			</Item>
			<Item class="Camera" referent="RBX30">
				<Properties>
					<Ref name="CameraSubject">null</Ref>
					<token name="CameraType">0</token>
					<CoordinateFrame name="CoordinateFrame">
						<X>3.12394333</X>
						<Y>1.09595561</Y>
						<Z>-5.37479115</Z>
						<R00>-0.166767851</R00>
						<R01>-0.184087351</R01>
						<R02>0.968659043</R02>
						<R10>-0</R10>
						<R11>0.98241663</R11>
						<R12>0.186701879</R12>
						<R20>-0.985996246</R20>
						<R21>0.0311358701</R21>
						<R22>-0.163835511</R22>
					</CoordinateFrame>
					<float name="FieldOfView">70</float>
					<CoordinateFrame name="Focus">
						<X>1.186625</X>
						<Y>0.722551823</Y>
						<Z>-5.04712009</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">ThumbnailCamera</string>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX31">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>-0.699999988</Z>
					<R00>-0</R00>
					<R01>0</R01>
					<R02>1</R02>
					<R10>1</R10>
					<R11>-0</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>1</R21>
					<R22>0</R22>
				</CoordinateFrame>
				<string name="Name">RotateTool</string>
				<Content name="TextureId"><url>http://www.pengin.xyz/asset/?id=59103214</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="LocalScript" referent="RBX32">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">RotateScript</string>
					<ProtectedString name="Source">-- NOTES:
--      NEEDS:
--            X  1.)  Make single blocks rotate always (they rotate 2x, then seem to think of themselves as blockers of themselves...  whaaa?)
--&#9;&#9;&#9;&#9;  X  2.)  Make scripts continue to work through rotations (or else error on any objects which can&apos;t be rotated...  prehaps elevators?)
--            3.)  File bug for #1 and for &quot;# of parts counted BEFORE instance-filter is applied for game.Workspace:FindPartsInRegion3&quot;
--            4.)  Make things rotate separately (break and make welds)
--&#9;&#9;&#9;&#9;  5.)  When something else is attached to a single block, stuff still breaks X&lt;

-- general functions
function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end
function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local Tool = script.Parent
local player
local playerArea
local selectionBox
local selectedModel = nil

local cluster = nil

waitForChild(Tool, &quot;ErrorBox&quot;)
local errorBox = Tool.ErrorBox

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;rbxasset://icons/configure_sel.png&quot;)


function getBoundingBox2(partOrModel)
-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
&#9;&#9;minVec = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
&#9;&#9;maxVec = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;boxMinInWorld1 = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;--boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld1 = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;--boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInWorld1.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInWorld1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInWorld1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInWorld1.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld1.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInWorld1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInWorld1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInWorld1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld1.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInWorld1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec
end

function isInRobloxModel(part)
&#9;if part == game.Workspace then
&#9;&#9;return false, nil
&#9;elseif part:FindFirstChild(&quot;RobloxModel&quot;) then 
&#9;&#9;return true, part
&#9;else
&#9;&#9;return isInRobloxModel(part.Parent)
&#9;end
end

function isInMyArea(part)
&#9;if part.Parent == nil then return false end
&#9;if part.Parent:FindFirstChild(&quot;Player&quot;) and part.Parent.Player:IsA(&quot;StringValue&quot;) then
&#9;&#9;if part.Parent.Player.Value == player.Name then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;elseif part.Parent == game.Workspace.BuildingAreas or part.Parent == game.Workspace then
&#9;&#9;return false
&#9;else
&#9;&#9;return isInMyArea(part.Parent)
&#9;end
end


function on3dButton1Down(mouse)
&#9;-- don&apos;t do anything for now (can fix later: for now this means you can click one model, drag mouse to second model, and release mouse, and this will activate second model)
end


function offsetPartsByVector3(partOrModel, offsetVector)
&#9;local insertCFrame
&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;object.CFrame = object.CFrame + offsetVector
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;partOrModel.CFrame = partOrModel.CFrame + offsetVector
&#9;end
end

function storeAndDisableScriptsInModel(parent, scriptTable)
&#9;--print(&quot;STORINGSCRIPTS&quot;)
&#9;for i, object in pairs(parent:GetChildren()) do
&#9;&#9;if object:IsA(&quot;Script&quot;) or object:IsA(&quot;LocalScript&quot;) then if not object.Disabled then print(object) object.Disabled = true table.insert(scriptTable, object) end end
&#9;&#9;if object.GetChildren then storeAndDisableScriptsInModel(object, scriptTable) end
&#9;end
end

function isInternalWeld(weld, model)
&#9;return (not weld.Part0 or weld.Part0:IsDescendantOf(model)) and (not weld.Part1 or weld.Part1:IsDescendantOf(model))
end

function storeAndRemoveWeldsInModel(initialmodel, model, welds, weldParents)
&#9;for i, object in pairs(model:GetChildren()) do
&#9;&#9;if object.className == &quot;ManualWeld&quot; then if isInternalWeld(object, initialmodel) then table.insert(welds, object) table.insert(weldParents, object.Parent) object.Parent = nil end end
&#9;&#9;if object.GetChildren then storeAndRemoveWeldsInModel(initialmodel, object, welds, weldParents) end
&#9;end
end


local debris = game:GetService(&quot;Debris&quot;)
function flashRedBox(modelToFlash)
&#9;if not modelToFlash then return end 

&#9;errorBox.Parent = player.PlayerGui
&#9;errorBox.Adornee = modelToFlash

&#9;delay(0,function()
&#9;&#9;for i = 1, 3 do
&#9;&#9;&#9;errorBox.Visible = true
&#9;&#9;&#9;wait(0.13)
&#9;&#9;&#9;errorBox.Visible = false
&#9;&#9;&#9;wait(0.13)
&#9;&#9;end
&#9;&#9;errorBox.Adornee = nil
&#9;&#9;errorBox.Parent = Tool
&#9;end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)
&#9;if not cluster then return false end

&#9;local startCell = cluster:WorldToCell(startVector)
&#9;local endCell = cluster:WorldToCell(endVector)

&#9;local startX = startCell.X
&#9;local startY = startCell.Y
&#9;local startZ = startCell.Z

&#9;local endX = endCell.X
&#9;local endY = endCell.Y
&#9;local endZ = endCell.Z

&#9;if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
&#9;if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
&#9;if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

&#9;if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
&#9;if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
&#9;if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

&#9;for x = startX, endX do
&#9;&#9;for y = startY, endY do
&#9;&#9;&#9;for z = startZ, endZ do
&#9;&#9;&#9;&#9;if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return false
end


local debounce = false
function on3dButton1Up(mouse)
&#9;on3dMouseMove(mouse)
&#9;local modelToRotate = selectedModel -- so that other mouse events can&apos;t give us race conditions
&#9;if modelToRotate and not debounce then
&#9;&#9;debounce = true
&#9;&#9;-- get the model centroid
&#9;&#9;local minBB, maxBB = getBoundingBox2(modelToRotate)
&#9;&#9;local oldModelCentroid = (minBB + maxBB) / 2  -- point to rotate around

&#9;&#9;local diagVector = minBB - oldModelCentroid
&#9;&#9;local rotatedDiagVector = Vector3.new(diagVector.Z, diagVector.Y, diagVector.X)
&#9;&#9;local rotatedMinBB = oldModelCentroid + rotatedDiagVector
&#9;&#9;local rotatedMaxBB = oldModelCentroid - rotatedDiagVector

&#9;&#9;-- check if part rotation will cause collision
&#9;&#9;local fudgeVector = Vector3.new(0.4, 0.4, 0.4)  -- mmmmmm, fudge

&#9;&#9;-- we need to check the even/odd parity on the x and z axes of the model.  If there is a difference, then the rotation will push the model off-grid, so we will
&#9;&#9;&#9;--   need to adjust
&#9;&#9;local adjustVector = Vector3.new(0, 0, 0)
&#9;&#9;local diffVector = minBB - maxBB
&#9;&#9;local garbage, xParity = math.modf(math.modf(math.abs(diffVector.X)/4 + .5)/2)
&#9;&#9;local garbage, zParity = math.modf(math.modf(math.abs(diffVector.Z)/4 + .5)/2)
&#9;&#9;xParity = math.floor(xParity*2 + .5)
&#9;&#9;zParity = math.floor(zParity*2 + .5)
&#9;&#9;if xParity ~= zParity then
&#9;&#9;&#9;print(&quot;DIFFERENT PARITIES&quot;)
&#9;&#9;&#9;print(diffVector)
&#9;&#9;&#9;print(xParity)
&#9;&#9;&#9;print(zParity)
&#9;&#9;&#9;-- need to shift
&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, 2)
&#9;&#9;&#9;local mouseHitFrame = mouse.Hit
&#9;&#9;&#9;if mouseHitFrame then
&#9;&#9;&#9;&#9;local mouseHit = mouseHitFrame.p
&#9;&#9;&#9;&#9;if math.abs(diffVector.X) &gt; math.abs(diffVector.Z) then
&#9;&#9;&#9;&#9;&#9;-- longest axis is X-axis
&#9;&#9;&#9;&#9;&#9;if mouseHit.X &gt; oldModelCentroid.X then
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, 2)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(-2, 0, -2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;-- longest axis is Z-axis
&#9;&#9;&#9;&#9;&#9;if mouseHit.Z &gt; oldModelCentroid.Z then
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(-2, 0, 2)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;adjustVector = Vector3.new(2, 0, -2)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;print(&quot;SAME PARITIES!!&quot;)
&#9;&#9;end
&#9;&#9;-- below line checks CURRENT BB, not post-rotation BB
&#9;&#9;--local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB + fudgeVector, maxBB - fudgeVector), modelToRotate, 100)

&#9;&#9;-- if blocked by the cluster, then exit out
&#9;&#9;if cluster and clusterPartsInRegion(minBB + fudgeVector, maxBB - fudgeVector) then
&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;flashRedBox(modelToRotate)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(rotatedMinBB + fudgeVector + adjustVector, rotatedMaxBB - fudgeVector + adjustVector), modelToRotate, 100)

&#9;&#9;if #blockingParts &gt; 1 or (#blockingParts &gt; 0 and blockingParts[1] ~= modelToRotate) then
&#9;&#9;&#9;-- BLOCKED!!  MAKE ERROR NOISE!
&#9;&#9;&#9;print(&quot;Can&apos;t rotate now!  X&lt;&quot;)
&#9;&#9;&#9;for j = 1, #blockingParts do 
&#9;&#9;&#9;&#9;print(blockingParts[j]) 
&#9;&#9;&#9;&#9;if blockingParts[j].className ~= &quot;WedgePart&quot; and (blockingParts[j].Size / 2):Dot(blockingParts[j].Size / 2) &gt; 9 and blockingParts[j] ~= modelToRotate then
&#9;&#9;&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;&#9;&#9;flashRedBox(modelToRotate)
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;--else
&#9;&#9;end
&#9;&#9;&#9;-- do the rotation! :D
&#9;&#9;&#9;print(&quot;Rotating! :D&quot;)
&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, math.pi/2, 0)

&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveInstance(modelToRotate)
&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints()

&#9;&#9;
&#9;&#9;&#9;-- below simple script disabling/re-enabling works for all scripts in normal usabilityset except for elevators and retracting spike [see if just need to change &quot;Weld&quot; in spikescript to &quot;ManualWeld&quot;... may need to also make sure below script-table can store all descendent scripts of modelToRotate, and not just immediate children...]
&#9;&#9;&#9;&#9;-- and elevator scripts only break if you rotate when the elevator is in the &quot;fully down&quot; position...  probably just need some sort of check in ElevatorScript for this case

&#9;&#9;&#9;local scriptsToTurnBackOn = {}
&#9;&#9;&#9;storeAndDisableScriptsInModel(modelToRotate, scriptsToTurnBackOn)

&#9;&#9;&#9;local weldsToReturn = {}
&#9;&#9;&#9;local weldParentsToReturn = {}
&#9;&#9;&#9;storeAndRemoveWeldsInModel(modelToRotate, modelToRotate, weldsToReturn, weldParentsToReturn)

&#9;&#9;&#9;modelToRotate:BreakJoints()

&#9;&#9;&#9;if modelToRotate:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;for i, object in pairs(modelToRotate:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) then object.CFrame = rotCF * object.CFrame end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;modelToRotate.CFrame = rotCF * modelToRotate.CFrame
&#9;&#9;&#9;end

&#9;&#9;&#9;-- fix position so centroid remains in same place [and then move centroid by adjustVector so it stays on grid]
&#9;&#9;&#9;local newMinBB, newMaxBB = getBoundingBox2(modelToRotate)
&#9;&#9;&#9;local newModelCentroid = (newMinBB + newMaxBB) / 2
&#9;&#9;&#9;offsetPartsByVector3(modelToRotate, oldModelCentroid - newModelCentroid + adjustVector)

&#9;&#9;&#9;game.JointsService:CreateJoinAfterMoveJoints()
&#9;&#9;&#9;modelToRotate:MakeJoints()

&#9;&#9;&#9;-- return all manual welds
&#9;&#9;&#9;--print(#weldsToReturn)
&#9;&#9;&#9;for i = 1, #weldsToReturn do weldsToReturn[i].Parent = weldParentsToReturn[i] end

&#9;&#9;&#9;-- turn back on scripts
&#9;&#9;&#9;for i = 1, #scriptsToTurnBackOn do scriptsToTurnBackOn[i].Disabled = false end
&#9;&#9;--end

&#9;&#9;--[[ for debugging
&#9;&#9;local tempPart = Instance.new(&quot;Part&quot;)
&#9;&#9;tempPart.CanCollide = false
&#9;&#9;tempPart.Anchored = true
&#9;&#9;tempPart.Size = maxBB - minBB
&#9;&#9;tempPart.CFrame = CFrame.new((minBB + maxBB)/2)
&#9;&#9;tempPart.Parent = game.Workspace
&#9;&#9;game:GetService(&quot;Debris&quot;):AddItem(tempPart, .5) ]]--


&#9;&#9;debounce = false
&#9;end
end

function on3dMouseMove(mouse)
&#9;local mouseModel
&#9;if mouse.Target == nil then mouseModel = nil
&#9;else boolGarbage, mouseModel = isInRobloxModel(mouse.Target) end

&#9;if mouseModel == nil or (Tool.IsRestricted.Value and (not isInMyArea(mouseModel))) then mouseModel = nil end

&#9;-- see if need to switch selectionBox
&#9;if mouseModel ~= selectedModel then
&#9;&#9;selectedModel = mouseModel
&#9;&#9;selectionBox.Adornee = selectedModel
&#9;end
end

function canSelectObject(part)
&#9;if Tool.IsRestricted.Value then
&#9;&#9;waitForChild(playerArea,&quot;PlayerArea&quot;)
&#9;&#9;if playerArea:FindFirstChild(&quot;PlayerArea&quot;) and part:IsDescendantOf(playerArea.PlayerArea) then
&#9;&#9;&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
&#9;&#9;else
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function onEquippedLocal(mouse)
&#9;if game.Workspace:FindFirstChild(&quot;Terrain&quot;) then
&#9;&#9;cluster = game.Workspace.Terrain
&#9;end

&#9;local character = script.Parent.Parent
&#9;player = game.Players:GetPlayerFromCharacter(character)

&#9;if player == nil then return end

&#9;if Tool.IsRestricted.Value then
&#9;&#9;waitForChild(game.Workspace,&quot;BuildingAreas&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas,&quot;Area1&quot;)
&#9;&#9;waitForChild(game.Workspace.BuildingAreas.Area1,&quot;Player&quot;)
&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == player.Name then
&#9;&#9;&#9;&#9;playerArea = areas[i]
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if game.Workspace:FindFirstChild(&quot;BaseplateBumpers&quot;) then mouse.TargetFilter = game.Workspace.BaseplateBumpers end

&#9;mouse.Icon =&quot;rbxasset://textures\\DragCursor.png&quot;
&#9;mouse.Button1Down:connect(function() on3dButton1Down(mouse) end)
&#9;mouse.Button1Up:connect(function() on3dButton1Up(mouse) end)
&#9;mouse.Move:connect(function() on3dMouseMove(mouse) end)
&#9;
&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;MainSelectionBox&quot;
&#9;selectionBox.Color = BrickColor.Blue()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui;

&#9;on3dMouseMove(mouse) -- so if they unequip/reequip, they still have selection box
end

function onUnequippedLocal()
&#9;if selectionBox then selectionBox:Remove() end
&#9;selectedModel = nil
&#9;player = nil
end


Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)

</ProtectedString>
				</Properties>
			</Item>
			<Item class="BoolValue" referent="RBX33">
				<Properties>
					<string name="Name">IsRestricted</string>
					<bool name="Value">false</bool>
				</Properties>
			</Item>
			<Item class="SelectionBox" referent="RBX34">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">21</int>
					<string name="Name">ErrorBox</string>
					<float name="Transparency">0</float>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
		</Item>
		<Item class="Tool" referent="RBX35">
			<Properties>
				<bool name="CanBeDropped">true</bool>
				<bool name="Enabled">true</bool>
				<CoordinateFrame name="Grip">
					<X>0</X>
					<Y>0</Y>
					<Z>0.349999994</Z>
					<R00>1</R00>
					<R01>0</R01>
					<R02>0</R02>
					<R10>0</R10>
					<R11>1</R11>
					<R12>0</R12>
					<R20>0</R20>
					<R21>0</R21>
					<R22>1</R22>
				</CoordinateFrame>
				<string name="Name">StamperTool</string>
				<Content name="TextureId"><url>http://www.pengin.xyz/asset/?id=59102781</url></Content>
				<string name="ToolTip"></string>
			</Properties>
			<Item class="ObjectValue" referent="RBX36">
				<Properties>
					<string name="Name">PlayerOwner</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="SelectionBox" referent="RBX37">
				<Properties>
					<Ref name="Adornee">null</Ref>
					<int name="Color">21</int>
					<string name="Name">ErrorBox</string>
					<float name="Transparency">0</float>
					<bool name="Visible">false</bool>
				</Properties>
			</Item>
			<Item class="ObjectValue" referent="RBX38">
				<Properties>
					<string name="Name">SavedState</string>
					<Ref name="Value">null</Ref>
				</Properties>
			</Item>
			<Item class="Script" referent="RBX39">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Script</string>
					<ProtectedString name="Source">if script.Parent.Parent.Parent.Name == &quot;Skampus&quot; then
&#9;script.Parent:Remove()
end

</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX40">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">BasePlateGuide</string>
					<ProtectedString name="Source">local pointDirection = nil

local tailLength = 2 -- 2 or 7
--local dSize = -.05  -- .01 or .005
local dSize = 0 -- because we want the targets to all be the same size (tail isn&apos;t larger anymore; just &quot;ghost&quot; effect)
local dTime = .04 --.025

-- old targetLock pic (square): 48972746

local targetLockSize = .2
local arrowSize = .1

local arrowScreenProportionSize = .95
local arrowMoveFactor = .025

local targetMoveFactor = targetLockSize / 2 - .025

local halfDSize = dSize / 2

local r = game:service(&quot;RunService&quot;)

local vChar = script.Parent
if vChar == nil then script.Parent = nil end

local vPlay = game.Players:GetPlayerFromCharacter(vChar)
if vPlay == nil then script.Parent = nil end

local arrowGui = vPlay.PlayerGui:FindFirstChild(&quot;GuideArrowGui&quot;)
if arrowGui == nil then
&#9;arrowGui = script.GuideArrowGui
&#9;arrowGui.Parent = vPlay.PlayerGui
else
&#9;script.GuideArrowGui:remove()
end

local upArrow = arrowGui.UpArrow
local downArrow = arrowGui.DownArrow
local leftArrow = arrowGui.LeftArrow
local rightArrow = arrowGui.RightArrow
local targetLock = arrowGui.TargetLock
local arrowList = {upArrow, downArrow, leftArrow, rightArrow, targetLock}

local goAway = arrowGui.GoAwayButton
goAway.Visible = true
goAway.Active = true
local keepShowing = true
goAway.MouseButton1Click:connect(function () keepShowing = false end)


local arrowHeightAugment = 0.0
local arrowWidthAugment = 0.0
local targetHeightAugment = 0.0
local targetWidthAugment = 0.0


local targetLockList = {targetLock}
for i = 1, tailLength do table.insert(targetLockList, targetLock:Clone()) end

targetLockList[1].Size = UDim2.new(targetLockSize, 0, targetLockSize, 0)
for i = 1, #targetLockList-1 do
&#9;targetLockList[i+1].Parent = arrowGui
&#9;--targetLockList[i+1].Size = UDim2.new(targetLockSize-i*dSize, 0, targetLockSize-i*dSize, 0)
end
-- switching over to a &quot;ghost-like&quot; transparency effect, but this means we have to upload separate images :(
-- if our tail is turned on, manually apply the ghosting to the next two images
if tailLength &gt; 0 then targetLockList[2].Image = &quot;http://www.pengin.xyz/asset/?id=49324811&quot; end
if tailLength &gt; 1 then targetLockList[3].Image = &quot;http://www.pengin.xyz/asset/?id=49324846&quot; end


function onResize() -- force arrows into a square resolution
&#9;xSize = arrowGui.AbsoluteSize.X
&#9;ySize = arrowGui.AbsoluteSize.Y

&#9;if xSize &gt;= ySize then
&#9;&#9;arrowHeightAugment = 0.0

&#9;&#9;-- calculate arrowWidthAugment and new arrow ratio here
&#9;&#9;newArrowUDim = UDim2.new(ySize / xSize * arrowSize, 0, arrowSize, 0)
&#9;&#9;rightArrow.Size = newArrowUDim 
&#9;&#9;leftArrow.Size = newArrowUDim 
&#9;&#9;upArrow.Size = newArrowUDim 
&#9;&#9;downArrow.Size = newArrowUDim

&#9;&#9;for tli = 1, #targetLockList do
&#9;&#9;&#9;targetLockList[tli].Size = UDim2.new(ySize / xSize * (targetLockSize-tli*dSize), 0, targetLockSize-tli*dSize, 0)
&#9;&#9;end

&#9;&#9;arrowWidthAugment = (xSize - ySize)*arrowSize*.5 / xSize
&#9;else
&#9;&#9;arrowWidthAugment = 0.0

&#9;&#9;-- calculate arrowHeightAugment here
&#9;&#9;newArrowUDim = UDim2.new(arrowSize, 0, xSize / ySize * arrowSize, 0)
&#9;&#9;rightArrow.Size = newArrowUDim
&#9;&#9;leftArrow.Size = newArrowUDim
&#9;&#9;upArrow.Size = newArrowUDim
&#9;&#9;downArrow.Size = newArrowUDim

&#9;&#9;for tli = 1, #targetLockList do
&#9;&#9;&#9;targetLockList[tli].Size = UDim2.new(targetLockSize-tli*dSize, 0, xSize / ySize * (targetLockSize-tli*dSize), 0)
&#9;&#9;end

&#9;&#9;arrowHeightAugment = (ySize - xSize)*arrowSize*.5 / ySize
&#9;end

&#9;targetWidthAugment = targetLock.Size.X.Scale / 2 - .025
&#9;targetHeightAugment = targetLock.Size.Y.Scale / 2 - .025
end

arrowGui.Changed:connect(onResize) -- dynamically resize the arrows on screen resize

function findMyBasePlate()
&#9;--if true then return game.Workspace.Base end -- for testing purposes

&#9;local buildingAreas = game.Workspace.BuildingAreas:GetChildren()
&#9;for i = 1, #buildingAreas do
&#9;&#9;if buildingAreas[i].Player.Value == script.Parent.Name then
&#9;&#9;&#9;return buildingAreas[i]:FindFirstChild(&quot;BasePlate&quot;) or buildingAreas[i].PlayerArea:FindFirstChild(&quot;BasePlate&quot;)
&#9;&#9;end
&#9;end
end

local myBase = findMyBasePlate()
if myBase == nil then
&#9;print(&quot;BasePlateGuide script error: no base plate found!&quot;)
&#9;-- abort if no BasePlate found
&#9;arrowGui:remove()
&#9;script:remove()
end

function setVisible(whichArrow)
&#9;for i = 1, #arrowList do
&#9;&#9;if arrowList[i] == whichArrow then
&#9;&#9;&#9;arrowList[i].Visible = true
&#9;&#9;else
&#9;&#9;&#9;arrowList[i].Visible = false
&#9;&#9;end
&#9;end
end

function truncate(number, augmentation)
&#9;if number+augmentation &lt; 0 then return 0 
   elseif number &gt; (1 - arrowSize)+augmentation then return (1 - arrowSize)+2*augmentation -- furthest extent we want the arrows to reach is .95 - arrowSize
&#9;else return number+augmentation end
end


function notInBasePlate(myPos, base)
&#9;local corner1 = base.Position - base.Size/2
&#9;local corner2 = base.Position + base.Size/2
&#9;if myPos.X &gt; corner1.X and myPos.Y &gt; corner1.Y and myPos.Z &gt; corner1.Z and myPos.X &lt; corner2.X and myPos.Z &lt; corner2.Z then -- we only care they&apos;re somewhere above baseplate
&#9;&#9;return false
&#9;else
&#9;&#9;return true
&#9;end
end

local lastTime = 0
local camera = game.Workspace.CurrentCamera
while notInBasePlate(script.Parent.Torso.Position, myBase) and keepShowing do
&#9;--pointDirection = (myBase.Position - script.Parent.Torso.Position) * Vector3.new(1, 0, 1)
&#9;camFrame = camera.CoordinateFrame
&#9;pointDirection = camFrame:vectorToObjectSpace(myBase.Position - camFrame.p)
&#9;camZ = pointDirection.Z
&#9;camX = pointDirection.X/math.abs(camZ)
&#9;camY = pointDirection.Y/math.abs(camZ)
&#9;--print(camX, camY, camZ)

&#9;-- was .55 for 610 (Y) and 1.15 for 1286 (X), so seems like scaling factor is universally 1114 on both axes&#9;
&#9;-- nvm:  at 1662 x 666, we have ... and .55, so seems like .55 always for Y, then X is scaled according to its proportion to Y

&#9;local xThreshold = arrowGui.AbsoluteSize.X / arrowGui.AbsoluteSize.Y * .55
&#9;local yThreshold = .55

&#9;local nCamX = camX / xThreshold
&#9;local nCamY = camY / yThreshold

&#9;if (math.abs(nCamX) &gt; 1 or math.abs(nCamY) &gt; 1) or (camZ &gt; 0) then -- camZ test makes sure we only lock on if facing right direction
&#9;&#9;for j = 2, #targetLockList do
&#9;&#9;&#9;targetLockList[j].Visible = false
&#9;&#9;end
&#9;
&#9;&#9;if math.abs(nCamX) &gt; math.abs(nCamY) then
&#9;&#9;&#9;--if nCamY &gt; 1 then nCamY = 1
&#9;&#9;&#9;--elseif nCamY &lt; -1 then nCamY = -1 end

&#9;&#9;&#9;if camX &gt; 0 then
&#9;&#9;&#9;&#9;-- should go right
&#9;&#9;&#9;&#9;rightArrow.Position = UDim2.new(arrowScreenProportionSize - arrowMoveFactor - .025 + 2*arrowWidthAugment, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
&#9;&#9;&#9;&#9;setVisible(rightArrow)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;-- should go left
&#9;&#9;&#9;&#9;leftArrow.Position = UDim2.new(0, 0, truncate(arrowScreenProportionSize*(1-nCamY)/2 - arrowMoveFactor, arrowHeightAugment), 0)
&#9;&#9;&#9;&#9;setVisible(leftArrow)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;--if nCamX &gt; 1 then nCamX = 1
&#9;&#9;&#9;--elseif nCamX &lt; -1 then nCamX = -1 end

&#9;&#9;&#9;if camY &gt; 0 then
&#9;&#9;&#9;&#9;-- should go up
&#9;&#9;&#9;&#9;upArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, 0, 0)
&#9;&#9;&#9;&#9;setVisible(upArrow)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;-- should go down
&#9;&#9;&#9;&#9;downArrow.Position = UDim2.new(truncate(arrowScreenProportionSize*(nCamX+1)/2 - arrowMoveFactor, arrowWidthAugment), 0, arrowScreenProportionSize - arrowMoveFactor -.025 + 2*arrowHeightAugment, 0)
&#9;&#9;&#9;&#9;setVisible(downArrow)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;-- locked on target
&#9;&#9;--for j = 2, #targetLockList do
&#9;&#9;&#9;--targetLockList[j].Visible = true
&#9;&#9;--end
&#9;&#9;--targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetMoveFactor, 0, .95*(1-nCamY)/2 - targetMoveFactor, 0)
&#9;&#9;targetLock.Position = UDim2.new(.95*(nCamX+1)/2 - targetWidthAugment, 0, .95*(1-nCamY)/2 - targetHeightAugment, 0)
&#9;&#9;setVisible(targetLock)
&#9;end

&#9;--wait()
&#9;
&#9;-- update every dTime seconds

&#9;-- ok to do it this way instead of a ring array, because even though it&apos;s less efficient, it&apos;s less efficient by only one or two commands [since only have 2 &quot;tails&quot;]

&#9;local t = r.Stepped:wait()
&#9;if t - lastTime &gt; dTime then
&#9;&#9;lastTime = t
&#9;&#9;for j = #targetLockList, 2, -1 do
&#9;&#9;&#9;targetLockList[j].Position = targetLockList[j-1].Position + UDim2.new(halfDSize, 0, halfDSize, 0)
&#9;&#9;&#9;targetLockList[j].Visible = targetLockList[j-1].Visible
&#9;&#9;end
&#9;end
end

--[[setVisible(nil)
for j = 2, #targetLockList do
&#9;targetLockList[j].Visible = false
end
goAway.Visible = false
goAway.Active = false
]]--
arrowGui:remove()
script:remove()</ProtectedString>
				</Properties>
				<Item class="ScreenGui" referent="RBX41">
					<Properties>
						<string name="Name">GuideArrowGui</string>
					</Properties>
					<Item class="ImageLabel" referent="RBX42">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.pengin.xyz/asset/?id=48972729 </url></Content>
							<string name="Name">UpArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX43">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.pengin.xyz/asset/?id=48972703</url></Content>
							<string name="Name">RightArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX44">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.pengin.xyz/asset/?id=48972653</url></Content>
							<string name="Name">DownArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX45">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.pengin.xyz/asset/?id=48972682</url></Content>
							<string name="Name">LeftArrow</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBX46">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>http://www.pengin.xyz/asset/?id=49321779</url></Content>
							<string name="Name">TargetLock</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.0500000007</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX47">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4278255360</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">0</token>
							<bool name="Modal">false</bool>
							<string name="Name">GoAwayButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>20</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>150</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Hide Guide Arrows</string>
							<Color3 name="TextColor3">4279970357</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBX48">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">GuiScript</string>
					<ProtectedString name="Source">-- This script is responsible for working the gui

-- basic functions
function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForProperty(instance, name)
&#9;while not instance[name] do
&#9;&#9;instance.Changed:wait()
&#9;end
end


-- Locals
local Tool = script.Parent

waitForChild(Tool, &quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables, &quot;InsertAsset&quot;)
local insertAsset = variables.InsertAsset
waitForChild(variables, &quot;SwitchMode&quot;)
local switchMode = variables.SwitchMode
waitForChild(variables, &quot;ShowAdminCategories&quot;)
local showAdminCategories = variables.ShowAdminCategories

waitForChild(variables, &quot;ReloadCurrentAsset&quot;)
waitForChild(variables,&quot;userIDs&quot;)

game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.pengin.xyz/asset/?id=42163425&quot;)
game:GetService(&quot;ContentProvider&quot;):Preload(&quot;http://www.pengin.xyz/asset/?id=42563487&quot;)

local BaseUrl = game:GetService(&quot;ContentProvider&quot;).BaseUrl

local buttonHeight = 64
local buttonWidth = buttonHeight

local waypointShowing = false
local showingPartPicker = true
local firstEquip = true

local Window
local Data
local loading = false

local startTime = 0

local SetCache = {}

local lastEnter = nil

-- For Restricting Stamper Tool
local buildingPlate
local partModel

-- wait for all of our set ids to load
local userIdsForStamperParts = variables.userIDs -- 7502714 This is UsabilityMan (on gametest)

function giveNewUserId(id)
&#9;local newUserId = Instance.new(&quot;IntValue&quot;)
&#9;newUserId.Name = &quot;userID&quot;
&#9;newUserId.Value = id
&#9;newUserId.Parent = userIdsForStamperParts
&#9;userIdsForStamperParts.Value = userIdsForStamperParts.Value + 1
end

BaseUrl = BaseUrl:lower()

local isRestricted = Instance.new(&quot;BoolValue&quot;)
isRestricted.Name = &quot;IsRestricted&quot;
isRestricted.Value = false

function isLocalWTRB()
&#9;waitForChild(game,&quot;StarterGui&quot;)
&#9;if game.StarterGui:FindFirstChild(&quot;VersionGui&quot;) then
&#9;&#9;if game.StarterGui.VersionGui:FindFirstChild(&quot;VersionText&quot;, true) then
&#9;&#9;&#9;return true
&#9;&#9;end
&#9;end
&#9;return false
end

waitForProperty(game,&quot;PlaceId&quot;)
if game.PlaceId == 41324860 or isLocalWTRB() then
&#9;isRestricted.Value = true
end
isRestricted.Parent = variables

--giveNewUserId(18881789)
--giveNewUserId(18881808)
--giveNewUserId(18881829)
--giveNewUserId(18881853)
--giveNewUserId(18881866)
--giveNewUserId(2409156)
--giveNewUserId(19238067)
--giveNewUserId(19238114)
--giveNewUserId(2409156)
--giveNewUserId(19238067)
--giveNewUserId(19238114)
giveNewUserId(11744447)
giveNewUserId(18881789)
giveNewUserId(19238114)


while #userIdsForStamperParts:GetChildren() &lt; userIdsForStamperParts.Value do userIdsForStamperParts.ChildAdded:wait() end
userIdsForStamperParts = userIdsForStamperParts:GetChildren()

local useAssetVersionId = false
local LargeThumbnailUrl
local SmallThumbnailUrl

local InsertRows = 0
local InsertColumns = 0
local insertButtons = {}

local CancelDuringLoad

local prevPart = {AssetNameValue = &quot;&quot;,AssetIdValue = 0 ,InsertFrameButtonImage = &quot;&quot;}
local recentPartStack = {}

-- Connection Managers
local guiChangedCon = nil
local cloneButtonCon = nil
local partListClickCon = nil
local itemFrameChangedCon = nil
local setsNextPageCon = nil
local setsPrevPageCon = nil
local insertPanelCloseCon = nil
local minimizeCon = nil
local restoreCon = nil
local setButtonCons = {}
local insertButtonCons = {}
local recentPartStackCons = {}

local Mouse = nil
local currSetPage = 1

local mode = 0 -- 0 = main dialog, 1 = stamper, 2 = eyedropper

waitForChild(script.Parent,&quot;StampGUI&quot;)
local stamperGui = script.Parent.StampGUI
waitForChild(stamperGui,&quot;InsertPanel&quot;)
waitForChild(stamperGui.InsertPanel, &quot;CancelButton&quot;)
local currStampGui = nil

local maxRecentParts = 4
for i = 1, maxRecentParts do
&#9;recentPartStack[i] = {AssetNameValue,AssetIdValue,InsertFrameButtonImage}
&#9;recentPartStack[i].AssetNameValue = &quot;&quot;
&#9;recentPartStack[i].AssetIdValue = &quot;&quot;
&#9;recentPartStack[i].InsertFrameButtonImage = &quot;&quot;
end
----------------------------------------------------------------------------------------


-- functions
function showBaseplateGuideArrows()
&#9;playerCharacter = Tool.Parent
&#9;if playerCharacter:FindFirstChild(&quot;Humanoid&quot;) and not playerCharacter:FindFirstChild(&quot;BasePlateGuide&quot;) then
&#9;&#9;newGuide = Tool.BasePlateGuide:Clone()
&#9;&#9;newGuide.Parent = playerCharacter
&#9;&#9;newGuide.Disabled = false
&#9;end
end

function setAssetUrls()
&#9;if useAssetVersionId then
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;assetversionid=&quot;
&#9;else
&#9;&#9;LargeThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;aid=&quot;
&#9;&#9;SmallThumbnailUrl = BaseUrl .. &quot;Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=&quot;
&#9;end
end

function signalSwitchMode(mode)
&#9;switchMode.Mode.Value = mode
&#9;switchMode.Value = true
end

function goToClone()
&#9;cancelLoadingWindow()
&#9;closeInsertPanel()
&#9;cancelAssetPlacement()

&#9;mode = 2
&#9;--signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)
&#9;signalSwitchMode(&quot;Clone&quot;)

&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = true
&#9;currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = true
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, -88, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = true end)
&#9;end
end

function goToStamp()
&#9;mode = 1
&#9;cancelLoadingWindow()
&#9;closeInsertPanel()
&#9;closeClonePanel()
end

function goToInsertPanel()
&#9;cancelLoadingWindow()
&#9;closeClonePanel()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
&#9;currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = true

&#9;if not showingPartPicker then
&#9;&#9;showingPartPicker = true
&#9;&#9;if currStampGui.Parent ~= nil then
&#9;&#9;&#9;currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 0.1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;end
&#9;else
&#9;&#9;closeInsertPanel()
&#9;&#9;reloadCurrentAsset()
&#9;end
end

function closeInsertPanel()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = false end)
&#9;currStampGui.StamperPanel.StamperButtons.PartsButton.Selected = false

&#9;showingPartPicker = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.InsertPanel:TweenPosition(UDim2.new(0.2, 2, 1, 24),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;end
end

function closeClonePanel()
&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel.ClonePanelText.Visible = false
&#9;currStampGui.StamperPanel.StamperButtons.CloneButton.Selected = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel.StamperButtons.ClonePanel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.35,true)
&#9;&#9;delay(0.3,function() currStampGui.StamperPanel.StamperButtons.ClonePanel.Visible = false end)
&#9;end
end

function cancelAssetPlacement()
&#9;gInitial90DegreeRotations = 0
&#9;Data.Stamp.Cancelled = true
&#9;Data.Stamp.Dragger = nil
&#9;if Data.Stamp.Model then
&#9;&#9;Data.Stamp.Model:Remove()
&#9;&#9;Data.Stamp.Model = nil
&#9;end
&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object:Remove()
&#9;&#9;end
&#9;&#9;Data.Stamp.CurrentParts = nil
&#9;end

&#9;if Mouse then
&#9;&#9;Mouse.Icon =&quot;rbxasset://textures\\ArrowCursor.png&quot;
&#9;end
&#9;game.JointsService:ClearJoinAfterMoveJoints()

end

function hint(label)

&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end

end

function getPlayer()
&#9;return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function getHumanoid()
&#9;local player = game.Players:GetPlayerFromCharacter(script.Parent.Parent)
&#9;if player then
&#9;&#9;waitForProperty(player,&quot;Character&quot;)
&#9;&#9;waitForChild(player.Character,&quot;Humanoid&quot;)
&#9;&#9;return player.Character.Humanoid
&#9;else
&#9;&#9;return nil
&#9;end
end

function buildSetButton(name, setId, setImageId, i,  count)

&#9;local button = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample:Clone()
&#9;button.Text = name
&#9;button.Name = &quot;SetButton&quot;
&#9;button.Visible = true

&#9;local setValue = Instance.new(&quot;IntValue&quot;)
&#9;setValue.Name = &quot;SetId&quot;
&#9;setValue.Value = setId
&#9;setValue.Parent = button

&#9;local setName = Instance.new(&quot;StringValue&quot;)
&#9;setName.Name = &quot;SetName&quot;
&#9;setName.Value = name
&#9;setName.Parent = button

&#9;return button
end


function previousSetPage()
&#9;local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index - (InsertRows * InsertColumns))
&#9;setSetIndex(newIndex)
end


function nextSetPage()
&#9;local newIndex = math.max(0, Data.Category[Data.CurrentCategory].Index + (InsertRows * InsertColumns))
&#9;setSetIndex(newIndex)
end

function setInsertButtonImageBehavior(insertFrame, visible, name, assetId)
&#9;if visible then
&#9;&#9;insertFrame.AssetName.Value = name
&#9;&#9;insertFrame.AssetId.Value = assetId
&#9;&#9;local newImageUrl = SmallThumbnailUrl  .. assetId
&#9;&#9;if newImageUrl ~= insertFrame.Button.ButtonImage.Image then
&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(SmallThumbnailUrl  .. assetId)
&#9;&#9;&#9;&#9;insertFrame.Button.ButtonImage.Image = SmallThumbnailUrl  .. assetId
&#9;&#9;&#9;end)
&#9;&#9;end
&#9;&#9;table.insert(insertButtonCons,
&#9;&#9;&#9;insertFrame.Button.MouseButton1Click:connect(function()
&#9;&#9;&#9;&#9;beginInsertAssetGui(insertFrame.AssetName.Value, insertFrame.AssetId.Value, insertFrame.Button.ButtonImage.Image, 1)
&#9;&#9;&#9;end)
&#9;&#9;)
&#9;&#9;insertFrame.Visible = true
&#9;else
&#9;&#9;insertFrame.Visible = false
&#9;end
end

function setSetIndex(dataOffset)

&#9;Data.Category[Data.CurrentCategory].Index = dataOffset

&#9;InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;local PageSize = InsertRows * InsertColumns
&#9;local contents = Data.Category[Data.CurrentCategory].Contents
&#9;if contents then
&#9;&#9;
&#9;&#9;local numOfPages = math.ceil((#contents)/(PageSize))
&#9;&#9;local currPage = math.ceil((dataOffset/PageSize) + 1)
&#9;&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currPage) .. &quot;/&quot; .. tostring(numOfPages)
&#9;&#9;currStampGui.InsertPanel.PagingControls.PageText.Visible = (numOfPages &gt; 1)

      currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = (numOfPages &gt; 1) and dataOffset &gt; 1
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = (numOfPages &gt; 1) and ((dataOffset - 1) + PageSize) &lt; (#contents)

&#9;&#9;-- remove our buttons and their connections
&#9;&#9;for i = 1, #insertButtons do
&#9;&#9;&#9;insertButtons[i]:remove()
&#9;&#9;end
&#9;&#9;for i = 1, #insertButtonCons do
&#9;&#9;&#9;pcall(function() insertButtonCons[i]:disconnect() end)
&#9;&#9;end

&#9;&#9;insertButtonCons = {}
&#9;&#9;insertButtons = {}
&#9;&#9;local arrayPosition = 1
&#9;&#9;for y = 1, InsertRows do
&#9;&#9;&#9;for x = 1, InsertColumns do
&#9;&#9;&#9;&#9;local buttonPosition = UDim2.new(0,(buttonWidth)*(x-1),0, (buttonHeight)*(y-1))

&#9;&#9;&#9;&#9;local buttonCon
&#9;&#9;&#9;&#9;insertButtons[arrayPosition], buttonCon = buildInsertButton(buttonPosition)
&#9;&#9;&#9;&#9;table.insert(insertButtonCons,buttonCon)
&#9;&#9;&#9;&#9;insertButtons[arrayPosition].Parent = currStampGui.InsertPanel.ItemsFrame
&#9;&#9;&#9;&#9;arrayPosition = arrayPosition + 1
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;Data.InsertButtons = insertButtons

&#9;&#9;for index = 1, PageSize do
&#9;&#9;&#9;if insertButtons[index] then
&#9;&#9;&#9;&#9;if contents[index + dataOffset] then
&#9;&#9;&#9;&#9;&#9;local assetId
&#9;&#9;&#9;&#9;&#9;if useAssetVersionId then
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index + dataOffset].AssetVersionId
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;assetId = contents[index + dataOffset].AssetId
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], true, contents[index + dataOffset].Name, assetId)
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;setInsertButtonImageBehavior(insertButtons[index], false)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
&#9;end

end

function moveLoadingLeft()
&#9;if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
&#9;&#9;loading = false
&#9;&#9;cancelAssetPlacement()
&#9;&#9;goToInsertPanel()
&#9;end
&#9;if loading then
&#9;&#9;currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 0, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingRight() end)
&#9;end
end

function moveLoadingRight()
&#9;if (tick() - startTime &gt; 5) and (currStampGui.Parent ~= nil) then
&#9;&#9;loading = false
&#9;&#9;cancelAssetPlacement()
&#9;&#9;goToInsertPanel()
&#9;end
&#9;if loading then
&#9;&#9;currStampGui.LoadDialog.LoadLabel:TweenPosition(UDim2.new(0, 180, 0, -8),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.7,true,function() moveLoadingLeft() end)
&#9;end
end

function moveLoadingWindow()
&#9;startTime = tick()
&#9;currStampGui.LoadDialog.Visible = true
&#9;loading = true
&#9;moveLoadingRight()
end

function cancelLoadingWindow()
&#9;currStampGui.LoadDialog.Visible = false
&#9;loading = false
end


function selectCategoryPage(buttons, page)

&#9;if buttons ~= Data.CurrentCategory then
&#9;&#9;if Data.CurrentCategory then
&#9;&#9;&#9;for key, button in pairs(Data.CurrentCategory) do
&#9;&#9;&#9;&#9;button.Visible = false
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;Data.CurrentCategory = buttons
&#9;&#9;if Data.Category[Data.CurrentCategory] == nil then
&#9;&#9;&#9;Data.Category[Data.CurrentCategory] = {}
&#9;&#9;&#9;if #buttons &gt; 0 then
&#9;&#9;&#9;&#9;selectSet(buttons[1], buttons[1].SetName.Value, buttons[1].SetId.Value, 0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = nil
&#9;&#9;&#9;selectSet(Data.Category[Data.CurrentCategory].ButtonFrame, Data.Category[Data.CurrentCategory].SetName, Data.Category[Data.CurrentCategory].SetId, Data.Category[Data.CurrentCategory].Index)
&#9;&#9;end
&#9;&#9;if Data.Main.FrameHeight then
&#9;&#9;&#9;if Data.Category[Data.CurrentCategory].SetIndex then
&#9;&#9;&#9;&#9;layoutSetButtons(Data.Main.FrameHeight, Data.Category[Data.CurrentCategory].SetIndex)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;layoutSetButtons(Data.Main.FrameHeight, 1)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

end

function selectSet(button, setName, setId, setIndex)

&#9;if button and Data.Category[Data.CurrentCategory] ~= nil then
&#9;&#9;if button ~= Data.Category[Data.CurrentCategory].Button then
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Button = button

&#9;&#9;&#9;if SetCache[setId] == nil then
&#9;&#9;&#9;&#9;SetCache[setId] = game:GetService(&quot;InsertService&quot;):GetCollection(setId)
&#9;&#9;&#9;end
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].Contents = SetCache[setId]

&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetName = setName
&#9;&#9;&#9;Data.Category[Data.CurrentCategory].SetId = setId
&#9;&#9;end
&#9;&#9;setSetIndex(setIndex)
&#9;end

end


function selectCategory(button, category)
&#9;selectCategoryPage(category, 0)
end


function processCategory(sets, setPanel)
&#9;local setButtons = {}
&#9;local numSkipped = 0
&#9;for index, object in pairs(sets) do
&#9;&#9;if not showAdminCategories.Value and object.Name == &quot;Beta&quot; then
&#9;&#9;&#9;-- skip this if not an admin
&#9;&#9;&#9;numSkipped = numSkipped + 1
&#9;&#9;else
&#9;&#9;&#9;setButtons[index - numSkipped] = buildSetButton(object.Name, object.CategoryId, object.ImageAssetId, index - numSkipped, #sets)
&#9;&#9;&#9;setButtons[index - numSkipped].Parent = setPanel
&#9;&#9;end
&#9;end
&#9;return setButtons
end


function setsNextPageClick(totalSetPages, gridSize)
&#9;-- set our logic/gui correctly
&#9;if currSetPage &gt;= totalSetPages then return end

&#9;currSetPage = currSetPage + 1
&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
&#9;if currSetPage == totalSetPages then
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = false
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
&#9;else
&#9;&#9;Window.Sets.PagingControls.NextPageButton.Visible = true
&#9;end
&#9;
&#9;-- actually update the items
&#9;makeCurrentSetsPageVisible(gridSize)
end

function setsPrevPageClick(totalSetPages, gridSize)
&#9;-- set our logic/gui correctly
&#9;if currSetPage &lt;= 1 then return end

&#9;currSetPage = currSetPage - 1
&#9;currStampGui.InsertPanel.PagingControls.PageText.Text = tostring(currSetPage) .. &quot;/&quot; .. tostring(totalSetPages)
&#9;if currSetPage == 1 then
&#9;&#9;currStampGui.InsertPanel.PagingControls.NextPageButton.Visible = true
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = false
&#9;else
&#9;&#9;currStampGui.InsertPanel.PagingControls.PreviousPageButton.Visible = true
&#9;end

&#9;-- actually update the items
&#9;makeCurrentSetsPageVisible(gridSize)
end

function resetAllSetButtonSelection()
&#9;local setButtons = Window.Sets.SetsLists:GetChildren()
&#9;for i = 1, #setButtons do
&#9;&#9;setButtons[i].Selected = false
&#9;&#9;setButtons[i].BackgroundTransparency = 1
&#9;&#9;setButtons[i].TextColor3 = Color3.new(1,1,1)
&#9;&#9;setButtons[i].BackgroundColor3 = Color3.new(1,1,1)
&#9;end
end

function populateSetsFrame()
&#9;local categories = #Data.UserCategoryButtons
&#9;local robloxMaxCat = categories
&#9;
&#9;-- don&apos;t do anything until window is visible (otherwise we won&apos;t layout anything!)
&#9;while Window.Sets.SetsLists.AbsoluteSize.X &lt;= 0 do
&#9;&#9;Window.Sets.SetsLists.Changed:wait()
&#9;end
&#9;while Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X &lt;= 0 do
&#9;&#9;Window.Sets.SetsLists.SetButtonExample.Changed:wait()
&#9;end

&#9;local totalColumns = math.floor(Window.Sets.SetsLists.AbsoluteSize.X/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.X)
&#9;local totalRows = math.floor(Window.Sets.SetsLists.AbsoluteSize.Y/Window.Sets.SetsLists.SetButtonExample.AbsoluteSize.Y)
&#9;
&#9;local currRow = 0
&#9;local buttonVisible = true

&#9;local masterCategory = 1
&#9;for i = 1, categories do
&#9;&#9;local userCategory = masterCategory -- needed to maintain local scope for categories in event listeners below
&#9;&#9;local button = Window.Sets.SetsLists.SetButtonExample:clone()

&#9;&#9;button.Name = &quot;Set&quot; .. tostring(Data.UserCategoryButtons[userCategory].SetName.Value) .. &quot;Button&quot;
&#9;&#9;button.Parent = Window.Sets.SetsLists
&#9;&#9;button.Position = UDim2.new(0,5,0,currRow * button.AbsoluteSize.Y)
&#9;&#9;button.Visible = buttonVisible
&#9;&#9;button.Text =  tostring(Data.UserCategoryButtons[userCategory].SetName.Value)

&#9;&#9;if i == 1 then
&#9;&#9;&#9;button.Selected = true
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;end

&#9;&#9;button.MouseEnter:connect(function()
&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 0
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;button.MouseLeave:connect(function()
&#9;&#9;&#9;if not button.Selected then
&#9;&#9;&#9;&#9;button.BackgroundTransparency = 1
&#9;&#9;&#9;&#9;button.TextColor3 = Color3.new(1,1,1)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;&#9;setButtonCons[i] = button.MouseButton1Click:connect(function()
&#9;&#9;&#9;resetAllSetButtonSelection()
&#9;&#9;&#9;button.Selected = not button.Selected
&#9;&#9;&#9;button.BackgroundColor3 = Color3.new(0,204/255,0)
&#9;&#9;&#9;button.TextColor3 = Color3.new(0,0,0)
&#9;&#9;&#9;button.BackgroundTransparency = 0

&#9;&#9;&#9;selectSet(button, button.Text, Data.UserCategoryButtons[userCategory].SetId.Value, 0)
&#9;&#9;end)
&#9;&#9;
&#9;&#9;masterCategory = masterCategory + 1

&#9;&#9;currRow = currRow + 1
&#9;end
&#9;
&#9;-- don&apos;t use example button as the first set!
&#9;local example = currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample
&#9;currStampGui.InsertPanel.Sets.SetsLists.SetButtonExample.Parent = nil
&#9;local buttons =  currStampGui.InsertPanel.Sets.SetsLists:GetChildren()
&#9;example.Parent = currStampGui.InsertPanel.Sets.SetsLists

&#9;-- set first category as loaded for default
&#9;selectSet(buttons[1], buttons[1].Text, Data.UserCategoryButtons[1].SetId.Value, 0)
&#9;selectCategory(buttons[1], Data.UserCategoryButtons)
end


function layoutSetButtons(frameHeight, setIndex)
&#9;Data.Main.FrameHeight = frameHeight
&#9;Data.Main.InsertSets = math.floor(frameHeight / (height*2))
&#9;if #Data.CurrentCategory &gt; Data.Main.InsertSets then
&#9;&#9;--Steal one entry since we have too many things
&#9;&#9;Data.Main.InsertSets = Data.Main.InsertSets - 1
&#9;end

&#9;Data.Category[Data.CurrentCategory].SetIndex = setIndex
end


function showLargePreview(insertButton)
&#9;if insertButton:FindFirstChild(&quot;AssetId&quot;) then
&#9;&#9;delay(0,function()
&#9;&#9;&#9;game:GetService(&quot;ContentProvider&quot;):Preload(LargeThumbnailUrl .. tostring(insertButton.AssetId.Value))
&#9;&#9;&#9;currStampGui.InsertPanel.ItemPreview.LargePreview.Image = LargeThumbnailUrl .. tostring(insertButton.AssetId.Value)
&#9;&#9;end)
&#9;end
&#9;if insertButton:FindFirstChild(&quot;AssetName&quot;) then
&#9;&#9;currStampGui.InsertPanel.ItemPreview.TextPanel.RolloverText.Text = insertButton.AssetName.Value
&#9;end
end


function buildInsertButton(buttonPosition)
&#9;local insertButton = currStampGui.InsertPanel.ItemsFrame.InsertAssetButtonExample:clone()
&#9;insertButton.Position = buttonPosition
&#9;insertButton.Name = &quot;InsertAssetButton&quot;
&#9;insertButton.Visible = true

&#9;local mouseEnterCon = insertButton.MouseEnter:connect(function()
&#9;&#9;lastEnter = insertButton
&#9;&#9;delay(0.1,function()
&#9;&#9;&#9;if lastEnter == insertButton then
&#9;&#9;&#9;&#9;showLargePreview(insertButton)
&#9;&#9;&#9;end
&#9;&#9;end)
&#9;end)
&#9;return insertButton, mouseEnterCon
end

function minimizeStamperPanel()
&#9;currStampGui.StamperPanel.StamperButtons.Visible = false
&#9;currStampGui.StamperPanel.MinimizeButton.Visible = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,0,0,0), UDim2.new(0.5,0,1,-92),Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;currStampGui.StamperPanel.RestoreButton.Visible = true
&#9;&#9;end)
&#9;end
end

function restoreStamperPanel()
&#9;currStampGui.StamperPanel.RestoreButton.Visible = false
&#9;if currStampGui.Parent ~= nil then
&#9;&#9;currStampGui.StamperPanel:TweenSizeAndPosition(UDim2.new(0,350,0,48), UDim2.new(0.5,-175,1,-135), Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,0.5,true)
&#9;&#9;delay(0.5,function()
&#9;&#9;&#9;currStampGui.StamperPanel.StamperButtons.Visible = true
&#9;&#9;&#9;currStampGui.StamperPanel.MinimizeButton.Visible = true
&#9;&#9;end)
&#9;end
end

function setUpStamperGui()
&#9;pcall(function() currStampGui.InsertPanel.CancelButton.Modal = true end)
&#9;Window.Sets = currStampGui.InsertPanel.Sets

&#9;cloneButtonCon = currStampGui.StamperPanel.StamperButtons.CloneButton.MouseButton1Click:connect(goToClone)
&#9;partListClickCon = currStampGui.StamperPanel.StamperButtons.PartsButton.MouseButton1Click:connect(goToInsertPanel)

&#9;Data.Main = {}
&#9;Data.Category = {}
&#9;Data.Stamp = {}

&#9;Data.BaseCategoryButtons = {}
&#9;local userData = {}
&#9;for id = 1, #userIdsForStamperParts do
&#9;&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserCategories(userIdsForStamperParts[id].Value)
&#9;&#9;if newUserData and #newUserData &gt; 2 then
&#9;&#9;&#9;-- start at #3 to skip over My Decals and My Models for each account
&#9;&#9;&#9;for category = 3, #newUserData do
&#9;&#9;&#9;&#9;if newUserData[category].Name == &quot;High Scalability&quot; then
&#9;&#9;&#9;&#9;&#9;table.insert(userData,1,newUserData[category])
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;table.insert(userData, newUserData[category])
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if userData then
&#9;&#9;Data.UserCategoryButtons = processCategory(userData, setPanel)
&#9;end

&#9;guiChangedCon = currStampGui.Changed:connect(function(prop)
&#9;&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;&#9;wait()
&#9;&#9;&#9;setSetIndex(0)
&#9;&#9;end
&#9;end)

&#9;InsertRows = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.Y/buttonHeight)
&#9;InsertColumns = math.floor(currStampGui.InsertPanel.ItemsFrame.AbsoluteSize.X/buttonWidth)

&#9;populateSetsFrame()

&#9;setsPrevPageCon = currStampGui.InsertPanel.PagingControls.PreviousPageButton.MouseButton1Click:connect(function() previousSetPage() end)
&#9;setsNextPageCon = currStampGui.InsertPanel.PagingControls.NextPageButton.MouseButton1Click:connect(function() nextSetPage() end)

&#9;insertPanelCloseCon = currStampGui.InsertPanel.CancelButton.MouseButton1Click:connect(function()
&#9;&#9;closeInsertPanel()
&#9;&#9;closeClonePanel()
&#9;&#9;reloadCurrentAsset()
&#9;end)

&#9;minimizeCon = currStampGui.StamperPanel.MinimizeButton.MouseButton1Click:connect(function() minimizeStamperPanel() end)
&#9;restoreCon = currStampGui.StamperPanel.RestoreButton.MouseButton1Click:connect(function() restoreStamperPanel() end)
end

-- signal to scripts we are ready to start manipulating objects
function signalStamperScript(assetName, assetId, image, stampMode)
&#9;insertAsset.AssetName.Value = assetName
&#9;insertAsset.AssetId.Value = assetId
&#9;insertAsset.Image.Value = image
&#9;insertAsset.StampMode.Value = stampMode
&#9;insertAsset.Updated.Value = true
end

function reloadCurrentAsset()
&#9;variables.ReloadCurrentAsset.Value = true
end


function beginInsertAssetGui(assetName, assetId, image, stampMode)
&#9;Data.Stamp.StampMode = stampMode
&#9;closeInsertPanel()
&#9;signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)
&#9;moveLoadingWindow()
&#9;cancelAssetPlacement()
&#9;signalStamperScript(assetName, assetId, image, stampMode)
end


function cancelAssetLoad()
&#9;Data.Loading.Cancelled = true
&#9;insertComplete()
&#9;gInitial90DegreeRotations = 0
end

function inBounds2(part)
&#9;-- part must have a position property
&#9;local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2
&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end
&#9;return true
end


-- For Restricting Stamper Tool (isRestricted)
function showHelp_pointToBuildingplate()

&#9;if(buildingPlate==nil) then
&#9;&#9;hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
&#9;else
&#9;&#9;-- only show one waypoint at a time (because kids will click a million times outside their plate)
&#9;&#9;hint(&quot;Stamper Tool only works in your area.&quot;)
&#9;&#9;if(not waypointShowing) then
&#9;&#9;&#9;waypointShowing = true
&#9;&#9;&#9;local _character = Tool.Parent
&#9;&#9;&#9;waitForChild(_character, &quot;Torso&quot;)
&#9;&#9;&#9;_player = game.Players:GetPlayerFromCharacter(_character)
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.target.Value = buildingPlate
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.Disabled = true
&#9;&#9;&#9;_player.PlayerGui.showBaseplateWaypoint.Disabled = false
&#9;&#9;&#9;-- Wait until character moves in bounds (check every 2 seconds)
&#9;&#9;&#9;while(not inBounds2(_character.Torso) and isEquipped) do&#9;wait(2) end
&#9;&#9;&#9;-- Then hide the waypoint
&#9;&#9;&#9;hideHelp_pointToBuildingplate()
&#9;&#9;end
&#9;end

end


function showHelp_tooManyParts()
&#9;hint(&quot;You have reached maximum number of parts! Delete some to put more down.&quot;)
end


function hideHelp_pointToBuildingplate()
&#9;waypointShowing = false
&#9;_player.PlayerGui.hideBaseplateWaypoint.Disabled = true
&#9;_player.PlayerGui.hideBaseplateWaypoint.Disabled = false&#9;&#9;
end


function setUpRestrictions()
&#9;playerModel = game.Workspace.ActiveParts:FindFirstChild(player.Name .. &quot;&apos;s parts&quot;)

&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()

&#9;waitForChild(player, &quot;playerNumber&quot;)
&#9;&#9;
&#9;if(player.playerNumber.Value == 0) then
&#9;  buildingPlate = nil
&#9;  partModel = nil
&#9;else
&#9;  waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;  local buildingAreas = game.Workspace.BuildingAreas
&#9;  waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;  local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;  waitForChild(targetArea, &quot;PlayerArea&quot;)
&#9;  waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

&#9;  buildingPlate = targetArea.PlayerArea.BasePlate
&#9;  partModel = targetArea.PlayerArea
&#9;&#9;&#9;
&#9;end

&#9;-- Check if player is standing in bounds, if not show error
&#9;local _character = Tool.Parent
&#9;waitForChild(_character, &quot;Torso&quot;)
&#9;_player = game.Players:GetPlayerFromCharacter(_character)
&#9;if(buildingPlate~=nil) then
&#9;&#9;if(not inBounds2(_character.Torso)) then
&#9;&#9;&#9;showHelp_pointToBuildingplate()
&#9;&#9;end
&#9;else
&#9;&#9;-- You have no building plate.
&#9;&#9;hint(&quot;All building areas are taken. If you want to build, leave and join again.&quot;)
&#9;end
end

function onInsertKeyDown(key)
&#9;if loading then return end -- don&apos;t try to switch while we&apos;re loading

&#9;key = string.lower(key)

&#9;-- go to mru buttons
&#9;if key == &apos;f&apos; then
&#9;&#9;mruButtonClick(1)
&#9;elseif key == &apos;g&apos; then
&#9;&#9;mruButtonClick(2)
&#9;elseif key == &apos;h&apos; then
&#9;&#9;mruButtonClick(3)
&#9;elseif key == &apos;j&apos; then
&#9;&#9;mruButtonClick(4)
&#9;end

end

function onEquippedLocal(mouse)
&#9;player = getPlayer()
&#9;if not player then 
&#9;&#9;return 
&#9;end
&#9;if Tool.PlayerOwner.Value and Tool.PlayerOwner.Value ~= player then return end 

&#9;-- For Restricting Stamper Tool
&#9;if isRestricted.Value then
&#9;&#9;setUpRestrictions()
&#9;end

&#9;Mouse = mouse
&#9;if not firstEquip and currStampGui and Tool.SavedState.Value and Tool.PlayerOwner.Value == getPlayer() and Data and Data.FullyLoaded then

&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui

&#9;&#9;if mode == 1 then -- if we were stamping, keep going
&#9;&#9;&#9;-- if we signal a negative asset, then that means keep going using whatever was in recent memory [don&apos;t reload from insert service]
&#9;&#9;&#9;signalStamperScript(insertAsset.AssetName.Value, -1, insertAsset.Image.Value, true)&#9;&#9;&#9;
&#9;&#9;elseif mode == 2 then -- time to clone
&#9;&#9;&#9;goToClone()
&#9;&#9;end

&#9;else
&#9;&#9;if firstEquip then
&#9;&#9;&#9;Tool.PlayerOwner.Value = player
&#9;&#9;&#9;firstEquip = false
&#9;&#9;end
&#9;&#9;CancelDuringLoad = false
&#9;&#9;resetCons()

&#9;&#9;Data = {}
&#9;&#9;Data.FullyLoaded = false
&#9;&#9;&#9;&#9;
&#9;&#9;Window = {}
&#9;&#9;Window.Sets = {}

&#9;&#9;currStampGui = stamperGui:clone()
&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui
&#9;&#9;wait()
&#9;&#9;setUpStamperGui()

&#9;&#9;if not(CancelDuringLoad) then
&#9;&#9;&#9;currStampGui.Parent = getPlayer().PlayerGui
&#9;&#9;&#9;Tool.SavedState.Value = currStampGui
&#9;&#9;end

&#9;&#9;Data.FullyLoaded = true
&#9;end

&#9;Mouse.KeyDown:connect(onInsertKeyDown)
end


function onUnequippedLocal()
&#9;if currStampGui then
&#9;&#9;Tool.SavedState.Value = currStampGui
&#9;&#9;currStampGui.Parent = nil
&#9;end
&#9;
&#9;pcall(function()
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Loading.Cancelled = true
&#9;end)
&#9;CancelDuringLoad = true
end


function killConnection(connection)
&#9;if connection then connection:disconnect() end
end


function resetCons()
&#9;killConnection(guiChangedCon)
&#9;killConnection(cloneButtonCon)
&#9;killConnection(partListClickCon)
&#9;killConnection(itemFrameChangedCon)
&#9;killConnection(setsPrevPageCon)
&#9;killConnection(setsNextPageCon)
&#9;killConnection(insertPanelCloseCon)
&#9;killConnection(minimizeCon)
&#9;killConnection(restoreCon)
end


function onAncestryChanged(child,parent)
&#9;if Tool.PlayerOwner.Value and not Tool:IsDescendantOf(Tool.PlayerOwner.Value) and not Tool:IsDescendantOf(Tool.PlayerOwner.Value.Character) then
&#9;&#9;--Tool was dropped in some way, so we need to nuke our external state
&#9;&#9;Tool.SavedState.Value = nil
&#9;&#9;resetCons()
&#9;end
end


function getMaxNumOfRecentParts()
&#9;return maxRecentParts
end


function pushRecentStackBack()
&#9;for i = getMaxNumOfRecentParts() - 1, 1, -1 do
&#9;&#9;recentPartStack[i + 1].AssetNameValue = recentPartStack[i].AssetNameValue
&#9;&#9;recentPartStack[i + 1].AssetIdValue = recentPartStack[i].AssetIdValue
&#9;&#9;recentPartStack[i + 1].InsertFrameButtonImage = recentPartStack[i].InsertFrameButtonImage
&#9;end
end


function clearMRUList()
&#9;local buttons = currStampGui.StamperPanel.StamperButtons.RecentFrame:GetChildren()
&#9;for i = 1, #buttons do
&#9;&#9;if recentPartStackCons[i] then recentPartStackCons[i]:disconnect() end
&#9;&#9;buttons[i].Visible = false
&#9;end
end


function mruButtonClick(position)
&#9;if recentPartStack[position].AssetIdValue == insertAsset.AssetId.Value then return end -- already stamping part
&#9;-- get rid of old part
&#9;signalStamperScript(&quot;&quot;,0,&quot;&quot;,&quot;&quot;,false)

&#9;--Show the dialog window
&#9;moveLoadingWindow()
&#9;signalStamperScript(recentPartStack[position].AssetNameValue, recentPartStack[position].AssetIdValue, recentPartStack[position].InsertFrameButtonImage, true)
end


function insertMRUButton(position)
&#9;local mruButton = currStampGui.StamperPanel.StamperButtons.RecentFrame:FindFirstChild(&quot;Button&quot; .. tostring(position))
&#9;mruButton.ButtonImage.Image = recentPartStack[position].InsertFrameButtonImage
&#9;if mruButton.ButtonImage.Image == &quot;&quot; then
&#9;&#9;mruButton.Text = recentPartStack[position].AssetNameValue
&#9;end

&#9;if recentPartStackCons[position] then pcall(function() recentPartStackCons[position]:Disconnect() end) end
&#9;recentPartStackCons[position] = mruButton.MouseButton1Click:connect(function() mruButtonClick(position) end)
&#9;mruButton.Visible = true
end


function refreshRecentParts()
&#9;if insertAsset.Image.Value == &quot;&quot; then return end -- we don&apos;t have an asset, get out of here
&#9;if not recentPartStack then return end -- if somehow not created yet (recentPartStack[i] calls below were nil somehow)
&#9;
&#9;local numOfRecentParts = getMaxNumOfRecentParts()

&#9;for i = 1,numOfRecentParts do
&#9;&#9;if insertAsset.AssetId and recentPartStack[i] and insertAsset.AssetId.Value == recentPartStack[i].AssetIdValue then -- already have part, don&apos;t push back
&#9;&#9;&#9;return
&#9;&#9;end
&#9;end

&#9;pushRecentStackBack()

&#9;-- update our stack to show previously allocated part
&#9;recentPartStack[1].AssetNameValue = insertAsset.AssetName.Value
&#9;recentPartStack[1].AssetIdValue = insertAsset.AssetId.Value
&#9;recentPartStack[1].InsertFrameButtonImage =  insertAsset.Image.Value

&#9;clearMRUList()

&#9;for i = 1, numOfRecentParts do
&#9;&#9;if recentPartStack[i] and recentPartStack[i].AssetIdValue ~= &quot;&quot; then
&#9;&#9;&#9;insertMRUButton(i)
&#9;&#9;end
&#9;end
end


function updateGui(type)
&#9;if type == &quot;Main&quot; then
&#9;&#9;goToInsertPanel()
&#9;elseif type == &quot;EyeDropper&quot; then
&#9;&#9;goToClone()
&#9;elseif type == &quot;SideDialog&quot; then
&#9;&#9;goToStamp()
&#9;end
end
----------------------------------------------------------------------------------------



-- Lua Start Execution
setAssetUrls()

Tool.Equipped:connect(onEquippedLocal)
Tool.Unequipped:connect(onUnequippedLocal)
Tool.AncestryChanged:connect(onAncestryChanged)

waitForChild(variables, &quot;SwitchLoaderToDialog&quot;)
variables.SwitchLoaderToDialog.Changed:connect(function(prop)
&#9;if variables.SwitchLoaderToDialog.Value == true then
&#9;&#9;updateGui(variables.SwitchLoaderToDialog.DialogType.Value)
&#9;&#9;variables.SwitchLoaderToDialog.Value = false
&#9;end

end)

waitForChild(variables, &quot;ShowInvalidPlacement&quot;)
variables.ShowInvalidPlacement.Changed:connect(function(prop)
&#9;if variables.ShowInvalidPlacement.Value == true then
&#9;&#9;showHelp_pointToBuildingplate()
&#9;&#9;showBaseplateGuideArrows()
&#9;&#9;variables.ShowInvalidPlacement.Value = false
&#9;end
end)

waitForChild(variables, &quot;ShowMaxedOut&quot;)
variables.ShowMaxedOut.Changed:connect(function(prop)
&#9;if variables.ShowMaxedOut.Value == true then
&#9;&#9;showHelp_tooManyParts()
&#9;&#9;variables.ShowMaxedOut.Value = false
&#9;end
end)

waitForChild(variables, &quot;Stamped&quot;)
variables.Stamped.Changed:connect(function()
&#9;if variables.Stamped.Value == true then
&#9;&#9;refreshRecentParts()
&#9;end
end)
----------------------------------------------------------------------------------------</ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX49">
				<Properties>
					<bool name="Disabled">true</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Readme</string>
					<ProtectedString name="Source">--[[ 
&#9;Stamper Tool v1.0.0
&#9;

&#9;Welcome to the stamper tool readme!
&#9;Currently, this doc only exists to show the Stamper Tool Version!

]] </ProtectedString>
				</Properties>
			</Item>
			<Item class="LocalScript" referent="RBX50">
				<Properties>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">StampScript</string>
					<ProtectedString name="Source">-- basic functions

function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
----------------------------------------------------------------------------------------

-- Locals

local Tool = script.Parent

local Mouse
local mouseMoveCon
local mouseButton1DownCon
local mouseButton1UpCon
local cameraChangeCon

local walking = false

local pressedEsc = false

local billBoardOwnerGui = nil

local cluster = game.Workspace:FindFirstChild(&quot;Terrain&quot;)

local gInitial90DegreeRotations = 0
local gStaticTrans = 1
local gDesiredTrans = 0.7
local transFadeInTime = 0.5
local fadeInDelayTime = 0.5
local eyedropperOffGridTolerance = 0.01

local insertBoundingBoxOverlapVector = Vector3.new(1, 1, 1) -- we can still stamp if our character extrudes into the target stamping space by 1 or fewer units

local useAssetVersionId = false


-- for high-scalability display
local adornPart = Instance.new(&quot;Part&quot;)
adornPart.Parent = nil
adornPart.formFactor = &quot;Custom&quot;
adornPart.Size = Vector3.new(4, 4, 4)
adornPart.CFrame = CFrame.new()

local adorn = Instance.new(&quot;SelectionBox&quot;)
adorn.Color = BrickColor.new(&quot;Toothpaste&quot;)
adorn.Adornee = adornPart
adorn.Visible = true
adorn.Transparency = 0
adorn.Name = &quot;HighScalabilityStamperLine&quot;
adorn.Parent = nil

local terrainSelectionBox = Instance.new(&quot;Part&quot;)
terrainSelectionBox.Parent = nil
terrainSelectionBox.formFactor = &quot;Custom&quot;
terrainSelectionBox.Size = Vector3.new(4, 4, 4)
terrainSelectionBox.CFrame = CFrame.new()

local HighScalabilityLine = {}
HighScalabilityLine.Start = nil
HighScalabilityLine.End = nil
HighScalabilityLine.Adorn = adorn
HighScalabilityLine.AdornPart = adornPart
HighScalabilityLine.InternalLine = nil
HighScalabilityLine.NewHint = true

-- for higher dimensional megacluster part stamping
HighScalabilityLine.MorePoints = {nil, nil}
HighScalabilityLine.MoreLines = {nil, nil}
HighScalabilityLine.Dimensions = 1

waitForChild(Tool,&quot;LuaGlobalVariables&quot;)
local variables = Tool.LuaGlobalVariables
waitForChild(variables,&quot;ShowInvalidPlacement&quot;)
waitForChild(variables, &quot;Stamped&quot;)
waitForChild(Tool,&quot;ErrorBox&quot;)
waitForChild(variables, &quot;ShowAdminCategories&quot;)
local errorBox = Tool.ErrorBox

waitForChild(variables, &quot;IsRestricted&quot;)
waitForChild(variables, &quot;MouseClick&quot;)
click = variables.MouseClick

local Data = {}
Data.Stamp = {}
Data.Loading = {}

local guiScriptIsLoadingSomething = false
local unstampableSurface = false

local eyeDropperConnection, eyeDropperMoveConnection

local playerModel
local player

local lastTargetCFrame = nil
local lastTargetTerrainOrientation = 0

-- For Restricting Stamper Tool
local isRestricted = variables.IsRestricted.Value
local adminAccess = variables.ShowAdminCategories.Value

-- For Delete highlighting
local selectionBox
local currentSelection
local currentSelectionColors = {}

if isRestricted then waitForChild(game.Workspace, &quot;BaseplateBumpers&quot;) end
----------------------------------------------------------------------------------------

-- Functions
function hint(label)
&#9;-- Pass in a string, it shows a top hint.  (Replaces previous hint, if exists)
&#9;_player = game.Players:GetPlayerFromCharacter(Tool.Parent)
&#9;if(_player.PlayerGui:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;&#9;local topHint = _player.PlayerGui.topHint
&#9;&#9;topHint.Add.Label.Value = label
&#9;&#9;topHint.Add.Width.Value = 3 -- widest width
&#9;&#9;topHint.Add.Time.Value = 5
&#9;&#9;topHint.Add.Disabled = true
&#9;&#9;topHint.Add.Disabled = false
&#9;end
end


function getClosestColorToTerrainMaterial(terrainValue)
&#9;if terrainValue == 1 then
&#9;&#9;return BrickColor.new(&quot;Bright green&quot;)
&#9;elseif terrainValue == 2 then
&#9;&#9;return BrickColor.new(&quot;Bright yellow&quot;)
&#9;elseif terrainValue == 3 then
&#9;&#9;return BrickColor.new(&quot;Bright red&quot;)
&#9;elseif terrainValue == 4 then
&#9;&#9;return BrickColor.new(&quot;Medium stone grey&quot;)
&#9;else
&#9;&#9;return BrickColor.new(&quot;Bright green&quot;)
&#9;end
end


local manualWeldTable = {}
local manualWeldParentTable = {}
function saveTheWelds(object)
&#9;if object:IsA(&quot;ManualWeld&quot;) or object:IsA(&quot;Rotate&quot;) then
&#9;&#9;table.insert(manualWeldTable, object)
&#9;&#9;table.insert(manualWeldParentTable, object.Parent)
&#9;else
&#9;&#9;local children = object:GetChildren()
&#9;&#9;for i = 1, #children do
&#9;&#9;&#9;saveTheWelds(children[i])
&#9;&#9;end
&#9;end
end

function restoreTheWelds()
&#9;for i = 1, #manualWeldTable do
&#9;&#9;manualWeldTable[i].Parent = manualWeldParentTable[i]
&#9;end
end


function findSeatsInModel(parent, seatTable)
&#9;if not parent then return end

&#9;if parent.className == &quot;Seat&quot; or parent.className == &quot;VehicleSeat&quot; then
&#9;&#9;table.insert(seatTable, parent)
&#9;end
&#9;local myChildren = parent:GetChildren()
&#9;for j = 1, #myChildren do
&#9;&#9;findSeatsInModel(myChildren[j], seatTable)
&#9;end
end

function setSeatEnabledStatus(model, isEnabled)
&#9;local seatList = {}
&#9;findSeatsInModel(model, seatList)

&#9;if isEnabled then
&#9;&#9;-- remove any welds called &quot;SeatWeld&quot; in seats
&#9;&#9;for i = 1, #seatList do
&#9;&#9;&#9;local nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;)
&#9;&#9;&#9;while nextSeat do nextSeat:Remove() nextSeat = seatList[i]:FindFirstChild(&quot;SeatWeld&quot;) end
&#9;&#9;end
&#9;else
&#9;&#9;-- put a weld called &quot;SeatWeld&quot; in every seat
&#9;&#9;--   this tricks it into thinking there&apos;s already someone sitting there, and it won&apos;t make you sit XD
&#9;&#9;for i = 1, #seatList do
&#9;&#9;&#9;local fakeWeld = Instance.new(&quot;Weld&quot;)
&#9;&#9;&#9;fakeWeld.Name = &quot;SeatWeld&quot;
&#9;&#9;&#9;fakeWeld.Parent = seatList[i]
&#9;&#9;end
&#9;end
end


function UnlockInstances(object)

&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;object.Locked = false
&#9;end
&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;UnlockInstances(child)
&#9;end

end

function generateOwnerGui(playerName)
&#9;local gui = Instance.new(&quot;BillboardGui&quot;)
&#9;gui.Name = &quot;PlayerStamperTagGui&quot;
&#9;gui.StudsOffset = Vector3.new(0,1,0)
&#9;gui.ExtentsOffset = Vector3.new(0,1,0)
&#9;gui.Size = UDim2.new(5,0,2,0)
&#9;pcall(function() gui.PlayerToHideFrom = game.Players.LocalPlayer end)

&#9;local frame = Instance.new(&quot;Frame&quot;)
&#9;frame.BackgroundColor3 = Color3.new(0,0,0)
&#9;frame.BackgroundTransparency = 0.5
&#9;frame.Name = &quot;OwnerFrame&quot;
&#9;frame.Size = UDim2.new(1,0,1,0)
&#9;frame.Parent = gui
&#9;
&#9;local ownerName = Instance.new(&quot;TextLabel&quot;)
&#9;ownerName.Name = &quot;OwnerName&quot;
&#9;ownerName.Size = UDim2.new(1,0,1,0)
&#9;ownerName.Text = playerName
&#9;ownerName.Font = Enum.Font.ArialBold
&#9;ownerName.FontSize = Enum.FontSize.Size14
&#9;ownerName.TextWrap = true
&#9;ownerName.TextColor3 = Color3.new(1,1,1)
&#9;ownerName.TextStrokeTransparency = 0
&#9;ownerName.BackgroundTransparency = 1
&#9;ownerName.Parent = frame

&#9;return gui
end



function getPlayer()
&#9;return game.Players:GetPlayerFromCharacter(script.Parent.Parent)
end

function beginInsertAssetStamp(assetName, assetId, image, stampMode)
&#9;-- trying to stop assets, gone back to Main Stamp Dialog
&#9;if assetId == 0 then
&#9;&#9;guiScriptIsLoadingSomething = true
&#9;&#9;cancelAssetPlacement()
&#9;&#9;return
&#9;end
&#9;if assetId &lt; 0 then
&#9;&#9;guiScriptIsLoadingSomething = true
&#9;&#9;cancelAssetPlacement()
&#9;&#9;setupDraggableClone()
&#9;&#9;wait() -- need this so onInsertMouseMove() can sync up with setupDraggableClone()
&#9;&#9;onInsertMouseMove()
&#9;&#9;guiScriptIsLoadingSomething = false
&#9;&#9;return
&#9;end
&#9;-- This call will cause a &quot;wait&quot; until the data comes back
&#9;-- below we wait a max of 8 seconds before deciding to bail out on loading
&#9;local root
&#9;local loader
&#9;loading = true
&#9;if useAssetVersionId then
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAssetVersion(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;else
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAsset(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;end

&#9;local lastGameTime = 0
&#9;local totalTime = 0
&#9;local maxWait = 8
&#9;while loading and totalTime &lt; maxWait do
&#9;&#9;lastGameTime = tick()
&#9;&#9;wait(1)
&#9;&#9;totalTime = totalTime + tick() - lastGameTime
&#9;end
&#9;loading = false

&#9;if totalTime &gt;= maxWait or pressedEsc then
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;pressedEsc = false
&#9;else
&#9;&#9;Data.Loading.Cancelled = false
&#9;end


&#9;if Data.Loading.Cancelled then
&#9;&#9;--The user got bored and wandered off
&#9;&#9;--Just delete the model from the world... a shame we loaded it when they got bored
&#9;&#9;-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
&#9;&#9;pcall(function() root:Remove() end)
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;else
&#9;&#9;if root == nil then
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;if not root:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;local instances = root:GetChildren()
&#9;&#9;if #instances == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;--Unlock all parts that are inserted, to make sure they are editable
&#9;&#9;UnlockInstances(root)

&#9;&#9;--Continue the insert process
&#9;&#9;root.Name = &quot;InsertedObject&quot; .. assetId

&#9;&#9;--Examine the contents and decide what it looks like
&#9;&#9;for pos, instance in pairs(instances) do
&#9;&#9;&#9;--Single instance objects might be treated special, decals/skyboxes
&#9;&#9;&#9;if instance:IsA(&quot;Decal&quot;) then
&#9;&#9;&#9;&#9;--Current system here stops after finding one Decal (and gives you Decal tool)
&#9;&#9;&#9;&#9;--We should do the same (probably)
&#9;&#9;&#9;&#9;beginInsertDecal(instance)
&#9;&#9;&#9;&#9;root:Remove()

&#9;&#9;&#9;&#9;Window.Stamp.Frame.Visible = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;elseif instance:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;instance.Parent = game:GetService(&quot;Teams&quot;)
&#9;&#9;&#9;elseif instance:IsA(&quot;SpawnLocation&quot;) then
&#9;&#9;&#9;&#9;-- uh.............
&#9;&#9;&#9;elseif instance:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;-- Must go into the starterPack, prompt user?
&#9;&#9;&#9;elseif instance:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;-- Ask them if it should go in StarterPack?
&#9;&#9;&#9;elseif instance:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;local lightingService = game:GetService(&quot;Lighting&quot;)
&#9;&#9;&#9;&#9;for index,child in pairs(lightingService:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;child:Remove();
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;instance.Parent = lightingService
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;else

&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if #root:GetChildren() == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;signalInsertComplete(&quot;SideDialog&quot;)
&#9;&#9;
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Stamp.Model = root
&#9;&#9;setupDraggableClone()
&#9;&#9;guiScriptIsLoadingSomething = false
&#9;end

end

function beginInsertDecal(decal)

&#9;Data.Stamp.DecalSelection = Instance.new(&quot;SurfaceSelection&quot;)
&#9;Data.Stamp.DecalSelection.Color = BrickColor.new(&quot;Bright orange&quot;)
&#9;Data.Stamp.DecalSelection.archivable = false
&#9;Data.Stamp.DecalSelection.Parent = getPlayer().PlayerGui

&#9;--Save the decal in our Lua code for later use
&#9;Data.Stamp.Decal = decal
&#9;Data.Stamp.Decal.Parent = nil

end


-- signal to gui to switch frames
function signalInsertComplete(type)

&#9;if type == &quot;SideDialog&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;elseif type == &quot;Main&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;Main&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;elseif type == &quot;EyeDropper&quot; then
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;EyeDropper&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;end

&#9;-- needed to make sure we disconnect eyedroper handler
&#9;if type ~= &quot;EyeDropper&quot; then
&#9;&#9;if eyeDropperConnection then
&#9;&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;&#9;eyeDropperConnection = nil
&#9;&#9;end
&#9;&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;end
&#9;clearSelection()

end


function p(assetName, assetId, image, stampMode)
&#9;-- trying to stop assets, gone back to Main Stamp Dialog
&#9;if assetId == 0 then
&#9;&#9;cancelAssetPlacement()
&#9;&#9;return
&#9;end

&#9;-- This call will cause a &quot;wait&quot; until the data comes back
&#9;-- below we wait a max of 8 seconds before deciding to bail out on loading
&#9;local root
&#9;local loader
&#9;loading = true
&#9;if useAssetVersionId then
&#9;&#9;loader = coroutine.create(function()
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAssetVersion(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;else
&#9;&#9;loader = coroutine.create(function()&#9;
&#9;&#9;&#9;root = game:GetService(&quot;InsertService&quot;):LoadAsset(assetId)
&#9;&#9;&#9;loading = false
&#9;&#9;end)
&#9;&#9;coroutine.resume(loader)
&#9;end

&#9;local lastGameTime = 0
&#9;local totalTime = 0
&#9;local maxWait = 8
&#9;while loading and totalTime &lt; maxWait do
&#9;&#9;lastGameTime = tick()
&#9;&#9;wait(1)
&#9;&#9;totalTime = totalTime + tick() - lastGameTime
&#9;end
&#9;loading = false

&#9;if totalTime &gt;= maxWait or pressedEsc then
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;pressedEsc = false
&#9;else
&#9;&#9;Data.Loading.Cancelled = false
&#9;end


&#9;if Data.Loading.Cancelled then
&#9;&#9;--The user got bored and wandered off
&#9;&#9;--Just delete the model from the world... a shame we loaded it when they got bored
&#9;&#9;-- 12/28/2010: Putting this inside a pcall (on gametest, first time equipping stamper, this was being called with root=nil.) (Jahr)
&#9;&#9;pcall(function() root:Remove() end)
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;else
&#9;&#9;local instances = root:GetChildren()
&#9;&#9;if #instances == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;--Unlock all parts that are inserted, to make sure they are editable
&#9;&#9;UnlockInstances(root)

&#9;&#9;--Continue the insert process
&#9;&#9;root.Name = &quot;InsertedObject&quot; .. assetId

&#9;&#9;--Examine the contents and decide what it looks like
&#9;&#9;for pos, instance in pairs(instances) do
&#9;&#9;&#9;--Single instance objects might be treated special, decals/skyboxes
&#9;&#9;&#9;if instance:IsA(&quot;Decal&quot;) then
&#9;&#9;&#9;&#9;--Current system here stops after finding one Decal (and gives you Decal tool)
&#9;&#9;&#9;&#9;--We should do the same (probably)
&#9;&#9;&#9;&#9;beginInsertDecal(instance)
&#9;&#9;&#9;&#9;root:Remove()

&#9;&#9;&#9;&#9;Window.Stamp.Frame.Visible = true
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;elseif instance:IsA(&quot;Team&quot;) then
&#9;&#9;&#9;&#9;instance.Parent = game:GetService(&quot;Teams&quot;)
&#9;&#9;&#9;elseif instance:IsA(&quot;SpawnLocation&quot;) then
&#9;&#9;&#9;&#9;-- uh.............
&#9;&#9;&#9;elseif instance:IsA(&quot;HopperBin&quot;) then
&#9;&#9;&#9;&#9;-- Must go into the starterPack, prompt user?
&#9;&#9;&#9;elseif instance:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;-- Ask them if it should go in StarterPack?
&#9;&#9;&#9;elseif instance:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;local lightingService = game:GetService(&quot;Lighting&quot;)
&#9;&#9;&#9;&#9;for index,child in pairs(lightingService:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if child:IsA(&quot;Sky&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;child:Remove();
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;instance.Parent = lightingService
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;else

&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;if #root:GetChildren() == 0 then
&#9;&#9;&#9;root:Remove()
&#9;&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;&#9;&#9;return
&#9;&#9;end

&#9;&#9;signalInsertComplete(&quot;SideDialog&quot;)
&#9;&#9;
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Stamp.Model = root
&#9;&#9;setupDraggableClone()
&#9;end

end


function positionPartsAtCFrame3(partOrModel, aCFrame)

&#9;local insertCFrame
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;--insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[1].CFrame
&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;CornerWedgePart&quot;)) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame

&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;)) then
&#9;&#9;&#9;&#9;local posPartInWorld = object.Position
&#9;&#9;&#9;&#9;local posPart1InWorld = insertCFrame.p
&#9;&#9;&#9;&#9;local newPosPartInWorld = posPartInWorld - posPart1InWorld + aCFrame.p
&#9;
&#9;&#9;&#9;&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = object.CFrame:components()
&#9;&#9;&#9;&#9;object.CFrame = CFrame.new(newPosPartInWorld.x, newPosPartInWorld.y, newPosPartInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;else
&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = aCFrame
&#9;end

end


-- For Restricting Stamper Tool (isRestricted)
function inBounds(object)

&#9;for part, transparency in pairs(object) do
&#9;&#9;if part:IsA(&quot;Part&quot;) or part:IsA(&quot;WedgePart&quot;) or part:IsA(&quot;CornerWedgePart&quot;) or part:IsA(&quot;TrussPart&quot;) then
&#9;&#9;&#9;if not partInBounds(part) then return false end
&#9;&#9;elseif part:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;local primPart = object.PrimaryPart
&#9;&#9;&#9;if not partInBounds(primPart) then return false end
&#9;&#9;end
&#9;end
&#9;return true

end

function partInBounds(part)

&#9;if part == nil then return false end

&#9;local xOne= buildingPlate.Position.x + buildingPlate.Size.x/2
&#9;local xTwo = buildingPlate.Position.x - buildingPlate.Size.x/2
&#9;local zOne = buildingPlate.Position.z + buildingPlate.Size.z/2
&#9;local zTwo = buildingPlate.Position.z - buildingPlate.Size.z/2

&#9;if part.Position.x &gt; xOne or part.Position.x &lt; xTwo then return false end
&#9;if part.Position.z &gt; zOne or part.Position.z &lt; zTwo then return false end

&#9;return true

end



function canSelectObject(part)
&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60
end

function canEyeDropperObject(part)
&#9;local stamperTag = part.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
&#9;if stamperTag == nil then stamperTag = part:FindFirstChild(&quot;RobloxStamper&quot;) end

&#9;return part and not (part.Locked) and part:IsA(&quot;BasePart&quot;) and (part.Position - Tool.Parent.Head.Position).Magnitude &lt; 60 and stamperTag ~= nil
end

function isOnGrid(partOrModel)
&#9;-- first check to see if off-grid, and if so, prevent eyedropperage
&#9;&#9;local modelExtentsInWorldCoords
&#9;&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;modelExtentsInWorldCoords = partOrModel:GetModelCFrame():vectorToWorldSpace(partOrModel:GetModelSize())
&#9;&#9;else
&#9;&#9;&#9;modelExtentsInWorldCoords = partOrModel.CFrame:vectorToWorldSpace(partOrModel.Size)
&#9;&#9;end

&#9;&#9;-- we now simply check to see if the above property fits in a 4x4x4 gridspace
&#9;&#9;offX = math.fmod(math.abs(modelExtentsInWorldCoords.X), 4)
&#9;&#9;offY = math.fmod(math.abs(modelExtentsInWorldCoords.Y), 4)
&#9;&#9;offZ = math.fmod(math.abs(modelExtentsInWorldCoords.Z), 4)

&#9;&#9;local numberOfAxesOffGrid = 0
&#9;&#9;if math.min(offX, 4 - offX) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
&#9;&#9;if math.min(offY, 4 - offY) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end
&#9;&#9;if math.min(offZ, 4 - offZ) &gt; eyedropperOffGridTolerance then numberOfAxesOffGrid = numberOfAxesOffGrid + 1 end

&#9;&#9;if numberOfAxesOffGrid &gt; 1 then return false -- we allow one axis to be not fit to grid, since any rotation must necessarily affect &gt;= 2 axes (some of the models are like 4x4x6 :(  ).
&#9;&#9;else return true end
end


-- below is a helper function to help get the model surface instead of the part surface [for allowing a side to elect out of making joints automatically]
function calcRayHitTime(rayStart, raySlope, intersectionPlane)
&#9;if math.abs(raySlope) &lt; .01 then return 0 end -- 0 slope --&gt;  we just say intersection time is 0, and sidestep this dimension
&#9;-- rayStart + t*raySlope = intersectionPlane, so t = (intersectionPlane - rayStart) / raySlope
&#9;return (intersectionPlane - rayStart) / raySlope
end


function modelTargetSurface(partOrModel, rayStart, rayEnd)
&#9;if not partOrModel then
&#9;&#9;return 0
&#9;end

&#9;local modelCFrame = nil
&#9;local modelSize = nil
&#9;if partOrModel:IsA(&quot;Model&quot;) then
&#9;&#9;modelCFrame = partOrModel:GetModelCFrame()
&#9;&#9;modelSize = partOrModel:GetModelSize()
&#9;else
&#9;&#9;modelCFrame = partOrModel.CFrame
&#9;&#9;modelSize = partOrModel.Size
&#9;end

&#9;local mouseRayStart = modelCFrame:pointToObjectSpace(rayStart)
&#9;local mouseRayEnd = modelCFrame:pointToObjectSpace(rayEnd)
&#9;local mouseSlope = mouseRayEnd - mouseRayStart

&#9;local xPositive = 1
&#9;local yPositive = 1
&#9;local zPositive = 1
&#9;if mouseSlope.X &gt; 0 then xPositive = -1 end
&#9;if mouseSlope.Y &gt; 0 then yPositive = -1 end
&#9;if mouseSlope.Z &gt; 0 then zPositive = -1 end

&#9;-- find which surface the transformed mouse ray hits (using modelSize):
&#9;local xHitTime = calcRayHitTime(mouseRayStart.X, mouseSlope.X, modelSize.X/2 * xPositive)
&#9;local yHitTime = calcRayHitTime(mouseRayStart.Y, mouseSlope.Y, modelSize.Y/2 * yPositive)
&#9;local zHitTime = calcRayHitTime(mouseRayStart.Z, mouseSlope.Z, modelSize.Z/2 * zPositive)

&#9;local hitFace = 0

&#9;--if xHitTime &gt;= 0 and yHitTime &gt;= 0 and zHitTime &gt;= 0 then
&#9;if xHitTime &gt; yHitTime then
&#9;&#9;if xHitTime &gt; zHitTime then
&#9;&#9;&#9;-- xFace is hit
&#9;&#9;&#9;hitFace = 1*xPositive
&#9;&#9;else
&#9;&#9;&#9;-- zFace is hit
&#9;&#9;&#9;hitFace = 3*zPositive
&#9;&#9;end
&#9;else
&#9;&#9;if yHitTime &gt; zHitTime then
&#9;&#9;&#9;-- yFace is hit
&#9;&#9;&#9;hitFace = 2*yPositive
&#9;&#9;else
&#9;&#9;&#9;-- zFace is hit
&#9;&#9;&#9;hitFace = 3*zPositive
&#9;&#9;end
&#9;end

&#9;return hitFace
end


-- helper function for truncating to 45-degree angles on a 2D plane
function truncateToCircleEighth(bigValue, littleValue)
&#9;local big = math.abs(bigValue)
&#9;local little = math.abs(littleValue)
&#9;local hypotenuse = math.sqrt(big*big + little*little)
&#9;local frac = little / hypotenuse

&#9;local bigSign = 1
&#9;local littleSign = 1
&#9;if bigValue &lt; 0 then bigSign = -1 end
&#9;if littleValue &lt; 0 then littleSign = -1 end

&#9;if frac &gt; .382683432 then
&#9;&#9;-- between 22.5 and 45 degrees, so truncate to 45-degree tilt
&#9;&#9;return .707106781 * hypotenuse * bigSign, .707106781 * hypotenuse * littleSign
&#9;else 
&#9;&#9;-- between 0 and 22.5 degrees, so truncate to 0-degree tilt
&#9;&#9;return hypotenuse * bigSign, 0
&#9;end
end

function onInsertMouseMove()

&#9;if Data.Stamp.MovingLock then
&#9;&#9;return
&#9;end

&#9;-- check to see if mouse is still active, and return otherwise!
&#9;if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then return true else return false end end) then print(&quot;ERRORED OUT&quot;) game.JointsService:SetJoinAfterMoveTarget(nil) Mouse = nil return end

&#9;if isRestricted and Mouse then
&#9;&#9;Mouse.TargetFilter = game.Workspace.BaseplateBumpers
&#9;end

&#9;Data.Stamp.MovingLock = true
&#9;if Data.Stamp.Dragger == nil then
&#9;&#9;if Data.Stamp.Model ~= nil then
&#9;&#9;&#9;if isRestricted then
&#9;&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;-- REM TL: Data.Stamp.Dragger:MouseMove(Mouse.UnitRay)
&#9;&#9;-- don&apos;t move with dragger - will move in one step on mouse down
&#9;&#9;-- draw ghost at acceptable positions
&#9;&#9;configFound, targetCFrame, targetSurface = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;if configFound then

&#9;&#9;&#9;&#9;if autoAlignToFace() and targetSurface ~= 1 and targetSurface ~= 4 then
&#9;&#9;&#9;&#9;-- pre-rotate the flag or portrait so it&apos;s aligned correctly
&#9;&#9;&#9;&#9;--local currCFrame
&#9;&#9;&#9;&#9;--if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then currCFrame = Data.Stamp.CurrentParts[1]:GetModelCFrame()
&#9;&#9;&#9;&#9;--else currCFrame = Data.Stamp.CurrentParts[1].CFrame end

&#9;&#9;&#9;&#9;local numRotations = 0 -- update this according to how many rotations you need to get it to target surface
&#9;&#9;&#9;&#9;if targetSurface == 3 then numRotations = 0 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 0 then numRotations = 2 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 5 then numRotations = 3 - gInitial90DegreeRotations + autoAlignToFace()
&#9;&#9;&#9;&#9;elseif targetSurface == 2 then numRotations = 1 - gInitial90DegreeRotations + autoAlignToFace() end
&#9;&#9;&#9;&#9;

&#9;&#9;&#9;&#9;local ry = math.pi/2
&#9;&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry*numRotations, 0)
&#9;&#9;&#9;&#9;gInitial90DegreeRotations = gInitial90DegreeRotations + numRotations
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;object.CFrame = rotCF * object.CFrame
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end



&#9;&#9;&#9;-- CODE TO CHECK FOR DRAGGING GHOST PART INTO A COLLIDING STATE
&#9;&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
&#9;
&#9;&#9;&#9;-- need to offset by distance to be dragged
&#9;&#9;&#9;local currModelCFrame
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;-- we assume model has at least one part in it; need to find first part
&#9;&#9;&#9;&#9;i = 1
&#9;&#9;&#9;&#9;while i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;BasePart&quot;) do
&#9;&#9;&#9;&#9;&#9;i = i + 1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;currModelCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
&#9;&#9;&#9;else currModelCFrame = Data.Stamp.CurrentParts[1].CFrame end
&#9;&#9;&#9;minBB = minBB + targetCFrame.p - currModelCFrame.p
&#9;&#9;&#9;maxBB = maxBB + targetCFrame.p - currModelCFrame.p

&#9;&#9;&#9;-- don&apos;t drag into terrain
&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then 
&#9;&#9;&#9;&#9;if lastTargetCFrame then 
&#9;&#9;&#9;&#9;&#9;positionPartsAtCFrame3(thingToDrag, lastTargetCFrame) 
&#9;&#9;&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and (Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA(&quot;Vector3Value&quot;)) then 
&#9;&#9;&#9;&#9;&#9;&#9;local clusterMat = Data.Stamp.CurrentParts[1].ClusterMaterial
&#9;&#9;&#9;&#9;&#9;&#9;clusterMat.Value = Vector3.new(clusterMat.Value.X, clusterMat.Value.Y, lastTargetTerrainOrientation)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), currentSelection, 100)
&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;-- put code back here if we want to prevent stamper from dragging ghost parts into other stamped models (once Region3 fix goes out)
&#9;&#9;&#9;end

&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
&#9;&#9;&#9;lastTargetCFrame = targetCFrame  -- successful positioning, so update &apos;dat cframe
&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and (Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)) and (Data.Stamp.CurrentParts[1].ClusterMaterial:IsA(&quot;Vector3Value&quot;)) then lastTargetTerrainOrientation = Data.Stamp.CurrentParts[1].ClusterMaterial.Value.Z end


&#9;&#9;&#9;-- auto break joints code
&#9;&#9;&#9;if Mouse and Mouse.Target and Mouse.Target.Parent then
&#9;&#9;&#9;&#9;local modelInfo = Mouse.Target:FindFirstChild(&quot;RobloxModel&quot;)
&#9;&#9;&#9;&#9;if not modelInfo then modelInfo = Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local myModelInfo = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;UnstampableFaces&quot;)

&#9;&#9;&#9;&#9;--if (modelInfo and modelInfo.Parent:FindFirstChild(&quot;UnstampableFaces&quot;)) or (modelInfo and myModelInfo) then  -- need better targetSurface calcs
&#9;&#9;&#9;&#9;if (true) then
&#9;&#9;&#9;&#9;&#9;local breakingFaces = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;local myBreakingFaces = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;if modelInfo and modelInfo.Parent:FindFirstChild(&quot;UnstampableFaces&quot;) then breakingFaces = modelInfo.Parent.UnstampableFaces.Value end
&#9;&#9;&#9;&#9;&#9;if myModelInfo then myBreakingFaces = myModelInfo.Value end
&#9;&#9;&#9;&#9;&#9;local hitFace = 0

&#9;&#9;&#9;&#9;&#9;if modelInfo then hitFace = modelTargetSurface(modelInfo.Parent, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p) end

&#9;&#9;&#9;&#9;&#9;-- are we stamping TO an unstampable surface?
&#9;&#9;&#9;&#9;&#9;for bf in string.gmatch(breakingFaces, &quot;[^,]+&quot;) do
&#9;&#9;&#9;&#9;&#9;&#9;if hitFace == tonumber(bf) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- return before we hit the JointsService code below!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unstampableSurface = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- now we have to cast the ray back in the other direction to find the surface we&apos;re stamping FROM
&#9;&#9;&#9;&#9;&#9;hitFace = modelTargetSurface(Data.Stamp.CurrentParts[1], Mouse.Hit.p, game.Workspace.CurrentCamera.CoordinateFrame.p)

&#9;&#9;&#9;&#9;&#9;-- are we stamping WITH an unstampable surface?
&#9;&#9;&#9;&#9;&#9;for bf in string.gmatch(myBreakingFaces, &quot;[^,]+&quot;) do
&#9;&#9;&#9;&#9;&#9;&#9;if hitFace == tonumber(bf) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;unstampableSurface = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.JointsService:ClearJoinAfterMoveJoints() -- clear the JointsService cache
&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MovingLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;-- just need to match breakingFace against targetSurface using rotation supplied by modelCFrame
&#9;&#9;&#9;&#9;&#9;-- targetSurface: 1 is top, 4 is bottom, 
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;end

&#9;&#9;-- to show joints during the mouse move
&#9;&#9;unstampableSurface = false
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

&#9;&#9;-- most common mouse inactive error occurs here, so check mouse active one more time in a pcall
&#9;&#9;if not pcall(function () if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then return true else return false end end) then print(&quot;ERRORED OUT&quot;) game.JointsService:ClearJoinAfterMoveJoints() Mouse = nil Data.Stamp.MovingLock = false return end

      if Mouse and Mouse.Target and Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(Mouse.Target)
      else
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(nil)
      end
      game.JointsService:ShowPermissibleJoints()

&#9;&#9;-- here we allow for a line of high-scalability parts
&#9;&#9;if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and HighScalabilityLine.Start then
&#9;&#9;&#9;HighScalabilityLine.End = Data.Stamp.CurrentParts[1].CFrame.p

&#9;&#9;&#9;local line
&#9;&#9;&#9;local line2 = Vector3.new(0, 0, 0)
&#9;&#9;&#9;local line3 = Vector3.new(0, 0, 0)

&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 then
&#9;&#9;&#9;&#9;-- extract the line from these positions and limit to a 2D plane made from 2 of the world axes
&#9;&#9;&#9;&#9;--   then use dominating axis to limit line to be at 45-degree intervals
&#9;&#9;&#9;&#9;--   will use this internal representation of the line for the actual stamping
&#9;&#9;&#9;&#9;line = (HighScalabilityLine.End - HighScalabilityLine.Start)

&#9;&#9;&#9;&#9;if math.abs(line.X) &lt; math.abs(line.Y) then
&#9;&#9;&#9;&#9;&#9;if math.abs(line.X) &lt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to Y/Z plane, domination unknown
&#9;&#9;&#9;&#9;&#9;&#9;local newY, newZ
&#9;&#9;&#9;&#9;&#9;&#9;if (math.abs(line.Y) &gt; math.abs(line.Z)) then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newY, newZ = truncateToCircleEighth(line.Y, line.Z)
&#9;&#9;&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newZ, newY = truncateToCircleEighth(line.Z, line.Y)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(0, newY, newZ)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Y plane, with Y dominating
&#9;&#9;&#9;&#9;&#9;&#9;local newY, newX = truncateToCircleEighth(line.Y, line.X)
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, newY, 0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;if math.abs(line.Y) &lt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Z plane, domination unknown
&#9;&#9;&#9;&#9;&#9;&#9;local newX, newZ
&#9;&#9;&#9;&#9;&#9;&#9;if math.abs(line.X) &gt; math.abs(line.Z) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newX, newZ = truncateToCircleEighth(line.X, line.Z)
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;newZ, newX = truncateToCircleEighth(line.Z, line.X)
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, 0, newZ)
&#9;&#9;&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;&#9;&#9;-- limit to X/Y plane, with X dominating
&#9;&#9;&#9;&#9;&#9;&#9;local newX, newY = truncateToCircleEighth(line.X, line.Y)
&#9;&#9;&#9;&#9;&#9;&#9;line = Vector3.new(newX, newY, 0)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line

&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 2 then
&#9;&#9;&#9;&#9;line = HighScalabilityLine.MoreLines[1]
&#9;&#9;&#9;&#9;line2 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[1]
&#9;&#9;
&#9;&#9;&#9;&#9;-- take out any component of line2 along line1, so you get perpendicular to line1 component
&#9;&#9;&#9;&#9;line2 = line2 - line.unit*line.unit:Dot(line2)

&#9;&#9;&#9;&#9;tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)

&#9;&#9;&#9;&#9;-- then zero out whichever is the smaller component
&#9;&#9;&#9;&#9;local yAxis = tempCFrame:vectorToWorldSpace(Vector3.new(0, 1, 0))
&#9;&#9;&#9;&#9;local xAxis = tempCFrame:vectorToWorldSpace(Vector3.new(1, 0, 0))
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local xComp = xAxis:Dot(line2)
&#9;&#9;&#9;&#9;local yComp = yAxis:Dot(line2)

&#9;&#9;&#9;&#9;if math.abs(yComp) &gt; math.abs(xComp) then
&#9;&#9;&#9;&#9;&#9;line2 = line2 - xAxis*xComp
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;line2 = line2 - yAxis*yComp
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line2
&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 3 then
&#9;&#9;&#9;&#9;line = HighScalabilityLine.MoreLines[1]
&#9;&#9;&#9;&#9;line2 = HighScalabilityLine.MoreLines[2]
&#9;&#9;&#9;&#9;line3 = HighScalabilityLine.End - HighScalabilityLine.MorePoints[2]

&#9;&#9;&#9;&#9;-- zero out all components of previous lines
&#9;&#9;&#9;&#9;line3 = line3 - line.unit*line.unit:Dot(line3)
&#9;&#9;&#9;&#9;line3 = line3 - line2.unit*line2.unit:Dot(line3)

&#9;&#9;&#9;&#9;HighScalabilityLine.InternalLine = line3
&#9;&#9;&#9;end

&#9;&#9;&#9;-- resize the &quot;line&quot; graphic to be the correct size and orientation
&#9;&#9;&#9;tempCFrame = CFrame.new(HighScalabilityLine.Start, HighScalabilityLine.Start + line)
&#9;&#9;&#9;
&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 then  -- faster calculation for line
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, line.magnitude + 4)
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(Vector3.new(2, 2, 2) - HighScalabilityLine.AdornPart.Size/2)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;local boxSize = tempCFrame:vectorToObjectSpace(line + line2 + line3)
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.Size = Vector3.new(4, 4, 4) + Vector3.new(math.abs(boxSize.X), math.abs(boxSize.Y), math.abs(boxSize.Z))
&#9;&#9;&#9;&#9;HighScalabilityLine.AdornPart.CFrame = tempCFrame + tempCFrame:vectorToWorldSpace(boxSize/2)
&#9;&#9;&#9;end

&#9;&#9;&#9;-- make player able to see this ish
&#9;&#9;&#9;if player then HighScalabilityLine.Adorn.Parent = player.PlayerGui end
&#9;&#9;&#9;if HighScalabilityLine.NewHint then 
&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions == 1 and line and (line.magnitude &gt; 4) then hint(&quot;Press C to stamp in 2D&quot;) HighScalabilityLine.NewHint = false  
&#9;&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 2 and line2 and (line2.magnitude &gt; 4) then hint(&quot;Press C again to stamp in 3D&quot;) HighScalabilityLine.NewHint = false 
&#9;&#9;&#9;&#9;elseif HighScalabilityLine.Dimensions == 3 then HighScalabilityLine.NewHint = false end  -- if we do cyclic, then let them know they&apos;re going back to line stamping
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;Data.Stamp.MovingLock = false

end


function onInsertMouseButton1Down()

&#9;if Data.Stamp.Dragger or Data.Stamp.Decal then
&#9;&#9;Data.Stamp.MouseDown = true
&#9;end

&#9;if (Data.Stamp.CurrentParts and Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) and not eyeDropperConnection then
&#9;&#9;&#9;-- only let them drag if they start dragging on the cluster!
&#9;&#9;&#9;if Mouse and Mouse.Target and Mouse.Target:IsA(&quot;Terrain&quot;) then
&#9;&#9;&#9;&#9;HighScalabilityLine.Dimensions = 1
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = Data.Stamp.CurrentParts[1].CFrame.p
&#9;&#9;&#9;end
&#9;end
end


function cancelAssetPlacement()
&#9;HighScalabilityLine.Start = nil
&#9;HighScalabilityLine.Adorn.Parent = nil

&#9;gInitial90DegreeRotations = 0
&#9;Data.Stamp.Cancelled = true

&#9;if Data.Stamp[&quot;Model&quot;] then
&#9;&#9;Data.Stamp.Model.Parent = nil
&#9;end

&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object.Parent = nil
&#9;&#9;end
&#9;
&#9;&#9;Data.Stamp.CurrentParts.Parent = nil
&#9;end

&#9;if Data.Stamp.DecalSelection then
&#9;&#9;Data.Stamp.DecalSelection:Remove()
&#9;&#9;Data.Stamp.DecalSelection = nil
&#9;end
&#9;if Data.Stamp.Decal then
&#9;&#9;Data.Stamp.Decal:Remove()
&#9;&#9;Data.Stamp.Decal = nil
&#9;end

&#9;if Mouse then
&#9;&#9;Mouse.Icon = &quot;http://www.pengin.xyz/asset?id=66887745&quot;
&#9;end
&#9;game.JointsService:ClearJoinAfterMoveJoints()

end


function collectParts(object, baseParts, scripts, decals)

&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;baseParts[#baseParts+1] = object
&#9;elseif object:IsA(&quot;Script&quot;) then
&#9;&#9;scripts[#scripts+1] = object
&#9;elseif object:IsA(&quot;Decal&quot;) then
&#9;&#9;decals[#decals+1] = object
&#9;end

&#9;for index,child in pairs(object:GetChildren()) do
&#9;&#9;collectParts(child, baseParts, scripts, decals)
&#9;end

end

function getTargetPartBoundingBox(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;return getBoundingBox2(targetPart.Parent)
&#9;else
&#9;&#9;return getBoundingBox2(targetPart)
&#9;end

end


function getBoundingBox2(partOrModel)

-- for models, the bounding box is defined as the minimum and maximum individual part bounding boxes
-- relative to the first part&apos;s coordinate frame.

&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;Part&quot;) or partOrModel:IsA(&quot;WedgePart&quot;) or partOrModel:IsA(&quot;CornerWedgePart&quot;) or partOrModel:IsA(&quot;TrussPart&quot;)then
&#9;&#9;minVec = -0.5 * partOrModel.Size
&#9;&#9;maxVec = -minVec
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;minVec = Vector3.new(-2, -2, -2)
&#9;&#9;maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;if partOrModel:IsA(&quot;Tool&quot;) then part1 = partOrModel.Handle if not part1 then return end end
&#9;&#9;if part1:IsA(&quot;Flag&quot;) then part1 = partOrModel:FindFirstChild(&quot;Part&quot;) if not part1 then return end end
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if (object:IsA(&quot;Part&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;TrussPart&quot;)) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMinInPart1 = part1.CFrame:pointToObjectSpace(boxMinInWorld)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInPart1 = part1.CFrame:pointToObjectSpace(boxMaxInWorld)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInPart1.x &lt; minVec.x then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &lt; minVec.y then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &lt; minVec.z then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInPart1.x &gt; maxVec.x then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.y &gt; maxVec.y then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInPart1.z &gt; maxVec.z then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInPart1.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInPart1.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInPart1.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInPart1.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInPart1.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;-- Adjust bounding box to reflect what the model or part author wants in  terms of justification
&#9;local justifyValue = partOrModel:FindFirstChild(&quot;Justification&quot;)
&#9;if justifyValue ~= nil then
&#9;&#9;-- find the multiple of 4 that contains the model
&#9;&#9;justify = justifyValue.Value
&#9;&#9;two = Vector3.new(2, 2, 2)
&#9;&#9;actualBox = maxVec - minVec - Vector3.new(0.01, 0.01, 0.01)
&#9;&#9;containingGridBox = Vector3.new(4 * math.ceil(actualBox.x/4), 4 * math.ceil(actualBox.y/4), 4 * math.ceil(actualBox.z/4))
&#9;&#9;adjustment = containingGridBox - actualBox
&#9;&#9;minVec = minVec - 0.5 * adjustment * justify
&#9;&#9;maxVec = maxVec + 0.5 * adjustment * (two - justify)
&#9;end

&#9;return minVec, maxVec

end


function getBoundingBoxInWorldCoordinates(partOrModel)
&#9;local minVec = Vector3.new(math.huge, math.huge, math.huge)
&#9;local maxVec = Vector3.new(-math.huge, -math.huge, -math.huge)

&#9;if partOrModel:IsA(&quot;BasePart&quot;)then
&#9;&#9;vec1 = partOrModel.CFrame:pointToWorldSpace(-0.5 * partOrModel.Size)
&#9;&#9;vec2 = partOrModel.CFrame:pointToWorldSpace(0.5 * partOrModel.Size)
&#9;&#9;minVec = Vector3.new(math.min(vec1.X, vec2.X), math.min(vec1.Y, vec2.Y), math.min(vec1.Z, vec2.Z))
&#9;&#9;maxVec = Vector3.new(math.max(vec1.X, vec2.X), math.max(vec1.Y, vec2.Y), math.max(vec1.Z, vec2.Z))
&#9;elseif partOrModel:IsA(&quot;Terrain&quot;) then
&#9;&#9;-- we shouldn&apos;t have to deal with this case
&#9;&#9;--minVec = Vector3.new(-2, -2, -2)
&#9;&#9;--maxVec = Vector3.new(2, 2, 2)
&#9;else
&#9;&#9;local part1 = partOrModel:GetChildren()[1]
&#9;&#9;for i, object in pairs(partOrModel:GetChildren()) do
&#9;&#9;&#9;if object:IsA(&quot;BasePart&quot;) then
&#9;&#9;&#9;&#9;boxMinInWorld = object.CFrame:pointToWorldSpace(-0.5 * object.Size)
&#9;&#9;&#9;&#9;boxMaxInWorld = object.CFrame:pointToWorldSpace(0.5 * object.Size)

&#9;&#9;&#9;&#9;local minX = minVec.x
&#9;&#9;&#9;&#9;local minY = minVec.y
&#9;&#9;&#9;&#9;local minZ = minVec.z
&#9;&#9;&#9;&#9;local maxX = maxVec.x
&#9;&#9;&#9;&#9;local maxY = maxVec.y
&#9;&#9;&#9;&#9;local maxZ = maxVec.z
&#9;&#9;&#9;&#9;if boxMinInWorld.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &lt; minX then
&#9;&#9;&#9;&#9;&#9;minX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &lt; minY then
&#9;&#9;&#9;&#9;&#9;minY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &lt; minZ then
&#9;&#9;&#9;&#9;&#9;minZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;if boxMinInWorld.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMinInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMinInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMinInWorld.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMinInWorld.z
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.x &gt; maxX then
&#9;&#9;&#9;&#9;&#9;maxX = boxMaxInWorld.x
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.y &gt; maxY then
&#9;&#9;&#9;&#9;&#9;maxY = boxMaxInWorld.y
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if boxMaxInWorld.z &gt; maxZ then
&#9;&#9;&#9;&#9;&#9;maxZ = boxMaxInWorld.z
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;minVec = Vector3.new(minX, minY, minZ)
&#9;&#9;&#9;&#9;maxVec = Vector3.new(maxX, maxY, maxZ)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return minVec, maxVec
end


function getClosestAlignedWorldDirection(aVector3InWorld)

&#9;local xDir = Vector3.new(1,0,0)
&#9;local yDir = Vector3.new(0,1,0)
&#9;local zDir = Vector3.new(0,0,1)
&#9;local xDot = aVector3InWorld.x * xDir.x + aVector3InWorld.y * xDir.y + aVector3InWorld.z * xDir.z
&#9;local yDot = aVector3InWorld.x * yDir.x + aVector3InWorld.y * yDir.y + aVector3InWorld.z * yDir.z
&#9;local zDot = aVector3InWorld.x * zDir.x + aVector3InWorld.y * zDir.y + aVector3InWorld.z * zDir.z

&#9;if math.abs(xDot) &gt; math.abs(yDot) and math.abs(xDot) &gt; math.abs(zDot) then
&#9;&#9;if xDot &gt; 0 then
&#9;&#9;&#9;return 0
&#9;&#9;else
&#9;&#9;&#9;return 3
&#9;&#9;end
&#9;elseif math.abs(yDot) &gt; math.abs(xDot) and math.abs(yDot) &gt; math.abs(zDot) then
&#9;&#9;if yDot &gt; 0 then
&#9;&#9;&#9;return 1
&#9;&#9;else
&#9;&#9;&#9;return 4
&#9;&#9;end
&#9;else
&#9;&#9;if zDot &gt; 0 then
&#9;&#9;&#9;return 2
&#9;&#9;else
&#9;&#9;&#9;return 5
&#9;&#9;end
&#9;end 

end


function getMouseTargetCFrame(targetPart)

&#9;if targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) ~= nil then
&#9;&#9;if targetPart.Parent:IsA(&quot;Tool&quot;) then return targetPart.Parent.Handle.CFrame
&#9;&#9;else return targetPart.Parent:GetChildren()[1].CFrame end
&#9;else
&#9;&#9;return targetPart.CFrame
&#9;end

end


function surfaceToVector(surf)
&#9;local vect = 1
&#9;if surf &lt; 0 then
&#9;&#9;surf = surf * -1
&#9;&#9;vect = vect * -1
&#9;end
&#9;if surf == 1 then return vect*Vector3.new(1, 0, 0)
&#9;elseif surf == 2 then return vect*Vector3.new(0, 1, 0)
&#9;elseif surf == 3 then return vect*Vector3.new(0, 0, 1)
&#9;elseif Mouse then return Vector3.FromNormalId(Mouse.TargetSurface) end  -- if we somehow got a &quot;0&quot;, then we just revert to old behavior
&#9;return Vector3.new(0,0,0)
end

function findConfigAtMouseTarget(partsTable)

-- *Critical Assumption* :
--&#9;&#9;&#9;&#9;This function assumes the target CF axes are orthogonal with the target bounding box faces
--&#9;&#9;&#9;&#9;And, it assumes the insert CF axes are orthongonal with the insert bounding box faces
--&#9;&#9;&#9;&#9;Therefore, insertion will not work with angled faces on wedges or other &quot;non-block&quot; parts, nor
--&#9;&#9;&#9;&#9;will it work for parts in a model that are not orthogonally aligned with the model&apos;s CF.

&#9;local grid = 4.0
&#9;local admissibleConfig = false
&#9;local targetConfig = CFrame.new(0,0,0)

&#9;local minBB, maxBB = getBoundingBox2(Data.Stamp.CurrentParts[1])
&#9;local diagBB = maxBB - minBB

&#9;local insertCFrame
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;i = 1
&#9;&#9;while (i &lt; (#Data.Stamp.CurrentParts[1]:GetChildren()) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;Part&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;TrussPart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;WedgePart&quot;) and not Data.Stamp.CurrentParts[1]:GetChildren()[i]:IsA(&quot;CornerWedgePart&quot;)) do
&#9;&#9;&#9;i = i + 1
&#9;&#9;end
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1]:GetChildren()[i].CFrame
&#9;else
&#9;&#9;insertCFrame = Data.Stamp.CurrentParts[1].CFrame
&#9;end

&#9;if not isRestricted and Mouse then
&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then Mouse.TargetFilter = Data.Stamp.CurrentParts[1].Handle
&#9;&#9;else Mouse.TargetFilter = Data.Stamp.CurrentParts[1] end
&#9;end

&#9;local targetPart = nil
&#9;local success = pcall(function() targetPart = Mouse.Target end)

&#9;if not success or targetPart == nil then
&#9;&#9;return admissibleConfig, targetConfig
&#9;end

&#9;-- test mouse hit location
&#9;local minBBTarget, maxBBTarget = getTargetPartBoundingBox(targetPart)
&#9;local diagBBTarget = maxBBTarget - minBBTarget
&#9;local targetCFrame = getMouseTargetCFrame(targetPart)
&#9;local hitCFrame = CFrame.new(0,0,0)
&#9;if Mouse then
&#9;&#9;hitCFrame = Mouse.Hit
&#9;end
&#9;local mouseHitInWorld = hitCFrame.p

&#9;-- find which axis of the insertion objects should match with the target surface
&#9;-- this should use targetPart CFrame, not the model CFrame

&#9;--[[ attempt at fixing Mouse.TargetSurface below...
&#9;local targetModel = targetPart
&#9;if not targetPart:FindFirstChild(&quot;RobloxModel&quot;) and targetPart.Parent and targetPart.Parent:FindFirstChild(&quot;RobloxModel&quot;) then targetModel = targetPart.Parent end
&#9;local correctedTargetSurfaceVector = surfaceToVector(modelTargetSurface(targetModel, game.Workspace.CurrentCamera.CoordinateFrame.p, mouseHitInWorld))
&#9;local targetVectorInWorld = targetPart.CFrame:vectorToWorldSpace(correctedTargetSurfaceVector)
&#9;--]]

&#9;if targetPart:IsA(&quot;Terrain&quot;) then
&#9;&#9;if not cluster then cluster = game.Workspace.Terrain end

&#9;&#9;cellID = cluster:WorldToCellPreferSolid(mouseHitInWorld)
&#9;&#9;targetCFrame = CFrame.new(cluster:CellCenterToWorld(cellID.x, cellID.y, cellID.z))
&#9;end
&#9;
&#9;local mouseHitInTarget = targetCFrame:pointToObjectSpace(mouseHitInWorld)
&#9;local targetVectorInWorld = Vector3.new(0,0,0)
&#9;if Mouse then
&#9;&#9;targetVectorInWorld = targetCFrame:vectorToWorldSpace(Vector3.FromNormalId(Mouse.TargetSurface))
&#9;end


&#9;local targetRefPointInTarget
&#9;local clampToSurface

&#9;if getClosestAlignedWorldDirection(targetVectorInWorld) == 0 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 3 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(0,1,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 1 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)&#9;&#9;
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 4 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, 1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,0,1)
&#9;elseif getClosestAlignedWorldDirection(targetVectorInWorld) == 2 then
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(-1, -1, 1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(-1, -1, -1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;else
&#9;&#9;targetRefPointInTarget = targetCFrame:vectorToObjectSpace(Vector3.new(1, -1, -1))
&#9;&#9;insertRefPointInInsert = insertCFrame:vectorToObjectSpace(Vector3.new(1, -1, 1))
&#9;&#9;clampToSurface = Vector3.new(1,1,0)
&#9;end

&#9;targetRefPointInTarget = targetRefPointInTarget * (0.5 * diagBBTarget) + 0.5 * (maxBBTarget + minBBTarget)
&#9;insertRefPointInInsert = insertRefPointInInsert * (0.5 * diagBB) + 0.5 * (maxBB + minBB)
&#9;
&#9;-- To Do: For cases that are not aligned to the world grid, account for the minimal rotation
&#9;-- needed to bring the Insert part(s) into alignment with the Target Part
&#9;-- Apply the rotation here

&#9;local delta = mouseHitInTarget - targetRefPointInTarget
&#9;local deltaClamped = Vector3.new(grid * math.modf(delta.x/grid), grid * math.modf(delta.y/grid), grid * math.modf(delta.z/grid))
&#9;deltaClamped = deltaClamped * clampToSurface
&#9;local targetTouchInTarget = deltaClamped + targetRefPointInTarget

&#9;local TargetTouchRelToWorld = targetCFrame:pointToWorldSpace(targetTouchInTarget)
&#9;local InsertTouchInWorld = insertCFrame:vectorToWorldSpace(insertRefPointInInsert)
&#9;local posInsertOriginInWorld = TargetTouchRelToWorld - InsertTouchInWorld

&#9;local x, y, z, R00, R01, R02, R10, R11, R12, R20, R21, R22 = insertCFrame:components()
&#9;targetConfig = CFrame.new(posInsertOriginInWorld.x, posInsertOriginInWorld.y, posInsertOriginInWorld.z, R00, R01, R02, R10, R11, R12, R20, R21, R22)
&#9;admissibleConfig = true

&#9;return admissibleConfig, targetConfig, getClosestAlignedWorldDirection(targetVectorInWorld)

end

function checkPartLimit()

&#9;local numPoints = player.PointsUsed.Value
&#9;local maxPoints = player.MaxPoints.Value

&#9;if numPoints &lt; maxPoints then
&#9;&#9;return true
&#9;else
&#9;&#9;return false
&#9;end

&#9;return true
end

function setupDraggableClone()
&#9;if eyeDropperConnection then eyeDropperConnection:disconnect() eyeDropperConnection = nil end

&#9;--if not Mouse.Target then return end
&#9;click.Value = false

&#9;if Data.Stamp.CurrentParts then
&#9;&#9;for i = 1, #Data.Stamp.CurrentParts do
&#9;&#9;&#9;if Data.Stamp.CurrentParts[i].Parent ~= nil then
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[i].Parent = partModel
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;
&#9;if Data.Stamp[&quot;Model&quot;] == nil then return end

&#9;local clone = Data.Stamp.Model:Clone()
&#9;local scripts = {}
&#9;local parts = {}
&#9;local decals = {}
&#9;
&#9;collectParts(clone, parts, scripts, decals)

&#9;if #parts &gt; 0 then
&#9;&#9;Data.Stamp.DisabledScripts = {}
&#9;&#9;Data.Stamp.TransparencyTable = {}
&#9;&#9;Data.Stamp.MaterialTable = {}
&#9;&#9;Data.Stamp.CanCollideTable = {}
&#9;&#9;Data.Stamp.AnchoredTable = {}
&#9;&#9;Data.Stamp.DecalTransparencyTable = {}

&#9;&#9;for index,script in pairs(scripts) do
&#9;&#9;&#9;if not(script.Disabled) then
&#9;&#9;&#9;&#9;script.Disabled = true
&#9;&#9;&#9;&#9;Data.Stamp.DisabledScripts[#Data.Stamp.DisabledScripts +1] = script
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;for index, part in pairs(parts) do
&#9;&#9;&#9;Data.Stamp.TransparencyTable[part] = part.Transparency
&#9;&#9;&#9;part.Transparency = gStaticTrans + (1-gStaticTrans)*part.Transparency
&#9;&#9;&#9;Data.Stamp.MaterialTable[part] = part.Material
&#9;&#9;&#9;part.Material = Enum.Material.Plastic
&#9;&#9;&#9;Data.Stamp.CanCollideTable[part] = part.CanCollide
&#9;&#9;&#9;part.CanCollide = false
&#9;&#9;&#9;Data.Stamp.AnchoredTable[part] = part.Anchored
&#9;&#9;&#9;part.Anchored = true
&#9;&#9;&#9;part.archivable = false

&#9;&#9;&#9;delay(0,function()
&#9;&#9;&#9;&#9;local con = nil
&#9;&#9;&#9;&#9;local exitLoop = false
&#9;&#9;&#9;&#9;con = click.Changed:connect(function()
&#9;&#9;&#9;&#9;&#9;if click.Value then
&#9;&#9;&#9;&#9;&#9;&#9;con:disconnect()
&#9;&#9;&#9;&#9;&#9;&#9;exitLoop = true
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;&#9;wait(fadeInDelayTime) -- give it some time to be completely transparent

&#9;&#9;&#9;&#9;if exitLoop then return end -- if we already stamped, we don&apos;t need to do the rest of this
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local begTime = tick()
&#9;&#9;&#9;&#9;local currTime = begTime
&#9;&#9;&#9;&#9;while (currTime - begTime) &lt; transFadeInTime and part and part:IsA(&quot;BasePart&quot;) and part.Transparency &gt; gDesiredTrans and not exitLoop do
&#9;&#9;&#9;&#9;&#9;local newTrans = 1 - (((currTime - begTime)/transFadeInTime) * (gStaticTrans - gDesiredTrans))
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.TransparencyTable[part] then part.Transparency = newTrans + (1-newTrans) * Data.Stamp.TransparencyTable[part] end
&#9;&#9;&#9;&#9;&#9;wait(0.03)
&#9;&#9;&#9;&#9;&#9;currTime = tick()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if part and part:IsA(&quot;BasePart&quot;) and not exitLoop then
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.TransparencyTable[part] then part.Transparency = gDesiredTrans + (1-gDesiredTrans)*Data.Stamp.TransparencyTable[part] end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if con then con:disconnect() end
&#9;&#9;&#9;end)
&#9;&#9;end

&#9;&#9;for index, decal in pairs(decals) do
&#9;&#9;&#9;Data.Stamp.DecalTransparencyTable[decal] = decal.Transparency
&#9;&#9;&#9;decal.Transparency = gDesiredTrans + (1-gDesiredTrans)*decal.Transparency
&#9;&#9;end
&#9;&#9;
&#9;&#9;clone.Parent = game.Workspace

&#9;&#9;-- For Restricting Stamper Tool
&#9;&#9;if(isRestricted) then

&#9;&#9;&#9;-- mark a particular spot in BaseplateBumpers, so we can remove any stragglers later, when player leaves
&#9;&#9;&#9;local cloneInsertionSpot = game.Workspace.BaseplateBumpers:FindFirstChild(player.Name)
&#9;&#9;&#9;if cloneInsertionSpot == nil then
&#9;&#9;&#9;&#9;cloneInsertionSpot = Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;&#9;cloneInsertionSpot.Name = player.Name
&#9;&#9;&#9;&#9;cloneInsertionSpot.Parent = game.Workspace.BaseplateBumpers
&#9;&#9;&#9;end

&#9;&#9;&#9;clone.Parent = cloneInsertionSpot
&#9;&#9;end

&#9;&#9;-- disable all seats
&#9;&#9;setSeatEnabledStatus(clone, true)
&#9;&#9;setSeatEnabledStatus(clone, false)

&#9;&#9;Data.Stamp.CurrentParts = clone:GetChildren()

&#9;&#9;-- if auto-alignable, we enforce a pre-rotation to the canonical &quot;0-frame&quot;
&#9;&#9;if autoAlignToFace() then
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1].PrimaryPart then modelInverse = Data.Stamp.CurrentParts[1].PrimaryPart.CFrame:inverse()
&#9;&#9;&#9;else modelInverse = Data.Stamp.CurrentParts[1]:GetModelCFrame():inverse() end
&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then object.CFrame = modelInverse*object.CFrame end
&#9;&#9;&#9;end
&#9;&#9;&#9;gInitial90DegreeRotations = 0
&#9;&#9;else

&#9;&#9;-- pre-rotate if necessary
&#9;&#9;local ry = gInitial90DegreeRotations * math.pi/2
&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0) 
&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then object.CFrame = rotCF * object.CFrame end
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;end
&#9;&#9;end

&#9;&#9;-- After rotating, update the position
&#9;&#9;configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;if configFound then
&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.TransparencyTable, targetCFrame)
&#9;&#9;end
&#9;&#9;-- to show joints during the mouse move
      game.JointsService:SetJoinAfterMoveInstance(Data.Stamp.CurrentParts[1])

&#9;&#9;local mouseTarget = nil
&#9;&#9;pcall(function() mouseTarget = Mouse.Target end)

      if mouseTarget and mouseTarget.Parent:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(mouseTarget)
      else
&#9;&#9;&#9;game.JointsService:SetJoinAfterMoveTarget(nil)
&#9;&#9;end
      game.JointsService:ShowPermissibleJoints()

&#9;&#9;for index, object in pairs(Data.Stamp.CurrentParts) do
&#9;&#9;&#9;object.Parent = clone.Parent
&#9;&#9;end

&#9;&#9;clone:Remove()

&#9;&#9;lastTargetCFrame = nil

&#9;
&#9;&#9;if billBoardOwnerGui then
&#9;&#9;&#9;if #parts == 1 then
&#9;&#9;&#9;&#9;billBoardOwnerGui.Parent = parts[1]
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;billBoardOwnerGui.Parent = parts[1].Parent
&#9;&#9;&#9;end
&#9;&#9;end

&#9;&#9;HighScalabilityLine.NewHint = true -- show hint if they start dragging a high-scalability part

&#9;&#9;Data.Stamp.Dragger = Instance.new(&quot;Dragger&quot;)
&#9;&#9;--Begin a movement by faking a MouseDown signal
&#9;&#9;Data.Stamp.Dragger:MouseDown(parts[1], Vector3.new(0,0,0), parts)
&#9;&#9;Data.Stamp.Dragger:MouseUp()
&#9;else
&#9;&#9;--Nothing draggable in the Model
&#9;&#9;Data.Stamp.Model:Remove()
&#9;&#9;Data.Stamp.Model = nil
&#9;&#9;Data.Stamp.TransparencyTable = nil
&#9;&#9;Data.Stamp.MaterialTable = nil
&#9;&#9;Data.Stamp.CanCollideTable = nil
&#9;&#9;Data.Stamp.AnchoredTable = nil
&#9;&#9;Data.Stamp.DisabledScripts = nil
&#9;end

end


function noManualWelds(part)
&#9;local partChildren = part:GetChildren()
&#9;for i = 1, #partChildren do
&#9;&#9;if partChildren[i]:IsA(&quot;ManualWeld&quot;) or partChildren[i]:IsA(&quot;Rotate&quot;) then
&#9;&#9;&#9;return false
&#9;&#9;end
&#9;end
&#9;return true
end

local debris = game:GetService(&quot;Debris&quot;)
function flashRedBox()
&#9;errorBox.Parent = player.PlayerGui
&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then errorBox.Adornee = Data.Stamp.CurrentParts[1].Handle
&#9;else errorBox.Adornee = Data.Stamp.CurrentParts[1] end

&#9;delay(0,function()
&#9;&#9;for i = 1, 3 do
&#9;&#9;&#9;errorBox.Visible = true
&#9;&#9;&#9;wait(0.13)
&#9;&#9;&#9;errorBox.Visible = false
&#9;&#9;&#9;wait(0.13)
&#9;&#9;end
&#9;&#9;errorBox.Adornee = nil
&#9;&#9;errorBox.Parent = Tool
&#9;end)
end


-- below function should work as a Region3 query, returning true if a single cluster part is within this region
function clusterPartsInRegion(startVector, endVector)

&#9;if not cluster then return false end

&#9;local startCell = cluster:WorldToCell(startVector)
&#9;local endCell = cluster:WorldToCell(endVector)

&#9;local startX = startCell.X
&#9;local startY = startCell.Y
&#9;local startZ = startCell.Z

&#9;local endX = endCell.X
&#9;local endY = endCell.Y
&#9;local endZ = endCell.Z

&#9;if startX &lt; cluster.MaxExtents.Min.X then startX = cluster.MaxExtents.Min.X end
&#9;if startY &lt; cluster.MaxExtents.Min.Y then startY = cluster.MaxExtents.Min.Y end
&#9;if startZ &lt; cluster.MaxExtents.Min.Z then startZ = cluster.MaxExtents.Min.Z end

&#9;if endX &gt; cluster.MaxExtents.Max.X then endX = cluster.MaxExtents.Max.X end
&#9;if endY &gt; cluster.MaxExtents.Max.Y then endY = cluster.MaxExtents.Max.Y end
&#9;if endZ &gt; cluster.MaxExtents.Max.Z then endZ = cluster.MaxExtents.Max.Z end

&#9;for x = startX, endX do
&#9;&#9;for y = startY, endY do
&#9;&#9;&#9;for z = startZ, endZ do
&#9;&#9;&#9;&#9;if (cluster:GetCell(x, y, z).Value) &gt; 0 then return true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;return false
end

-- helper function to determine if a character can be pushed upwards by a certain amount
-- character is 5 studs tall, we&apos;ll check a 1.5 x 1.5 x 4.5 box around char, with center .5 studs below torsocenter
function spaceAboveCharacter(charTorso, newTorsoY)
&#9;local partsAboveChar = game.Workspace:FindPartsInRegion3(Region3.new(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)), charTorso.Parent, 100)
&#9;for j = 1, #partsAboveChar do
&#9;&#9;if partsAboveChar[j].CanCollide and not partsAboveChar[j]:IsDescendantOf(Data.Stamp.CurrentParts[1]) then return false end
&#9;end

&#9;if clusterPartsInRegion(Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) - Vector3.new(.75, 2.75, .75), Vector3.new(charTorso.Position.X, newTorsoY, charTorso.Position.Z) + Vector3.new(.75, 1.75, .75)) then return false end

&#9;return true
end


-- returns whether or not we want to cancel the stamp because we&apos;re blocked by this part
function isBlocker(part)
&#9;if not part then return false end
&#9;if not part.Parent then return false end
&#9;if part:FindFirstChild(&quot;Humanoid&quot;) then return false end
&#9;if part:FindFirstChild(&quot;RobloxStamper&quot;) or part:FindFirstChild(&quot;RobloxModel&quot;) then return true end
&#9;if part:IsA(&quot;Part&quot;) and not part.CanCollide then return false end
&#9;if part == game.Workspace then return true end
&#9;if part == game.Lighting then return false end
&#9;return isBlocker(part.Parent)
end

function onInsertMouseButton1Up()
&#9;if guiScriptIsLoadingSomething or variables.InsertAsset.Updated.Value then return end -- don&apos;t try to stamp while we&apos;re loading!

&#9;if eyeDropperConnection then 
&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;eyeDropperConnection = nil
&#9;&#9;return
&#9;end

&#9;if Data.Stamp.MouseDown then
&#9;&#9;Data.Stamp.MouseDown = false
&#9;&#9;if Data.Stamp.Dragger then

&#9;&#9;&#9;--Place the object where the mouse is currently positioned
&#9;&#9;&#9;-- For Restricting Stamper Tool

&#9;&#9;&#9;while Data.Stamp.MouseLock do wait() end
&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;Data.Stamp.MouseLock = true

&#9;&#9;&#9;if(isRestricted) then
&#9;&#9;&#9;&#9;-- if player tries to stamp out of bounds, tell them they can&apos;t
&#9;&#9;&#9;&#9;if not inBounds(Data.Stamp.TransparencyTable) then
&#9;&#9;&#9;&#9;&#9;variables.ShowInvalidPlacement.Value = true
&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- if unstampable face, then don&apos;t let us stamp there!
&#9;&#9;&#9;if unstampableSurface then
&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;flashRedBox()
&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Prevent part from being stamped on top of a player

&#9;&#9;&#9;local minBB, maxBB = getBoundingBoxInWorldCoordinates(Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;local configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)

&#9;&#9;&#9;if configFound and not HighScalabilityLine.Adorn.Parent then
&#9;&#9;&#9;&#9;if clusterPartsInRegion(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector) then Data.Stamp.MouseLock = false flashRedBox() return end

&#9;&#9;&#9;&#9;local blockingParts = game.Workspace:FindPartsInRegion3(Region3.new(minBB+insertBoundingBoxOverlapVector, maxBB-insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)
&#9;&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;&#9;-- below if we only want to block stamping on self
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b].Parent == script.Parent.Parent then return end
&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;-- below if we want to block stamping on self and also stamping that intersects a model we&apos;ve previously stamped on our baseplate
&#9;&#9;&#9;&#9;&#9;--&#9;&#9;  should work as soon as Region3 queries are fixed
&#9;&#9;&#9;&#9;&#9;--      NOTE TO SELF:  See if partModel applies when isRestricted is false
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b]:IsDescendantOf(partModel) or blockingParts[b].Parent == script.Parent.Parent then Data.Stamp.MouseLock = false flashRedBox() break end --return end
&#9;&#9;&#9;&#9;&#9;if isBlocker(blockingParts[b]) then Data.Stamp.MouseLock = false flashRedBox() return end-- still error if overlapping another model [should return here too!]
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;local alreadyPushedUp = {}
&#9;&#9;&#9;&#9;-- if no blocking model below, then see if stamping on top of a character
&#9;&#9;&#9;&#9;for b = 1, #blockingParts do
&#9;&#9;&#9;&#9;&#9;--if blockingParts[b].Parent == script.Parent.Parent then
--&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = script.Parent.Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;if blockingParts[b].Parent and not alreadyPushedUp[blockingParts[b].Parent] and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and blockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = blockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;alreadyPushedUp[blockingParts[b].Parent] = true

&#9;&#9;&#9;&#9;&#9;&#9;if blockingPersonTorso then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newY = maxBB.Y + 3
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if spaceAboveCharacter(blockingPersonTorso, newY) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no space, we just error
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;flashRedBox()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- should return here too!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;--break
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;elseif (not configFound) then
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false 
&#9;&#9;&#9;&#9;return 
&#9;&#9;&#9;end -- if no config then don&apos;t stamp!

&#9;&#9;&#9;-- something will be stamped!  so set the &quot;StampedSomething&quot; toggle to true
&#9;&#9;&#9;local localChar = game.Players.LocalPlayer.Character
&#9;&#9;&#9;if localChar then
&#9;&#9;&#9;&#9;local stampTracker = localChar:FindFirstChild(&quot;StampTracker&quot;)
&#9;&#9;&#9;&#9;if stampTracker and not stampTracker.Value then stampTracker.Value = true end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- also, show hints again if high scalability part
&#9;&#9;&#9;HighScalabilityLine.NewHint = true

&#9;&#9;&#9;if Data.Stamp.Model and Data.Stamp.Model:GetChildren()[1] and Data.Stamp.Model:GetChildren()[1].Name == &quot;MegaClusterCube&quot; then
&#9;&#9;&#9;&#9;&#9;local line = HighScalabilityLine.InternalLine
&#9;&#9;&#9;&#9;&#9;local cMax = game.Workspace.Terrain.MaxExtents.Max
&#9;&#9;&#9;&#9;&#9;local cMin = game.Workspace.Terrain.MaxExtents.Min

&#9;&#9;&#9;&#9;&#9;local clusterMaterial = 1 -- default is grass
&#9;&#9;&#9;&#9;&#9;local clusterType = 0 -- default is brick
&#9;&#9;&#9;&#9;&#9;local clusterOrientation = 0 -- default is 0 rotation

&#9;&#9;&#9;&#9;&#9;local autoWedgeClusterParts = false
&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;AutoWedge&quot;) then autoWedgeClusterParts = true end

&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = Data.Stamp.CurrentParts[1].ClusterMaterial
&#9;&#9;&#9;&#9;&#9;&#9;if (clusterMaterial:IsA(&quot;Vector3Value&quot;)) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- extract all info from vector
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterType = clusterMaterial.Value.Y
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterOrientation = clusterMaterial.Value.Z
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = clusterMaterial.Value.X
&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;clusterMaterial = clusterMaterial.Value
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;
&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Adorn.Parent and HighScalabilityLine.Start and ((HighScalabilityLine.Dimensions &gt; 1) or (line and line.magnitude &gt; 0)) then
&#9;&#9;&#9;&#9;&#9;&#9;local startCell = game.Workspace.Terrain:WorldToCell(HighScalabilityLine.Start)

&#9;&#9;&#9;&#9;&#9;&#9;local xInc = {0,0,0}
&#9;&#9;&#9;&#9;&#9;&#9;local yInc = {0,0,0}
&#9;&#9;&#9;&#9;&#9;&#9;local zInc = {0,0,0}
&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;local incrementVect = {nil, nil, nil}
&#9;&#9;&#9;&#9;&#9;&#9;local stepVect = {Vector3.new(0, 0, 0), Vector3.new(0, 0, 0), Vector3.new(0, 0, 0)}

&#9;&#9;&#9;&#9;&#9;&#9;local worldAxes = {Vector3.new(1, 0, 0), Vector3.new(0, 1, 0), Vector3.new(0, 0, 1)}

&#9;&#9;&#9;&#9;&#9;&#9;local lines = {}
&#9;&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions &gt; 1 then table.insert(lines, HighScalabilityLine.MoreLines[1]) end
&#9;&#9;&#9;&#9;&#9;&#9;if line and line.magnitude &gt; 0 then table.insert(lines, line) end
&#9;&#9;&#9;&#9;&#9;&#9;if HighScalabilityLine.Dimensions &gt; 2 then table.insert(lines, HighScalabilityLine.MoreLines[2]) end

&#9;&#9;&#9;&#9;&#9;&#9;for i = 1, #lines do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;lines[i] = Vector3.new(math.floor(lines[i].X+.5), math.floor(lines[i].Y+.5), math.floor(lines[i].Z+.5)) -- round to integers

&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].X &gt; 0 then xInc[i] = 1 elseif lines[i].X &lt; 0 then xInc[i] = -1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].Y &gt; 0 then yInc[i] = 1 elseif lines[i].Y &lt; 0 then yInc[i] = -1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lines[i].Z &gt; 0 then zInc[i] = 1 elseif lines[i].Z &lt; 0 then zInc[i] = -1 end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;incrementVect[i] = Vector3.new(xInc[i], yInc[i], zInc[i])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[i].magnitude &lt; .9 then incrementVect[i] = nil end
&#9;&#9;&#9;&#9;&#9;&#9;end


&#9;&#9;&#9;&#9;&#9;&#9;if not lines[2] then lines[2] = Vector3.new(0, 0, 0) end
&#9;&#9;&#9;&#9;&#9;&#9;if not lines[3] then lines[3] = Vector3.new(0, 0, 0) end

&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[3].magnitude*4 &lt;= lines[3].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local outerStepVectIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;while outerStepVectIndex &lt; 4 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[2] = Vector3.new(0, 0, 0)
&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[2].magnitude*4 &lt;= lines[2].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local innerStepVectIndex = 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;while innerStepVectIndex &lt; 4 do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[1] = Vector3.new(0, 0, 0)
&#9;&#9;&#9;&#9;&#9;&#9;while (stepVect[1].magnitude*4 &lt;= lines[1].magnitude) do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local stepVectSum = stepVect[1] + stepVect[2] + stepVect[3]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellPos = Vector3int16.new(startCell.X + stepVectSum.X, startCell.Y + stepVectSum.Y, startCell.Z + stepVectSum.Z)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- check if overlaps player or part:
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cellPos.X, cellPos.Y, cellPos.Z)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local cellBlockingParts = game.Workspace:FindPartsInRegion3(Region3.new(cellCenter - Vector3.new(2, 2, 2) + insertBoundingBoxOverlapVector, cellCenter + Vector3.new(2, 2, 2) - insertBoundingBoxOverlapVector), Data.Stamp.CurrentParts[1], 100)

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local skipThisCell = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for b = 1, #cellBlockingParts do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if isBlocker(cellBlockingParts[b]) then skipThisCell = true break end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not skipThisCell then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- pop players up above any set cells
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local alreadyPushedUp = {}
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no blocking model below, then see if stamping on top of a character
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;for b = 1, #cellBlockingParts do
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if cellBlockingParts[b].Parent and not alreadyPushedUp[cellBlockingParts[b].Parent] and cellBlockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;) and cellBlockingParts[b].Parent:FindFirstChild(&quot;Humanoid&quot;):IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local blockingPersonTorso = cellBlockingParts[b].Parent:FindFirstChild(&quot;Torso&quot;)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;alreadyPushedUp[cellBlockingParts[b].Parent] = true

&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if blockingPersonTorso then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if so, let&apos;s push the person upwards so they pop on top of the stamped model/part (but only if there&apos;s space above them)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;local newY = cellCenter.Y + 5
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if spaceAboveCharacter(blockingPersonTorso, newY) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;blockingPersonTorso.CFrame = blockingPersonTorso.CFrame + Vector3.new(0, newY - blockingPersonTorso.CFrame.p.Y, 0)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- if no space, we just skip this one
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;skipThisCell = true
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if not skipThisCell then  -- if we STILL aren&apos;t skipping...  then we&apos;re good to go!
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- set it
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- auto-wedge it?
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (autoWedgeClusterParts) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[1] = stepVect[1] + incrementVect[1]
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[2] then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;while innerStepVectIndex &lt; 4 and worldAxes[innerStepVectIndex]:Dot(incrementVect[2]) == 0 do innerStepVectIndex = innerStepVectIndex + 1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if innerStepVectIndex &lt; 4 then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[2] = stepVect[2] + worldAxes[innerStepVectIndex]*worldAxes[innerStepVectIndex]:Dot(incrementVect[2])
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;innerStepVectIndex = innerStepVectIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else stepVect[2] = Vector3.new(1, 0, 0) innerStepVectIndex = 4 end -- skip all remaining loops
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (stepVect[2].magnitude*4 &gt; lines[2].magnitude) then innerStepVectIndex = 4 end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait()
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if incrementVect[3] then 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;while outerStepVectIndex &lt; 4 and worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) == 0 do outerStepVectIndex = outerStepVectIndex + 1 end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if outerStepVectIndex &lt; 4 then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;stepVect[3] = stepVect[3] + worldAxes[outerStepVectIndex]*worldAxes[outerStepVectIndex]:Dot(incrementVect[3]) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;outerStepVectIndex = outerStepVectIndex + 1
&#9;&#9;&#9;&#9;&#9;&#9;&#9;else stepVect[3] = Vector3.new(1, 0, 0) outerStepVectIndex = 4 end -- skip all remaining loops
&#9;&#9;&#9;&#9;&#9;&#9;&#9;if (stepVect[3].magnitude*4 &gt; lines[3].magnitude) then outerStepVectIndex = 4 end
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;-- and also get rid of any HighScalabilityLine stuff if it&apos;s there
&#9;&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil
&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;-- not High-Scalability-Line-Based, so behave normally [and get rid of any HSL stuff]
&#9;&#9;&#9;&#9;HighScalabilityLine.Start = nil
&#9;&#9;&#9;&#9;HighScalabilityLine.Adorn.Parent = nil

&#9;&#9;&#9;&#9;-- if target point is in cluster, just use cluster:SetCell
&#9;&#9;&#9;&#9;if cluster then
&#9;&#9;&#9;&#9;&#9;-- if targetCFrame is inside cluster, just set that cell to 1 and return
&#9;&#9;&#9;&#9;&#9;local cellPos = cluster:WorldToCell(targetCFrame.p)

&#9;&#9;&#9;&#9;&#9;if cellPos.X &gt;= cMin.X and cellPos.Y &gt;= cMin.Y and cellPos.Z &gt;= cMin.Z and cellPos.X &lt; cMax.X and cellPos.Y &lt; cMax.Y and cellPos.Z &lt; cMax.Z then
&#9;&#9;&#9;&#9;&#9;&#9;cluster:SetCell(cellPos.X, cellPos.Y, cellPos.Z, clusterMaterial, clusterType, clusterOrientation)

&#9;&#9;&#9;&#9;&#9;&#9;-- auto-wedge it
&#9;&#9;&#9;&#9;&#9;&#9;if (autoWedgeClusterParts) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;game.Workspace.Terrain:AutowedgeCells(Region3int16.new(Vector3int16.new(cellPos.x - 1, cellPos.y - 1, cellPos.z - 1), Vector3int16.new(cellPos.x + 1, cellPos.y + 1, cellPos.z + 1)))
&#9;&#9;&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;&#9;&#9;&#9;Data.Stamp.MouseLock = false
&#9;&#9;&#9;&#9;&#9;&#9;return
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Post process: after positioning the part or model, restore transparency, material, anchored and collide states and create joints
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) then
&#9;&#9;&#9;&#9;&#9;-- Tyler&apos;s magical hack-code for allowing/preserving clones of both Surface and Manual Welds...  just don&apos;t ask X&lt;
&#9;&#9;&#9;&#9;&#9;manualWeldTable = {}
&#9;&#9;&#9;&#9;&#9;manualWeldParentTable = {}
&#9;&#9;&#9;&#9;&#9;saveTheWelds(Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:BreakJoints()
&#9;&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:MakeJoints()
&#9;&#9;&#9;&#9;&#9;restoreTheWelds()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- if it&apos;s a model, we also want to fill in the playerID and playerName tags, if it has those (e.g. for the friend-only door)
&#9;&#9;&#9;&#9;playerIdTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerIdTag&quot;)
&#9;&#9;&#9;&#9;playerNameTag = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;PlayerNameTag&quot;)
&#9;&#9;&#9;&#9;if playerIdTag ~= nil then
&#9;&#9;&#9;&#9;&#9;tempPlayerValue = getPlayer()
&#9;&#9;&#9;&#9;&#9;if tempPlayerValue ~= nil then playerIdTag.Value = tempPlayerValue.userId end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;if playerNameTag ~= nil then
&#9;&#9;&#9;&#9;&#9;tempPlayerValue = getPlayer()
&#9;&#9;&#9;&#9;&#9;if tempPlayerValue ~= nil then playerNameTag.Value = tempPlayerValue.Name end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;-- ...and tag all inserted models for subsequent origin identification
&#9;&#9;&#9;&#9;-- if no RobloxModel tag already exists, then add it.
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;stringTag.Name = &quot;RobloxModel&quot;

&#9;&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;&#9;local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;&#9;stringTag2.Name = &quot;RobloxStamper&quot;
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end

&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1]:BreakJoints()
&#9;&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxStamper&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;local stringTag2 = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;&#9;stringTag2.Name = &quot;RobloxStamper&quot;
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;
&#9;&#9;&#9;-- make sure all the joints are activated before restoring anchor states
&#9;&#9;&#9;if not createJoints then game.JointsService:CreateJoinAfterMoveJoints() end

&#9;&#9;&#9;click.Value = true
&#9;&#9;&#9;--Fix the transparency and material of all the parts
&#9;&#9;&#9;for part, transparency in pairs(Data.Stamp.TransparencyTable) do
&#9;&#9;&#9;&#9;part.Transparency = transparency
&#9;&#9;&#9;&#9;part.archivable = true
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, material in pairs(Data.Stamp.MaterialTable) do
&#9;&#9;&#9;&#9;part.Material = material
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, collide in pairs(Data.Stamp.CanCollideTable) do
&#9;&#9;&#9;&#9;part.CanCollide = collide
&#9;&#9;&#9;end
&#9;&#9;&#9;for part, anchored in pairs(Data.Stamp.AnchoredTable) do
&#9;&#9;&#9;&#9;part.Anchored = anchored
&#9;&#9;&#9;end
&#9;&#9;&#9;for decal, transparency in pairs(Data.Stamp.DecalTransparencyTable) do
&#9;&#9;&#9;&#9;decal.Transparency = transparency
&#9;&#9;&#9;end

&#9;&#9;&#9;if (Data.Stamp.CurrentParts[1] and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot;) then
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].Transparency = 0
&#9;&#9;&#9;end

&#9;&#9;&#9;-- re-enable all seats
&#9;&#9;&#9;setSeatEnabledStatus(Data.Stamp.CurrentParts[1], true)

&#9;&#9;&#9;Data.Stamp.TransparencyTable = nil
&#9;&#9;&#9;Data.Stamp.MaterialTable = nil
&#9;&#9;&#9;Data.Stamp.CanCollideTable = nil
&#9;&#9;&#9;Data.Stamp.AnchoredTable = nil

&#9;&#9;&#9;-- ...and tag all inserted models for subsequent origin identification
&#9;&#9;&#9;-- if no RobloxModel tag already exists, then add it.
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;RobloxModel&quot;) == nil then
&#9;&#9;&#9;&#9;local stringTag = Instance.new(&quot;BoolValue&quot;, Data.Stamp.CurrentParts[1])
&#9;&#9;&#9;&#9;stringTag.Name = &quot;RobloxModel&quot;
&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;
&#9;&#9;&#9;-- set our object back to the player&apos;s plate
&#9;&#9;&#9;Data.Stamp.CurrentParts[1].Parent = partModel

&#9;&#9;&#9;--Re-enable the scripts
&#9;&#9;&#9;for index,script in pairs(Data.Stamp.DisabledScripts) do
&#9;&#9;&#9;&#9;script.Disabled = false
&#9;&#9;&#9;end
&#9;&#9;&#9;--Now that they are all marked enabled, reinsert them into the world so they start running
&#9;&#9;&#9;for index,script in pairs(Data.Stamp.DisabledScripts) do
&#9;&#9;&#9;&#9;local oldParent = script.Parent
&#9;&#9;&#9;&#9;script.Parent = nil
&#9;&#9;&#9;&#9;script:Clone().Parent = oldParent
&#9;&#9;&#9;end
&#9;&#9;&#9;Data.Stamp.DisabledScripts = nil
&#9;&#9;&#9;Data.Stamp.Dragger = nil
&#9;&#9;&#9;Data.Stamp.CurrentParts.Parent = nil
&#9;&#9;&#9;Data.Stamp.CurrentParts = nil

&#9;&#9;&#9;Data.Stamp.MouseLock = false

&#9;&#9;&#9;--Now set up a new instance of the object to allow a second copy to be stamped down
&#9;&#9;&#9;variables.Stamped.Value = true
&#9;&#9;&#9;variables.Stamped.Value = false
&#9;&#9;&#9;if isRestricted then
&#9;&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;end

&#9;&#9;end
&#9;end
end


------------------------ EyeDropper Code -------------------------------------------

function onEyeDropperMouseButton1Down()
&#9;if eyeDropperMoveConnection then 
&#9;&#9;eyeDropperMoveConnection:disconnect()
&#9;end
&#9;clearSelection()
&#9;if Mouse then
&#9;&#9;Mouse.Icon = &quot;http://www.pengin.xyz/asset?id=66887745&quot;
&#9;end

&#9;-- deny any attempt to clone something that wasn&apos;t stamped using the Stamper tool
&#9;if not Mouse or not Mouse.Target then
&#9;&#9;startEyeDropperOperation()
&#9;&#9;return
&#9;end

&#9;local isTerrainEyedroppering = false
&#9;if Mouse.Target == game.Workspace.Terrain then
&#9;&#9;-- want to eyedropper a terrain piece; gotta do a little extra footwork
&#9;&#9;print(&quot;Eyedroppering Terrain Piece&quot;)
&#9;&#9;local newTerrainPiece

&#9;&#9;-- gotta make the fake part here
&#9;&#9;local hitCell = game.Workspace.Terrain:WorldToCellPreferSolid(Mouse.Hit.p)
&#9;&#9;local cellMat, cellType, cellOrient = game.Workspace.Terrain:GetCell(hitCell.x, hitCell.y, hitCell.z)

&#9;&#9;if (cellType.Value == 1 or cellType.Value == 4) then newTerrainPiece = Instance.new(&quot;WedgePart&quot;) newTerrainPiece.formFactor = &quot;Custom&quot;
&#9;&#9;elseif (cellType.Value == 2) then newTerrainPiece = Instance.new(&quot;CornerWedgePart&quot;)
&#9;&#9;else newTerrainPiece = Instance.new(&quot;Part&quot;) newTerrainPiece.formFactor = &quot;Custom&quot; end
&#9;&#9;newTerrainPiece.Name = &quot;MegaClusterCube&quot;
&#9;&#9;newTerrainPiece.Size = Vector3.new(4, 4, 4)
&#9;&#9;newTerrainPiece.BottomSurface = &quot;Smooth&quot;
&#9;&#9;newTerrainPiece.TopSurface = &quot;Smooth&quot;

&#9;&#9;-- can add decals or textures here if feeling particularly adventurous...  for now, can make a table of look-up colors
&#9;&#9;newTerrainPiece.BrickColor = getClosestColorToTerrainMaterial(cellMat.Value)

&#9;&#9;local sideways = 0
&#9;&#9;local flipped = math.pi
&#9;&#9;if cellType.Value == 4 then sideways = -math.pi/2 end
&#9;&#9;if cellType.Value == 2 or cellType.Value == 3 then flipped = 0 end
&#9;&#9;newTerrainPiece.CFrame = CFrame.Angles(0, math.pi/2*cellOrient.Value + flipped, sideways)

&#9;&#9;if cellType.Value == 3 then
&#9;&#9;&#9;local inverseCornerWedgeMesh = Instance.new(&quot;SpecialMesh&quot;)
&#9;&#9;&#9;inverseCornerWedgeMesh.MeshType = &quot;FileMesh&quot;
&#9;&#9;&#9;inverseCornerWedgeMesh.MeshId = &quot;http://www.pengin.xyz/asset?id=66832495&quot;
&#9;&#9;&#9;inverseCornerWedgeMesh.Scale = Vector3.new(2, 2, 2)
&#9;&#9;&#9;inverseCornerWedgeMesh.Parent = newTerrainPiece
&#9;&#9;end

&#9;&#9;local materialTag = Instance.new(&quot;Vector3Value&quot;)
&#9;&#9;materialTag.Value = Vector3.new(cellMat.Value, cellType.Value, cellOrient.Value)
&#9;&#9;materialTag.Name = &quot;ClusterMaterial&quot;
&#9;&#9;materialTag.Parent = newTerrainPiece

&#9;&#9;local tempModel = Instance.new(&quot;Model&quot;)
&#9;&#9;newTerrainPiece.Parent = tempModel

&#9;&#9;Data.Stamp.Model = tempModel
&#9;&#9;Data.Stamp.Model:BreakJoints()

&#9;&#9;isTerrainEyedroppering = true
&#9;end

&#9;local stamperTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxStamper&quot;)
&#9;if stamperTag == nil then stamperTag = Mouse.Target:FindFirstChild(&quot;RobloxStamper&quot;) end
&#9;if stamperTag == nil and not isTerrainEyedroppering then
&#9;&#9;startEyeDropperOperation()
&#9;&#9;return
&#9;end

&#9;local eyeDropperInstance
&#9;-- find out if the target part is part of a Roblox Set Model
&#9;local robloxModelTag = Mouse.Target.Parent:FindFirstChild(&quot;RobloxModel&quot;)
&#9;if robloxModelTag ~= nil then
&#9;&#9;eyeDropperInstance = Mouse.Target.Parent
&#9;else
&#9;&#9;eyeDropperInstance = Mouse.Target
&#9;end
&#9;
&#9;-- do not allow certain objects to be captured with eye-dropper
&#9;-- for now, locked parts
&#9;if eyeDropperInstance:IsA(&quot;Part&quot;) and eyeDropperInstance.Locked and not isTerrainEyedroppering then
&#9;&#9;startEyeDropperOperation()
&#9;else
&#9;&#9;if not isTerrainEyedroppering then
&#9;&#9;&#9;local cloneInstance = eyeDropperInstance:clone()
&#9;&#9;&#9;local tempModel = Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;cloneInstance.Parent = tempModel

&#9;&#9;&#9;-- once more, we make sure it&apos;s on grid before eyedroppering
&#9;&#9;&#9;if not isOnGrid(tempModel) then startEyeDropperOperation() return end

&#9;&#9;&#9;Data.Stamp.Model = tempModel
&#9;&#9;&#9;Data.Stamp.Model:BreakJoints()
&#9;&#9;end

&#9;&#9;-- will create and position clone without requiring user to move the mouse&#9;&#9;

&#9;&#9;if isRestricted then
&#9;&#9;&#9;if checkPartLimit() then
&#9;&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;variables.ShowMaxedOut.Value = true
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;setupDraggableClone()
&#9;&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end
&#9;&#9;end

&#9;&#9;variables.SwitchLoaderToDialog.AssetImage.Value = &quot;0&quot;
&#9;&#9;variables.SwitchLoaderToDialog.DialogType.Value = &quot;SideDialog&quot;
&#9;&#9;variables.SwitchLoaderToDialog.Value = true
&#9;end
end

function onEyeDropperMouseMove() 
&#9;if not(inGui) and not(inPalette) then
&#9;&#9;if not Mouse or not Mouse.Target then clearSelection() return end
&#9;&#9;local part = Mouse.Target
&#9;&#9;if part:IsA(&quot;Terrain&quot;) and Mouse.Hit then
&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;setTerrainSelection(Mouse.Hit.p)
&#9;&#9;elseif canEyeDropperObject(part) then
&#9;&#9;&#9;local model = findModel(part)
&#9;&#9;&#9;if model and isOnGrid(model) then &#9;&#9;
&#9;&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;&#9;setSelection(model)
&#9;&#9;&#9;elseif (not model) and isOnGrid(part) then
&#9;&#9;&#9;&#9;selectionBox.Color = BrickColor.Green()
&#9;&#9;&#9;&#9;setSelection(part)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;clearSelection()
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;clearSelection()
&#9;&#9;end
&#9;end
end

function startEyeDropperOperation()

&#9;cancelAssetPlacement()
&#9;pressedEsc = false
&#9;signalInsertComplete(&quot;EyeDropper&quot;)

&#9;if mouseButton1UpCon then mouseButton1UpCon:disconnect() mouseButton1UpCon = nil end

&#9;if eyeDropperConnection then
&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;eyeDropperConnection = nil
&#9;end
&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end
&#9;if Mouse then
&#9;&#9;--Mouse.Icon =&quot;rbxasset://textures//DropperCursor.png&quot;
&#9;&#9;Mouse.Icon = &quot;http://www.pengin.xyz/asset?id=67163166&quot;
&#9;&#9;eyeDropperConnection = Mouse.Button1Up:connect(onEyeDropperMouseButton1Down)
&#9;&#9;eyeDropperMoveConnection = Mouse.Move:connect(onEyeDropperMouseMove)
&#9;end

end

function findModel(part)

&#9;if isRestricted then
&#9;&#9;while part ~= nil do
&#9;&#9;&#9;if part.className == &quot;Model&quot; and part.Name ~= playerModel.Name and part.Name ~= &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;elseif part.Name == playerModel.Name or part.Name == &quot;GarbageParts&quot; then
&#9;&#9;&#9;&#9;return nil
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;&#9;return nil

&#9;else
&#9;&#9;while part ~= game.Workspace do
&#9;&#9;&#9;if part:FindFirstChild(&quot;RobloxModel&quot;) then
&#9;&#9;&#9;&#9;return part
&#9;&#9;&#9;end
&#9;&#9;&#9;part = part.Parent
&#9;&#9;end
&#9;&#9;return nil
&#9;end

end

------------------------ End EyeDropper Code ---------------------------------------




------------------------ Start Selection Highlighting Code --------------------------
function setTerrainSelection(point)
&#9;if selectionBox then
&#9;&#9;local cell = game.Workspace.Terrain:WorldToCellPreferSolid(point)
&#9;&#9;local cellCenter = game.Workspace.Terrain:CellCenterToWorld(cell.X, cell.Y, cell.Z)
&#9;&#9;terrainSelectionBox.CFrame = CFrame.new(cellCenter)
&#9;&#9;selectionBox.Adornee = terrainSelectionBox
&#9;end
end
&#9;
function setSelection(partOrModel)
&#9;if partOrModel ~= currentSelection then
&#9;&#9;clearSelection()
&#9;&#9;currentSelection = partOrModel
&#9;&#9;selectionBox.Adornee = currentSelection
&#9;end
end

function clearSelection()
&#9;if currentSelection ~= nil then
&#9;&#9;for part, color in pairs(currentSelectionColors) do
&#9;&#9;&#9;part.BrickColor = color
&#9;&#9;end
&#9;&#9;selectionBox.Adornee = nil
&#9;end
&#9;currentSelectionColors = {}
&#9;-- I put these inside if statements, because we can&apos;t assume these exist. (Jahr, 12-29-2010)
&#9;if currentSelection then currentSelection = nil end
&#9;if selectionBox then selectionBox.Adornee = nil end
end

------------------------ End Selection Highlighting Code --------------------------

function autoAlignToFace()
&#9;local aatf = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;AutoAlignToFace&quot;)
&#9;if aatf then return aatf.Value else return false end
end


function autoAlignHelper()
&#9;local model = Data.Stamp.CurrentParts[1]
&#9;local aatfTag = model:FindFirstChild(&quot;AutoAlignToFace&quot;)
&#9;if not aatfTag then
&#9;&#9;aatfTag = Instance.new(&quot;IntValue&quot;)
&#9;&#9;aatfTag.Name = &quot;AutoAlignToFace&quot;
&#9;&#9;aatfTag.Parent = Data.Stamp.CurrentParts[1]
&#9;&#9;aatfTag.Value = 3
&#9;end
&#9;aatfTag.Value = aatfTag.Value + 1
&#9;if aatfTag.Value &gt; 3 then aatfTag.Value = 0 end
end

function unstampableFaceHelper()
&#9;if not Mouse or not Mouse.Target then return end
&#9;local model = Mouse.Target
&#9;if not model then return end
&#9;if not model:FindFirstChild(&quot;RobloxModel&quot;) then model = model.Parent end
&#9;if not model then return end
&#9;if not model:FindFirstChild(&quot;RobloxModel&quot;) then return end

&#9;local ufhTag = model:FindFirstChild(&quot;UnstampableFaces&quot;)
&#9;if not ufhTag then
&#9;&#9;ufhTag = Instance.new(&quot;StringValue&quot;)
&#9;&#9;ufhTag.Name = &quot;UnstampableFaces&quot;
&#9;&#9;ufhTag.Parent = model
&#9;&#9;ufhTag.Value = &quot;&quot;
&#9;end
&#9;
&#9;local hitFace = modelTargetSurface(model, game.Workspace.CurrentCamera.CoordinateFrame.p, Mouse.Hit.p)

&#9;-- put string list into table form
&#9;breakingFaceList = {}
&#9;for bf = -3, 3 do
&#9;&#9;breakingFaceList[bf] = false
&#9;end
&#9;for bf in string.gmatch(ufhTag.Value, &quot;[^,]+&quot;) do
&#9;&#9;breakingFaceList[tonumber(bf)] = true
&#9;end

&#9;-- toggle value of hit face
&#9;breakingFaceList[hitFace] = not breakingFaceList[hitFace]

&#9;-- put table form back into string value
&#9;ufhTag.Value = &quot;&quot;
&#9;local seenAValueSoFar = false
&#9;for bf = -3, 3 do
&#9;&#9;if bf ~= 0 then -- ignore 0 face, since that doesn&apos;t exist
&#9;&#9;&#9;if breakingFaceList[bf] then 
&#9;&#9;&#9;&#9;if seenAValueSoFar then ufhTag.Value = ufhTag.Value .. &quot;,&quot; .. tostring(bf)
&#9;&#9;&#9;&#9;else ufhTag.Value = tostring(bf) seenAValueSoFar = true end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function justificationHelper(whichAxis)
&#9;local model = Data.Stamp.CurrentParts[1]
&#9;local justTag = model:FindFirstChild(&quot;Justification&quot;)
&#9;if not justTag then
&#9;&#9;justTag = Instance.new(&quot;Vector3Value&quot;)
&#9;&#9;justTag.Name = &quot;Justification&quot;
&#9;&#9;justTag.Parent = Data.Stamp.CurrentParts[1]
&#9;&#9;justTag.Value = Vector3.new(1, 1, 1)
&#9;end
&#9;local oldValue = justTag.Value
&#9;if whichAxis == 1 then
&#9;&#9;if oldValue.X == 2 then justTag.Value = Vector3.new(0, oldValue.Y, oldValue.Z)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X+1, oldValue.Y, oldValue.Z) end
&#9;elseif whichAxis == 2 then
&#9;&#9;if oldValue.Y == 2 then justTag.Value = Vector3.new(oldValue.X, 0, oldValue.Z)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X, oldValue.Y+1, oldValue.Z) end
&#9;elseif whichAxis == 3 then
&#9;&#9;if oldValue.Z == 2 then justTag.Value = Vector3.new(oldValue.X, oldValue.Y, 0)
&#9;&#9;else justTag.Value = Vector3.new(oldValue.X, oldValue.Y, oldValue.Z+1) end
&#9;end
end

function onInsertKeyDown(key)
&#9;key = string.lower(key)
&#9;if Data.Stamp.Dragger then
&#9;&#9;if key == &apos;c&apos; and Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot; and HighScalabilityLine.InternalLine and HighScalabilityLine.InternalLine.magnitude &gt; 0 and HighScalabilityLine.Dimensions &lt; 3 then
&#9;&#9;&#9;HighScalabilityLine.MorePoints[HighScalabilityLine.Dimensions] = HighScalabilityLine.End
&#9;&#9;&#9;HighScalabilityLine.MoreLines[HighScalabilityLine.Dimensions] = HighScalabilityLine.InternalLine
&#9;&#9;&#9;HighScalabilityLine.Dimensions = HighScalabilityLine.Dimensions + 1
&#9;&#9;&#9;HighScalabilityLine.NewHint = true
&#9;&#9;end

&#9;&#9;if key == &apos;r&apos; and not autoAlignToFace() then
&#9;&#9;&#9;-- Update orientation value if this is a fake terrain part
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1].Name == &quot;MegaClusterCube&quot; then
&#9;&#9;&#9;&#9;local clusterValues = Data.Stamp.CurrentParts[1]:FindFirstChild(&quot;ClusterMaterial&quot;)
&#9;&#9;&#9;&#9;if clusterValues and clusterValues:IsA(&quot;Vector3Value&quot;) then
&#9;&#9;&#9;&#9;&#9;clusterValues.Value = Vector3.new(clusterValues.Value.X, clusterValues.Value.Y, (clusterValues.Value.Z+1)%4)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end

&#9;&#9;&#9;-- Rotate the parts or all the parts in the model
&#9;&#9;&#9;local ry = math.pi/2
&#9;&#9;&#9;local rotCF = CFrame.fromEulerAnglesXYZ(0, ry, 0)
&#9;&#9;&#9;gInitial90DegreeRotations = gInitial90DegreeRotations + 1
&#9;&#9;&#9;if Data.Stamp.CurrentParts[1]:IsA(&quot;Model&quot;) or Data.Stamp.CurrentParts[1]:IsA(&quot;Tool&quot;) then
&#9;&#9;&#9;&#9;for i, object in pairs(Data.Stamp.CurrentParts[1]:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Flag&quot;) then object = object.Handle end
&#9;&#9;&#9;&#9;&#9;if object:IsA(&quot;Part&quot;) or object:IsA(&quot;TrussPart&quot;) or object:IsA(&quot;WedgePart&quot;) or object:IsA(&quot;CornerWedgePart&quot;) or object:IsA(&quot;Seat&quot;) or object:IsA(&quot;VehicleSeat&quot;) then
&#9;&#9;&#9;&#9;&#9;&#9;object.CFrame = rotCF * object.CFrame
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;Data.Stamp.CurrentParts[1].CFrame = rotCF * Data.Stamp.CurrentParts[1].CFrame
&#9;&#9;&#9;end
&#9;&#9;&#9;-- After rotating, update the position
&#9;&#9;&#9;configFound, targetCFrame = findConfigAtMouseTarget(Data.Stamp.TransparencyTable)
&#9;&#9;&#9;if configFound then
&#9;&#9;&#9;&#9;positionPartsAtCFrame3(Data.Stamp.CurrentParts[1], targetCFrame)
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;-- update everything else in MouseMove
&#9;&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;if key == &apos;e&apos;  then
&#9;&#9;startEyeDropperOperation()
&#9;elseif key == &apos;q&apos; then
&#9;&#9;pressedEsc = true
&#9;&#9;if eyeDropperConnection then
&#9;&#9;&#9;eyeDropperConnection:disconnect()
&#9;&#9;&#9;eyeDropperConnection = nil
&#9;&#9;end
&#9;&#9;if eyeDropperMoveConnection then eyeDropperMoveConnection:disconnect() end

&#9;&#9;if Mouse and not mouseButton1UpCon then mouseButton1UpCon = Mouse.Button1Up:connect(onInsertMouseButton1Up) end

&#9;&#9;clearSelection()
&#9;&#9;cancelAssetPlacement()
&#9;&#9;Data.Loading.Cancelled = true
&#9;&#9;signalInsertComplete(&quot;Main&quot;)
&#9;end
&#9;
&#9;-- admin-only tools: helpful functions for construction purposes
&#9;if adminAccess then
&#9;&#9;if key == &apos;L&apos; or key == &apos;l&apos; then
&#9;&#9;&#9;-- autoalign helper
&#9;&#9;&#9;if Data.Stamp.Dragger then autoAlignHelper() onInsertMouseMove() end
&#9;&#9;elseif key == &apos;U&apos; or key == &apos;u&apos; then
&#9;&#9;&#9;-- unstampable face helper
&#9;&#9;&#9;unstampableFaceHelper()
&#9;&#9;--elseif key == &apos;C&apos; or key == &apos;c&apos; then
--&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper() end -- the &apos;c&apos; stands for &quot;Centering&quot; since &quot;j&quot; is already reserved by GuiScript
&#9;&#9;--end
&#9;&#9;elseif key == &apos;X&apos; or key == &apos;x&apos; then  -- change x justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(1) onInsertMouseMove() end
&#9;&#9;elseif key == &apos;Y&apos; or key == &apos;y&apos; then  -- change y justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(2) onInsertMouseMove() end
&#9;&#9;elseif key == &apos;Z&apos; or key == &apos;z&apos; then  -- change z justification
&#9;&#9;&#9;if Data.Stamp.Dragger then justificationHelper(3) onInsertMouseMove() end
&#9;&#9;end
&#9;end
end


function onEquippedLocal(newMouse)
&#9;Mouse = newMouse

&#9;player = getPlayer()

&#9;-- if equip goes through while in backpack (so getPlayer() returns nil), we don&apos;t want to process anything else
&#9;if not player then return end

&#9;--[[if game:FindFirstChild(&quot;NetworkClient&quot;) and game.CoreGui.Version &gt;= 7 then  only show billboards in online mode
&#9;&#9;if not billBoardOwnerGui then billBoardOwnerGui = generateOwnerGui(player.Name) end
&#9;end]]

&#9;if isRestricted then
&#9;&#9;if game.Workspace:FindFirstChild(&quot;BuildingAreas&quot;) then
&#9;&#9;&#9;local areas = game.Workspace.BuildingAreas:GetChildren()
&#9;&#9;&#9;for i = 1, #areas do
&#9;&#9;&#9;&#9;if areas[i]:FindFirstChild(&quot;Player&quot;) and areas[i].Player.Value == Tool.Parent.Name then
&#9;&#9;&#9;&#9;&#9;playerModel = areas[i]:FindFirstChild(&quot;PlayerArea&quot;)
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;else
&#9;&#9;playerModel = game.Workspace

&#9;&#9;-- give them a topHint gui too, if they don&apos;t have it since the place won&apos;t already have it&#9;
&#9;&#9;if not player.PlayerGui:FindFirstChild(&quot;topHint&quot;) then
&#9;&#9;&#9;local topHintGui = script.Parent:FindFirstChild(&quot;topHint&quot;)
&#9;&#9;&#9;if topHintGui then
&#9;&#9;&#9;&#9;topHintGui:Clone().Parent = player.PlayerGui
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end

&#9;if not playerModel then return end

&#9;-- used to move object when walking
&#9;cameraChangeCon = game.Players.LocalPlayer.Character.Humanoid.Running:connect(function(speed)
&#9;&#9;if speed &gt; 0 then
&#9;&#9;&#9;walking = true
&#9;&#9;&#9;while walking and cameraChangeCon do
&#9;&#9;&#9;&#9;onInsertMouseMove()
&#9;&#9;&#9;&#9;wait(1.0/30.0)
&#9;&#9;&#9;end
&#9;&#9;else
&#9;&#9;&#9;walking = false
&#9;&#9;end
&#9;end)
&#9;if Mouse then
&#9;&#9;mouseMoveCon = newMouse.Move:connect(onInsertMouseMove)
&#9;&#9;mouseButton1DownCon = newMouse.Button1Down:connect(onInsertMouseButton1Down)
&#9;&#9;mouseButton1UpCon = newMouse.Button1Up:connect(onInsertMouseButton1Up)
&#9;&#9;newMouse.KeyDown:connect(onInsertKeyDown)
&#9;end

&#9;if(isRestricted) then
&#9;&#9;local takenAreas = game.Workspace.BuildingAreas:GetChildren()

&#9;&#9;waitForChild(player, &quot;playerNumber&quot;)

&#9;&#9;if(player.playerNumber.Value == 0) then
&#9;&#9;&#9;buildingPlate = nil
&#9;&#9;&#9;partModel = nil
&#9;&#9;else
&#9;&#9;&#9;waitForChild(game.Workspace, &quot;BuildingAreas&quot;)
&#9;&#9;&#9;local buildingAreas = game.Workspace.BuildingAreas
&#9;&#9;&#9;waitForChild(buildingAreas, &quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;&#9;&#9;local targetArea = buildingAreas:FindFirstChild(&quot;Area&quot;..tostring(player.playerNumber.Value))
&#9;&#9;&#9;
&#9;&#9;&#9;waitForChild(targetArea, &quot;PlayerArea&quot;)
&#9;&#9;&#9;waitForChild(targetArea.PlayerArea, &quot;BasePlate&quot;)

&#9;&#9;&#9;buildingPlate = targetArea.PlayerArea.BasePlate
&#9;&#9;&#9;partModel = targetArea.PlayerArea
&#9;&#9;end
&#9;else
&#9;&#9;if game.Workspace:FindFirstChild(&quot;UnfinishedModels&quot;) == nil then
&#9;&#9;&#9;local newmodel = Instance.new(&quot;Model&quot;)
&#9;&#9;&#9;newmodel.Name = &quot;UnfinishedModels&quot;
&#9;&#9;&#9;newmodel.Parent = game.Workspace
&#9;&#9;&#9;game.Lighting.FixThings:Clone().Parent = newmodel
&#9;&#9;end
&#9;&#9;partModel = game.Workspace.UnfinishedModels
&#9;end

&#9;selectionBox = Instance.new(&quot;SelectionBox&quot;)
&#9;selectionBox.Name = &quot;Model Delete Selection&quot;
&#9;selectionBox.Color = BrickColor.Red()
&#9;selectionBox.Adornee = nil
&#9;selectionBox.Parent = player.PlayerGui

&#9;alreadyMoving = false
end


function onUnequipped()
&#9;Mouse = nil
&#9;if mouseMoveCon then mouseMoveCon:disconnect() end
&#9;if mouseButton1DownCon then mouseButton1DownCon:disconnect() end
&#9;if mouseButton1UpCon then mouseButton1UpCon:disconnect() end
&#9;if cameraChangeCon then cameraChangeCon:disconnect() cameraChangeCon = nil end
&#9;if billBoardOwnerGui then billBoardOwnerGui:Remove() end

&#9;cancelAssetPlacement()

&#9;clearSelection()
&#9;if selectionBox then selectionBox:Remove() end
end
----------------------------------------------------------------------------------------




-- Lua Start Script
Tool.Equipped:connect(function(newMouse) onEquippedLocal(newMouse) end)

waitForChild(variables,&quot;InsertAsset&quot;)
waitForChild(variables.InsertAsset, &quot;Updated&quot;)
variables.InsertAsset.Updated.Changed:connect(function(prop)
&#9;if variables.InsertAsset.Updated.Value == true then
&#9;&#9;pressedEsc = false
&#9;&#9;beginInsertAssetStamp(variables.InsertAsset.AssetName.Value, variables.InsertAsset.AssetId.Value,
&#9;&#9;&#9;variables.InsertAsset.Image.Value, variables.InsertAsset.StampMode.Value)
&#9;&#9;variables.InsertAsset.Updated.Value = false
&#9;end
end)

waitForChild(variables, &quot;SwitchMode&quot;)
waitForChild(variables.SwitchMode, &quot;Mode&quot;)
variables.SwitchMode.Changed:connect(function()
&#9;if variables.SwitchMode.Value == true then
&#9;&#9;if variables.SwitchMode.Mode.Value == &quot;Clone&quot; then
&#9;&#9;&#9;startEyeDropperOperation()
&#9;&#9;end
&#9;&#9;variables.SwitchMode.Value = false
&#9;end
end)

waitForChild(variables, &quot;ReloadCurrentAsset&quot;)
variables.ReloadCurrentAsset.Changed:connect(function()
&#9;if variables.ReloadCurrentAsset.Value == true then
&#9;&#9;setupDraggableClone()
&#9;&#9;variables.ReloadCurrentAsset.Value = false
&#9;end
end)

Tool.Unequipped:connect(function() onUnequipped() end)
----------------------------------------------------------------------------------------


</ProtectedString>
				</Properties>
			</Item>
			<Item class="Model" referent="RBX51">
				<Properties>
					<CoordinateFrame name="ModelInPrimary">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<string name="Name">LuaGlobalVariables</string>
					<Ref name="PrimaryPart">null</Ref>
				</Properties>
				<Item class="Model" referent="RBX52">
					<Properties>
						<CoordinateFrame name="ModelInPrimary">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
							<R00>1</R00>
							<R01>0</R01>
							<R02>0</R02>
							<R10>0</R10>
							<R11>1</R11>
							<R12>0</R12>
							<R20>0</R20>
							<R21>0</R21>
							<R22>1</R22>
						</CoordinateFrame>
						<string name="Name">InsertAsset</string>
						<Ref name="PrimaryPart">null</Ref>
					</Properties>
					<Item class="StringValue" referent="RBX53">
						<Properties>
							<string name="Name">AssetName</string>
							<string name="Value">Block - Brick</string>
						</Properties>
					</Item>
					<Item class="IntValue" referent="RBX54">
						<Properties>
							<string name="Name">AssetId</string>
							<int name="Value">-1</int>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX55">
						<Properties>
							<string name="Name">Image</string>
							<string name="Value">https://finobe.com/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=75&amp;ht=75&amp;aid=56450668</string>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX56">
						<Properties>
							<string name="Name">StampMode</string>
							<bool name="Value">true</bool>
						</Properties>
					</Item>
					<Item class="BoolValue" referent="RBX57">
						<Properties>
							<string name="Name">Updated</string>
							<bool name="Value">false</bool>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX58">
					<Properties>
						<string name="Name">SwitchLoaderToDialog</string>
						<bool name="Value">false</bool>
					</Properties>
					<Item class="StringValue" referent="RBX59">
						<Properties>
							<string name="Name">DialogType</string>
							<string name="Value">SideDialog</string>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX60">
						<Properties>
							<string name="Name">AssetImage</string>
							<string name="Value">nil</string>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX61">
					<Properties>
						<string name="Name">ShowInvalidPlacement</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX62">
					<Properties>
						<string name="Name">ShowMaxedOut</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX63">
					<Properties>
						<string name="Name">SwitchMode</string>
						<bool name="Value">false</bool>
					</Properties>
					<Item class="StringValue" referent="RBX64">
						<Properties>
							<string name="Name">Mode</string>
							<string name="Value"></string>
						</Properties>
					</Item>
				</Item>
				<Item class="BoolValue" referent="RBX65">
					<Properties>
						<string name="Name">Stamped</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX66">
					<Properties>
						<string name="Name">Moving</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX67">
					<Properties>
						<string name="Name">ShowAdminCategories</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="IntValue" referent="RBX68">
					<Properties>
						<string name="Name">userIDs</string>
						<int name="Value">0</int>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX69">
					<Properties>
						<string name="Name">ReloadCurrentAsset</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX70">
					<Properties>
						<string name="Name">ReloadCurrentAsset</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX71">
					<Properties>
						<string name="Name">MouseClick</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
				<Item class="BoolValue" referent="RBX72">
					<Properties>
						<string name="Name">IsRestricted</string>
						<bool name="Value">false</bool>
					</Properties>
				</Item>
			</Item>
			<Item class="Part" referent="RBX73">
				<Properties>
					<bool name="Anchored">false</bool>
					<float name="BackParamA">-0.5</float>
					<float name="BackParamB">0.5</float>
					<token name="BackSurface">0</token>
					<token name="BackSurfaceInput">0</token>
					<float name="BottomParamA">-0.5</float>
					<float name="BottomParamB">0.5</float>
					<token name="BottomSurface">4</token>
					<token name="BottomSurfaceInput">0</token>
					<int name="BrickColor">194</int>
					<CoordinateFrame name="CFrame">
						<X>-523.5</X>
						<Y>96.5</Y>
						<Z>631.5</Z>
						<R00>1</R00>
						<R01>0</R01>
						<R02>0</R02>
						<R10>0</R10>
						<R11>1</R11>
						<R12>0</R12>
						<R20>0</R20>
						<R21>0</R21>
						<R22>1</R22>
					</CoordinateFrame>
					<bool name="CanCollide">true</bool>
					<float name="Elasticity">0.5</float>
					<float name="Friction">0.300000012</float>
					<float name="FrontParamA">-0.5</float>
					<float name="FrontParamB">0.5</float>
					<token name="FrontSurface">0</token>
					<token name="FrontSurfaceInput">0</token>
					<float name="LeftParamA">-0.5</float>
					<float name="LeftParamB">0.5</float>
					<token name="LeftSurface">0</token>
					<token name="LeftSurfaceInput">0</token>
					<bool name="Locked">true</bool>
					<token name="Material">256</token>
					<string name="Name">Handle</string>
					<float name="Reflectance">0</float>
					<float name="RightParamA">-0.5</float>
					<float name="RightParamB">0.5</float>
					<token name="RightSurface">0</token>
					<token name="RightSurfaceInput">0</token>
					<Vector3 name="RotVelocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<float name="TopParamA">-0.5</float>
					<float name="TopParamB">0.5</float>
					<token name="TopSurface">3</token>
					<token name="TopSurfaceInput">0</token>
					<float name="Transparency">0</float>
					<Vector3 name="Velocity">
						<X>0</X>
						<Y>0</Y>
						<Z>0</Z>
					</Vector3>
					<token name="formFactorRaw">1</token>
					<token name="shape">1</token>
					<Vector3 name="size">
						<X>1</X>
						<Y>0.400000006</Y>
						<Z>1</Z>
					</Vector3>
				</Properties>
				<Item class="SpecialMesh" referent="RBX74">
					<Properties>
						<token name="LODX">2</token>
						<token name="LODY">2</token>
						<Content name="MeshId"><url>http://www.pengin.xyz/asset/?id=42163552</url></Content>
						<token name="MeshType">5</token>
						<string name="Name">Mesh</string>
						<Vector3 name="Offset">
							<X>0</X>
							<Y>0</Y>
							<Z>0</Z>
						</Vector3>
						<Vector3 name="Scale">
							<X>0.899999976</X>
							<Y>0.899999976</Y>
							<Z>0.899999976</Z>
						</Vector3>
						<Content name="TextureId"><url>http://www.pengin.xyz/asset/?id=42163513</url></Content>
						<Vector3 name="VertexColor">
							<X>1</X>
							<Y>1</Y>
							<Z>1</Z>
						</Vector3>
					</Properties>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX75">
				<Properties>
					<string name="Name">StampGUI</string>
				</Properties>
				<Item class="Frame" referent="RBX76">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">InsertPanel</string>
						<UDim2 name="Position">
							<XS>0.200000003</XS>
							<XO>2</XO>
							<YS>0.100000001</YS>
							<YO>24</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0.600000024</XS>
							<XO>-20</XO>
							<YS>0.639999986</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX77">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ItemsFrame</string>
							<UDim2 name="Position">
								<XS>0.239999995</XS>
								<XO>0</XO>
								<YS>0.0850000009</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.540000021</XS>
								<XO>0</XO>
								<YS>0.800000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX78">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294112243</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">InsertAssetButtonExample</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>128</XO>
									<YS>0</YS>
									<YO>64</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>64</XO>
									<YS>0</YS>
									<YO>64</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBX79">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button</string>
									<UDim2 name="Position">
										<XS>0.0250000004</XS>
										<XO>0</XO>
										<YS>0.0250000004</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0.949999988</XS>
										<XO>0</XO>
										<YS>0.949999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX80">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><null></null></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
							</Item>
							<Item class="IntValue" referent="RBX81">
								<Properties>
									<string name="Name">AssetId</string>
									<int name="Value">209411115</int>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX82">
								<Properties>
									<string name="Name">AssetName</string>
									<string name="Value">Roof - Outer Corner</string>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBX83">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4278190080</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.pengin.xyz/asset?id=54140547</url></Content>
									<string name="Name">ConfigIcon</string>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>-23</XO>
										<YS>1</YS>
										<YO>-24</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>16</XO>
										<YS>0</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX84">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">CancelButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-32</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>34</XO>
								<YS>0</YS>
								<YO>34</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX85">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.pengin.xyz/asset?id=54135717</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>-2</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX86">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">SelectSetButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.200000003</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text">Select Set</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX87">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">PagingControls</string>
							<UDim2 name="Position">
								<XS>0.239999995</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.540000021</XS>
								<XO>0</XO>
								<YS>0.100000001</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX88">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<bool name="Modal">false</bool>
								<string name="Name">PreviousPageButton</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-95</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX89">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.pengin.xyz/asset?id=54138586</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>-1</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>18</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX90">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4284874854</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">PageText</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-30</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">1 / 3</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextButton" referent="RBX91">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<bool name="Modal">false</bool>
								<string name="Name">NextPageButton</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>35</XO>
									<YS>0.5</YS>
									<YO>-20</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>60</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX92">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.pengin.xyz/asset?id=54138563</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>10</XO>
										<YS>0</YS>
										<YO>-1</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>18</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX93">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4294901862</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Sets</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>5</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.230000004</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-5</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX94">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4294967295</Color3>
								<float name="BackgroundTransparency">0.699999988</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">Line</string>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>-3</XO>
									<YS>0.0599999987</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>3</XO>
									<YS>0.899999976</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX95">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">7</token>
								<string name="Name">SetsHeader</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>47</XO>
									<YS>0</YS>
									<YO>24</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<string name="Text">Sets</string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX96">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4291559577</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">SetsLists</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.0599999987</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-6</XO>
									<YS>0.939999998</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextButton" referent="RBX97">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">false</bool>
									<Color3 name="BackgroundColor3">4294967295</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">1</token>
									<token name="FontSize">6</token>
									<bool name="Modal">false</bool>
									<string name="Name">SetButtonExample</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>5</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>-5</XO>
										<YS>0</YS>
										<YO>18</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<string name="Text">House Decorations</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX98">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4284874803</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">ItemPreview</string>
							<UDim2 name="Position">
								<XS>0.790000021</XS>
								<XO>0</XO>
								<YS>0.0850000009</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0.209999993</XS>
								<XO>0</XO>
								<YS>0.899999976</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX99">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4278190080</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><null></null></Content>
								<string name="Name">LargePreview</string>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>-2</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>4</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX100">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4286578816</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">TextPanel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX101">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4291624857</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">7</token>
									<string name="Name">RolloverText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Window - Diagonal</string>
									<Color3 name="TextColor3">4294112243</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX102">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<string name="Name">ConfigureText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBX103">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4294901862</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Configure:</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX104">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure1</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Speed</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX105">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure2</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>28</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Damage</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX106">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<token name="FontSize">5</token>
										<string name="Name">Configure3</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>42</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>14</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">Delay</string>
										<Color3 name="TextColor3">4294112243</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="Frame" referent="RBX107">
					<Properties>
						<bool name="Active">true</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">StamperPanel</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-175</XO>
							<YS>1</YS>
							<YO>-135</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>48</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<token name="Style">3</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="TextButton" referent="RBX108">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">MinimizeButton</string>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>-32</XO>
								<YS>0</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>34</XO>
								<YS>0</YS>
								<YO>34</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX109">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.pengin.xyz/asset?id=54932670</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-3</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>16</XO>
									<YS>0</YS>
									<YO>20</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX110">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">StamperButtons</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBX111">
							<Properties>
								<bool name="Active">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">RecentFrame</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>103</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>192</XO>
									<YS>0</YS>
									<YO>44</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="TextButton" referent="RBX112">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button1</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>-2</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">0</token>
									<token name="TextYAlignment">0</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX113">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.pengin.xyz/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX114">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">F</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX115">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button2</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>-2</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX116">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.pengin.xyz/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX117">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">G</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX118">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button3</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>95</XO>
										<YS>0</YS>
										<YO>-3</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX119">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.pengin.xyz/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX120">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">H</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX121">
								<Properties>
									<bool name="Active">true</bool>
									<bool name="AutoButtonColor">true</bool>
									<Color3 name="BackgroundColor3">4282861383</Color3>
									<float name="BackgroundTransparency">0.100000001</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">0</token>
									<token name="FontSize">0</token>
									<bool name="Modal">false</bool>
									<string name="Name">Button4</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>142</XO>
										<YS>0</YS>
										<YO>-3</YO>
									</UDim2>
									<bool name="Selected">false</bool>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>48</XO>
										<YS>0</YS>
										<YO>48</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<token name="Style">2</token>
									<string name="Text"></string>
									<Color3 name="TextColor3">4279970357</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.100000001</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX122">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://gametest.pengin.xyz/Game/Tools/ThumbnailAsset.ashx?fmt=png&amp;wd=420&amp;ht=420&amp;assetversionid=209434543</url></Content>
										<string name="Name">ButtonImage</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-8</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>16</XO>
											<YS>1</YS>
											<YO>16</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">5</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX123">
									<Properties>
										<bool name="Active">false</bool>
										<Color3 name="BackgroundColor3">4288914085</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">4279970357</Color3>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">2</token>
										<token name="FontSize">5</token>
										<string name="Name">ShortcutText</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>-7</XO>
											<YS>0</YS>
											<YO>-8</YO>
										</UDim2>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>7</XO>
											<YS>0</YS>
											<YO>12</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<string name="Text">J</string>
										<Color3 name="TextColor3">4294967295</Color3>
										<bool name="TextScaled">false</bool>
										<Color3 name="TextStrokeColor3">4278190080</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">8</int>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX124">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<bool name="Modal">false</bool>
								<string name="Name">CloneButton</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<bool name="Selected">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>45</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX125">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.pengin.xyz/asset?id=51641555</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-7</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>14</XO>
										<YS>1</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">4</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX126">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">CloneShortcut</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">E</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX127">
							<Properties>
								<bool name="Active">true</bool>
								<bool name="AutoButtonColor">true</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">2</token>
								<token name="FontSize">5</token>
								<bool name="Modal">false</bool>
								<string name="Name">PartsButton</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>-6</YO>
								</UDim2>
								<bool name="Selected">true</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>45</XO>
									<YS>0</YS>
									<YO>45</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<string name="Text"></string>
								<Color3 name="TextColor3">4294967295</Color3>
								<bool name="TextScaled">false</bool>
								<Color3 name="TextStrokeColor3">4278190080</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">3</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX128">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>http://www.pengin.xyz/asset?id=54966682</url></Content>
									<string name="Name">ImageLabel</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-7</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>14</XO>
										<YS>1</YS>
										<YO>14</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">4</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX129">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">PartsShortcut</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-7</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>8</XO>
										<YS>0</YS>
										<YO>12</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Q</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">0</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX130">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<string name="Name">ClonePanel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>-8</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>80</XO>
									<YS>1</YS>
									<YO>16</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<token name="Style">2</token>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX131">
								<Properties>
									<bool name="Active">false</bool>
									<Color3 name="BackgroundColor3">4288914085</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">4279970357</Color3>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">2</token>
									<token name="FontSize">5</token>
									<string name="Name">ClonePanelText</string>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>-6</XO>
										<YS>0</YS>
										<YO>-8</YO>
									</UDim2>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>12</XO>
										<YS>1</YS>
										<YO>16</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<string name="Text">Click on a part to clone it</string>
									<Color3 name="TextColor3">4294967295</Color3>
									<bool name="TextScaled">false</bool>
									<Color3 name="TextStrokeColor3">4278190080</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="TextButton" referent="RBX132">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">7</token>
							<bool name="Modal">false</bool>
							<string name="Name">RestoreButton</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>-25</XO>
								<YS>0</YS>
								<YO>-20</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>50</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">1</token>
							<string name="Text"></string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">false</bool>
							<int name="ZIndex">3</int>
						</Properties>
						<Item class="ImageLabel" referent="RBX133">
							<Properties>
								<bool name="Active">false</bool>
								<Color3 name="BackgroundColor3">4288914085</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">4279970357</Color3>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.pengin.xyz/asset?id=54933540</url></Content>
								<string name="Name">ImageLabel</string>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>-4</XO>
									<YS>0</YS>
									<YO>-4</YO>
								</UDim2>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>8</XO>
									<YS>1</YS>
									<YO>8</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">4</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX134">
					<Properties>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">StampGuiController</string>
						<ProtectedString name="Source">local stampGui = script.Parent
local insertPanel = stampGui.InsertPanel
local stamperPanel = stampGui.StamperPanel

local itemPreview = insertPanel.ItemPreview

function handleResize()
&#9;wait() -- neccessary to insure heartbeat happened
&#9;itemPreview.LargePreview.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.X)
&#9;itemPreview.LargePreview.Position = UDim2.new(0.5,-itemPreview.LargePreview.AbsoluteSize.X/2,0,0)
&#9;itemPreview.TextPanel.Position = UDim2.new(0,0,0,itemPreview.LargePreview.AbsoluteSize.Y)
&#9;itemPreview.TextPanel.Size = UDim2.new(1,0,0,itemPreview.AbsoluteSize.Y - itemPreview.LargePreview.AbsoluteSize.Y)
end

stampGui.Changed:connect(function(prop)
&#9;if prop == &quot;AbsoluteSize&quot; then
&#9;&#9;handleResize()
&#9;end
end)

handleResize()</ProtectedString>
					</Properties>
				</Item>
				<Item class="Frame" referent="RBX135">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<string name="Name">LoadDialog</string>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>-175</XO>
							<YS>0.5</YS>
							<YO>-25</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">1</token>
						<token name="Style">3</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBX136">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<token name="FontSize">8</token>
							<string name="Name">LoadLabel</string>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>-8</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>155</XO>
								<YS>0.5</YS>
								<YO>36</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<string name="Text">Loading...</string>
							<Color3 name="TextColor3">4294506744</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX137">
				<Properties>
					<string name="Name">topHint</string>
				</Properties>
				<Item class="ImageLabel" referent="RBX138">
					<Properties>
						<bool name="Active">false</bool>
						<Color3 name="BackgroundColor3">4288914085</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">4279970357</Color3>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<Content name="Image"><null></null></Content>
						<string name="Name">_preview</string>
						<UDim2 name="Position">
							<XS>0</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>1</YS>
							<YO>0</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<bool name="Visible">false</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="Frame" referent="RBX139">
						<Properties>
							<bool name="Active">false</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<string name="Name">Bkg</string>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-250</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>400</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">3</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX140">
						<Properties>
							<bool name="Active">true</bool>
							<bool name="AutoButtonColor">true</bool>
							<Color3 name="BackgroundColor3">4288914085</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">4279970357</Color3>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">0</token>
							<token name="FontSize">5</token>
							<bool name="Modal">false</bool>
							<string name="Name">Label</string>
							<UDim2 name="Position">
								<XS>0.25</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<bool name="Selected">false</bool>
							<UDim2 name="Size">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>40</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<token name="Style">0</token>
							<string name="Text">Saved changes</string>
							<Color3 name="TextColor3">4294967295</Color3>
							<bool name="TextScaled">false</bool>
							<Color3 name="TextStrokeColor3">4278190080</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX141">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Add</string>
						<ProtectedString name="Source">-- This script&apos;s job is to destroy previous topHint instance (if exists) and clone and run a new _topHint script (naming it &quot;topHint&quot;)
-- When this script is finished, it disables and resets itself.

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(script, &quot;Label&quot;)
waitForChild(script, &quot;Time&quot;)
waitForChild(script, &quot;Width&quot;)
waitForChild(script.Parent, &quot;_topHint&quot;)
waitForChild(script.Parent._topHint, &quot;Label&quot;)
waitForChild(script.Parent._topHint, &quot;HideTime&quot;)
waitForChild(script.Parent._topHint, &quot;Width&quot;)

local width = 0.55--script.Width.Value
--width = math.min(0.55,width/script.Parent.AbsoluteSize.X)

local quickReplace = true

-- If there&apos;s already an instance, do you quickly replace the text and width (true), or animate out then in? (false)

if (script.Parent:FindFirstChild(&quot;topHint&quot;)~=nil) then
&#9;-- If there&apos;s already an instance...
&#9;if(quickReplace) then
&#9;&#9;-- If quickReplace is true...
&#9;&#9;local bkg = script.Parent.Bkg
&#9;&#9;local label = script.Parent.Label
&#9;&#9;local ys = bkg.Position.Y.Scale
&#9;&#9;local yo = bkg.Position.Y.Offset
&#9;&#9;bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
&#9;&#9;bkg.Size = UDim2.new(width,0, 0, 40)
&#9;&#9;label.Text = script.Label.Value
&#9;&#9;script.Parent.topHint.HideTime.Value = time() + script.Time.Value
&#9;else
&#9;&#9;-- If quickReplace is false...
&#9;&#9;script.Parent.Delete.Disabled = false
&#9;&#9;-- Wait for instance to be removed
&#9;&#9;waitForNoChild(script.Parent, &quot;topHint&quot;)
&#9;&#9;waitForNoChild(script.Parent, &quot;Bkg&quot;)
&#9;&#9;waitForNoChild(script.Parent, &quot;Label&quot;)
&#9;end
else
&#9;-- There&apos;s no previous instance.
&#9;-- Clone and enable a new instance
&#9;local topHint = script.Parent._topHint:Clone()
&#9;topHint.Parent = script.Parent
&#9;topHint.Name = &quot;topHint&quot;
&#9;topHint.Label.Value = script.Label.Value
&#9;topHint.HideTime.Value = time() + script.Time.Value
&#9;topHint.Width.Value = width
&#9;topHint.Disabled = false
end

script.Disabled = true
</ProtectedString>
					</Properties>
					<Item class="NumberValue" referent="RBX142">
						<Properties>
							<string name="Name">Width</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX143">
						<Properties>
							<string name="Name">Label</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX144">
						<Properties>
							<string name="Name">Time</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX145">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_topHint</string>
						<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

-- This script creates the graphics for the new topHint, and animates it.
-- Before calling this script, we&apos;ve already made sure: there&apos;s no other &quot;topHint&quot;, &quot;Bkg&quot;, and &quot;Label&quot;
-- Then, if time~=0, it waits &quot;time&quot; and then calls &quot;Remove&quot; script

waitForChild(script, &quot;Label&quot;)
waitForChild(script, &quot;HideTime&quot;)
waitForChild(script, &quot;Width&quot;)

local container = script.Parent
local labelText = script.Label.Value
local hideTime = script.HideTime.Value
local width = script.Width.Value

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50
local bottomY = 10
local easing = &quot;Sine.easeInOut&quot;
--

local bkg = Instance.new(&quot;Frame&quot;)
bkg.Parent = container
bkg.Name = &quot;Bkg&quot;
bkg.Position = UDim2.new((1 - width)/2,0, ys, yo)
bkg.Size = UDim2.new(width,0, 0, 40)
bkg.Style = &quot;RobloxRound&quot;

function destroy()
&#9;script.Parent.Delete.Disabled = false
end

local label = Instance.new(&quot;TextButton&quot;)
label.Parent = container
label.Name = &quot;Label&quot;
label.BackgroundTransparency = 1
label.FontSize = &quot;Size14&quot;
label.Position = UDim2.new((1 - width)/2,0, 0, topY)
label.Size = UDim2.new(width,0, 0, 40)
label.Text = labelText
label.TextColor3 = Color3.new(1, 1, 1)
label.MouseButton1Click:connect(destroy)

bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,bottomY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,bottomY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Sine,tweenTime,true)

if(hideTime~=0) then
&#9;while(time() &lt; hideTime) do wait(0.1) end
&#9;destroy()
end</ProtectedString>
					</Properties>
					<Item class="NumberValue" referent="RBX146">
						<Properties>
							<string name="Name">Width</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
					<Item class="StringValue" referent="RBX147">
						<Properties>
							<string name="Name">Label</string>
							<string name="Value"></string>
						</Properties>
					</Item>
					<Item class="NumberValue" referent="RBX148">
						<Properties>
							<string name="Name">HideTime</string>
							<double name="Value">0</double>
						</Properties>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX149">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Delete</string>
						<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

function waitForNoChild(instance, name)
&#9;while instance:FindFirstChild(name) do
&#9;&#9;instance.ChildRemoved:wait()
&#9;end
end

function waitForAnyChild(instance)
&#9;while not instance:GetChildren()[1] do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local topHint = script.Parent:FindFirstChild(&quot;topHint&quot;)
local bkg = script.Parent:FindFirstChild(&quot;Bkg&quot;)
local label = script.Parent:FindFirstChild(&quot;Label&quot;)

-- SETTINGS
local tweenTime = 0.3 -- animation time (seconds)
local topY = -50 -- top position (Y Offset)
local easing = &quot;Back.easeInOut&quot;
--

if(topHint~=nil) then
&#9;topHint:Remove()
end

if(bkg~=nil) then
&#9;bkg:TweenPosition(UDim2.new(bkg.Position.X.Scale,bkg.Position.X.Offset,bkg.Position.Y.Scale,topY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

if(label~=nil) then
&#9;label:TweenPosition(UDim2.new(label.Position.X.Scale,label.Position.X.Offset,label.Position.Y.Scale,topY),
&#9;&#9;Enum.EasingDirection.InOut,Enum.EasingStyle.Quad,tweenTime,true)
end

wait(tweenTime)
if(bkg~=nil) then bkg:Remove() end
if(label~=nil) then label:Remove() end

script.Disabled = true
</ProtectedString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX150">
					<Properties>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">_readme</string>
						<ProtectedString name="Source">--
-- Top Hint
--
--  * This is a string of text that&apos;s top-centered in the window. (White text on black background)
--  * It should be used for messages from the client, and never from the place creator. 
--
-- FEATURES:
--  * Auto-hides previous messages before showing yours.
--  * Always centered, regardless of length.
--  * Clicking the message hides it.
-- 
-- USE IT FOR:
--  * Quick task-related (non-essential) hints
--  * Showing the current modal state
--  * Tool hints (for the currently equipped tool)
--  * Keyboard shortcuts
--
-- NEVER USE IT FOR:
--  * Essential information (Use a popup instead)
--  * Messages from users or place creators.  This is for client messages only.
--
-- ARGUMENTS:
--  Label:  The message
--  Width:  Text and background width (pixels) -- This should be removed when textWidth is added to Lua
--  Time:   Seconds before hiding itself (If 0, it never hides)
--
-- USAGE:
local topHint = script.Parent.topHint  -- path to topHint ScreenGui
topHint.Add.Label.Value = &quot;Press D to return to main menu.&quot;
topHint.Add.Width.Value = 290
topHint.Add.Time.Value = 7
topHint.Add.Disabled = true  -- flip it off then on, in case it&apos;s currently running.
topHint.Add.Disabled = false
--
-- TO HIDE MANUALLY:
topHint.Delete.Disabled = false
-- Clicking the message also hides it.</ProtectedString>
					</Properties>
				</Item>
			</Item>
		</Item>
	</Item>
	<Item class="StarterGui" referent="RBX151">
		<Properties>
			<string name="Name">StarterGui</string>
			<bool name="ShowDevelopmentGui">true</bool>
		</Properties>
	</Item>
	<Item class="SoundService" referent="RBX152">
		<Properties>
			<token name="AmbientReverb">0</token>
			<float name="DistanceFactor">10</float>
			<float name="DopplerScale">1</float>
			<string name="Name">Soundscape</string>
			<float name="RolloffScale">1</float>
		</Properties>
	</Item>
	<Item class="CollectionService" referent="RBX153">
		<Properties>
			<string name="Name">CollectionService</string>
		</Properties>
	</Item>
	<Item class="PhysicsService" referent="RBX154">
		<Properties>
			<string name="Name">PhysicsService</string>
		</Properties>
	</Item>
	<Item class="BadgeService" referent="RBX155">
		<Properties>
			<string name="Name">BadgeService</string>
		</Properties>
	</Item>
	<Item class="Geometry" referent="RBX156">
		<Properties>
			<string name="Name">Geometry</string>
		</Properties>
	</Item>
	<Item class="RenderHooksService" referent="RBX157">
		<Properties>
			<string name="Name">RenderHooksService</string>
		</Properties>
	</Item>
	<Item class="SocialService" referent="RBX158">
		<Properties>
			<string name="Name">SocialService</string>
		</Properties>
	</Item>
	<Item class="GamePassService" referent="RBX159">
		<Properties>
			<string name="Name">GamePassService</string>
		</Properties>
	</Item>
	<Item class="Debris" referent="RBX160">
		<Properties>
			<int name="MaxItems">1000</int>
			<string name="Name">Debris</string>
		</Properties>
	</Item>
	<Item class="TimerService" referent="RBX161">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="ScriptInformationProvider" referent="RBX162">
		<Properties>
			<string name="Name">Instance</string>
		</Properties>
	</Item>
	<Item class="CookiesService" referent="RBX163">
		<Properties>
			<string name="Name">CookiesService</string>
		</Properties>
	</Item>
	<Item class="TeleportService" referent="RBX164">
		<Properties>
			<string name="Name">Teleport Service</string>
		</Properties>
	</Item>
	<Item class="Players" referent="RBX165">
		<Properties>
			<bool name="CharacterAutoLoads">true</bool>
			<string name="Name">Players</string>
		</Properties>
	</Item>
	<Item class="Selection" referent="RBX166">
		<Properties>
			<string name="Name">Selection</string>
		</Properties>
	</Item>
	<Item class="Lighting" referent="RBX167">
		<Properties>
			<Color3 name="Ambient">4286611584</Color3>
			<float name="Brightness">1</float>
			<Color3 name="ColorShift_Bottom">4278190080</Color3>
			<Color3 name="ColorShift_Top">4278190080</Color3>
			<Color3 name="FogColor">4290822336</Color3>
			<float name="FogEnd">100000</float>
			<float name="FogStart">0</float>
			<float name="GeographicLatitude">41.7332993</float>
			<string name="Name">Lighting</string>
			<Color3 name="ShadowColor">4289967032</Color3>
			<string name="TimeOfDay">14:00:00</string>
		</Properties>
		<Item class="Script" referent="RBX168">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">AndGateScript</string>
				<ProtectedString name="Source">--





sp=script.Parent

local inputs={sp.Input1:GetCurrentValue(),sp.Input2:GetCurrentValue()}

function check()
&#9;if inputs[1]&gt;.5 and sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;else
&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;end
&#9;if inputs[2]&gt;.5 and sp.Parent:FindFirstChild(&quot;Light2Color&quot;) then
&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;else
&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;end
&#9;if inputs[1]&gt;.5 and inputs[2]&gt;.5 then
&#9;&#9;sp.Output:SetValue(1)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light3Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light3Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;sp.Output:SetValue(0)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light3Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light3Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;end
end

sp.Input1.SourceValueChanged:connect(function(val)
&#9;inputs[1]=val
&#9;check()
end)

sp.Input2.SourceValueChanged:connect(function(val)
&#9;inputs[2]=val
&#9;check()
end)

check()


</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX169">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Trapscript</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local player = nil

local door = script.Parent
--door.Anchored = true
door.CanCollide = false
local isOpen = false

local doorOpenTime = 1

--[[function accessGranted(part)
&#9;if part.Parent == nil then return false end
&#9;pPlay = game.Players:GetPlayerFromCharacter(part.Parent)
&#9;if pPlay == nil then return false end
&#9;player = part.Parent
&#9;return true
end]]--

function checkHit(part)
&#9;--if (accessGranted(part)) then
&#9;&#9;if not isOpen then
&#9;&#9;&#9;isOpen = true
&#9;&#9;&#9;wait(.3)
&#9;&#9;&#9;door.Transparency = 1
&#9;&#9;&#9;wait(doorOpenTime)
&#9;&#9;&#9;door.Transparency = 0
&#9;&#9;&#9;isOpen = false
&#9;&#9;end
end


door.Touched:connect(checkHit)

-- Remove decals
waitForChild(script.Parent, &quot;Decal1&quot;)
waitForChild(script.Parent, &quot;Decal2&quot;)
waitForChild(script.Parent, &quot;Decal3&quot;)
waitForChild(script.Parent, &quot;Decal4&quot;)
script.Parent.Decal1:Remove()
script.Parent.Decal2:Remove()
script.Parent.Decal3:Remove()
script.Parent.Decal4:Remove()</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX170">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Boombox Controller</string>
				<ProtectedString name="Source">--

sp=script.Parent


function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local jazzAsset = &quot;http://www.pengin.xyz/asset/?id=60047782&quot;
local electronicAsset = &quot;http://www.pengin.xyz/asset/?id=60049010&quot;
local rockAsset = &quot;http://www.pengin.xyz/asset/?id=60059129&quot;
local funkAsset = &quot;http://www.pengin.xyz/asset/?id=60051616&quot;

game:GetService(&quot;ContentProvider&quot;):Preload(jazzAsset)
game:GetService(&quot;ContentProvider&quot;):Preload(electronicAsset)
game:GetService(&quot;ContentProvider&quot;):Preload(rockAsset)
game:GetService(&quot;ContentProvider&quot;):Preload(funkAsset)

waitForChild(sp, &quot;Sound&quot;)
local sound = sp.Sound
waitForChild(sp,&quot;Configuration&quot;)
local config = sp:FindFirstChild(&quot;Configuration&quot;)
waitForChild(sp,&quot;PausePlay&quot;)


config.Music.Changed:connect(function()
&#9;sound.Volume=0
&#9;sound:Stop()
&#9;if config.Music.Value == &quot;Rock&quot; then
&#9;&#9;sound.SoundId = rockAsset
&#9;elseif config.Music.Value == &quot;Electronic&quot; then
&#9;&#9;sound.SoundId = electronicAsset
&#9;elseif config.Music.Value == &quot;Jazz&quot; then
&#9;&#9;sound.SoundId = jazzAsset
&#9;elseif config.Music.Value == &quot;Funk&quot; then
&#9;&#9;sound.SoundId = funkAsset
&#9;end
&#9;if sp.PausePlay:GetCurrentValue()&gt;=.5 then
&#9;&#9;sound.Volume=config.Volume.Value
&#9;&#9;sound:Play()
&#9;end
end)

config.Volume.Changed:connect(function()
&#9;sound.Volume=config.Volume.Value
end)

sp.PausePlay.SourceValueChanged:connect(function(val)
&#9;if val&gt;=.5 then
&#9;&#9;sound.Volume=config.Volume.Value
&#9;&#9;sound:Play()
&#9;else
&#9;&#9;sound.Volume=0
&#9;&#9;sound:Pause()
&#9;end
end)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX171">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">BoomboxController</string>
				<ProtectedString name="Source">--Stickmasterluke

sp=script.Parent

function waitForChild(instance, name)
&#9;while not instance:findFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Sound&quot;)
local sound=sp.Sound
waitForChild(sp,&quot;Configuration&quot;)
local config=sp:FindFirstChild(&quot;Configuration&quot;)
waitForChild(sp,&quot;PausePlay&quot;)


function update()
&#9;sound.Volume=0
&#9;sound:Stop()
&#9;sound.Pitch=config.Pitch.Value
&#9;
&#9;&#9;sound.SoundId=&quot;http://www.pengin.xyz/asset/?id=&quot;..tostring(config.SoundId.Value)

&#9;
&#9;if sp.PausePlay:GetCurrentValue()&gt;=.5 then
&#9;&#9;sound.Volume=config.Volume.Value
&#9;&#9;sound:Play()
&#9;end
end

for i,v in ipairs(config:GetChildren()) do
&#9;v.Changed:connect(update)
end

sp.PausePlay.SourceValueChanged:connect(function(val)
&#9;if val&gt;=.5 then
&#9;&#9;sound.Volume=config.Volume.Value
&#9;&#9;if config.RestartSound.Value then
&#9;&#9;&#9;sound:Stop()
&#9;&#9;end
&#9;&#9;sound:Play()
&#9;else
&#9;&#9;sound.Volume=0
&#9;&#9;sound:Pause()
&#9;end
end)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX172">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ButtonScript</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
function getPlayerFromPart(part)
&#9;-- If part is inside a character, then return the player.  Else, return nil.
&#9;while part do
&#9;&#9;if part:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;&#9;return game.Players:GetPlayerFromCharacter(part)
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end
&#9;return nil
end

local model = script.Parent

waitForChild(model, &quot;BottomBase&quot;)
waitForChild(model, &quot;Knob&quot;)
waitForChild(model, &quot;ClickDetector&quot;)
waitForChild(model, &quot;Lever&quot;)
waitForChild(model, &quot;sidewallRelative&quot;)
waitForChild(model.Lever, &quot;LeverEngage&quot;)

local lever = model.Lever
local knob = model.Knob
local leverEngage = lever.LeverEngage
local bottomBase = model.BottomBase
local cDetector = model.ClickDetector
local sidewallRelative = model.sidewallRelative

waitForChild(lever, &quot;LeverWeld&quot;)
local leverWeld = lever.LeverWeld
--lever.CFrame = sidewallRelative.CFrame + sidewallRelative.CFrame:vectorToWorldSpace(Vector3.new(0.7, 0, 0.7))

local leverOn = false
local leverMoveDiff = 1.7
local movingLever = false

-- was lever last on or off?
if knob.BrickColor.Name ~= &quot;Bright red&quot; then
&#9;leverOn = true
end


function moveLever()
&#9;leverOn = not leverOn

&#9;&#9;if leverOn then
&#9;&#9;&#9;knob.BrickColor = BrickColor.new(&quot;Bright green&quot;)
&#9;&#9;&#9;leverWeld.C1 = leverWeld.C1 + Vector3.new(0, 0, leverMoveDiff)
&#9;&#9;else
&#9;&#9;&#9;knob.BrickColor = BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;&#9;leverWeld.C1 = leverWeld.C1 - Vector3.new(0, 0, leverMoveDiff)
&#9;&#9;end
end

cDetector.MouseClick:connect(function()
&#9;if not movingLever then
&#9;&#9;movingLever = true

&#9;&#9;&#9;if not leverOn then
&#9;&#9;&#9;&#9;moveLever() -- bring the lever down
&#9;&#9;&#9;&#9;leverEngage:SetValue(1)
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;moveLever() -- bring the lever back up
&#9;&#9;&#9;&#9;leverEngage:SetValue(0)
&#9;&#9;&#9;end

&#9;&#9;movingLever = false
&#9;end
end)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX173">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ButtonScriptOK</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end
function getPlayerFromPart(part)
&#9;-- If part is inside a character, then return the player.  Else, return nil.
&#9;while part do
&#9;&#9;if part:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;&#9;return game.Players:GetPlayerFromCharacter(part)
&#9;&#9;end
&#9;&#9;part = part.Parent
&#9;end
&#9;return nil
end

local model = script.Parent
waitForChild(model, &quot;Base&quot;)
waitForChild(model, &quot;BottomBase&quot;)
waitForChild(model, &quot;Button&quot;)
local button = model.Button
local bottomBase = model.BottomBase
local base = model.Base

-- SETTINGS
--local offColor = BrickColor.new(&quot;Deep blue&quot;)
--local onColor  = BrickColor.new(0.8, 0.8, 0.8)

local onColor = BrickColor.new(&quot;Deep orange&quot;)
local offColor = BrickColor.new(&quot;Neon orange&quot;)

local downY = base.Position.Y
local buttonHeight = 0.45 -- Distance above bottomBase that button should be when it&apos;s in the up position
local upY = downY + buttonHeight
local threshold = 0.2  -- How far down do you have to press the button before isPressed = true?
local onlyTriggeredByPlayers = true  -- Only players can trigger this button.
local button_maxForce = Vector3.new(1200, 1200, 1200) -- MaxForce for the Button&apos;s BodyPosition
local button_D = 1250
local button_P = 3500
local stamperToolWasEquipped = false
local isCoolingDown = false
--



local currentColor = 1
local colors = {
&#9;BrickColor.new(&quot;Camo&quot;),
&#9;BrickColor.new(&quot;Cyan&quot;),
&#9;BrickColor.new(&quot;Bright yellow&quot;),
&#9;BrickColor.new(&quot;Deep blue&quot;),
&#9;BrickColor.new(&quot;Bright red&quot;),
&#9;BrickColor.new(&quot;Pink&quot;),
&#9;BrickColor.new(&quot;Magenta&quot;),
&#9;BrickColor.new(&quot;Bright red&quot;)
}

function button_touchHandler(part)
&#9;local playerWhoTouched
&#9;playerWhoTouched = getPlayerFromPart(part)

&#9;if isCoolingDown then return end
&#9;isCoolingDown = true
&#9;-- Turn switch on
&#9;button.BrickColor = onColor
&#9;stop = time() + 1.4
&#9;button.ButtonPush:SetValue(1.0)
&#9;wait(0.2)
&#9;button.ButtonPush:SetValue(0)
&#9;button.BrickColor = offColor
&#9;wait(0.4)
&#9;isCoolingDown = false
end

-- Initialize
button.BrickColor = offColor

-- Connect events
button.Touched:connect(function(part) button_touchHandler(part) end)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX174">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ButtonScriptcoil</string>
				<ProtectedString name="Source">--



sp=script.Parent
oncolor=BrickColor.new(28)
offcolor=BrickColor.new(&quot;Bright red&quot;)

effectparts={&quot;Ring1&quot;,&quot;Ring2&quot;,&quot;Ring3&quot;,&quot;Ring4&quot;,&quot;Ring5&quot;,&quot;Ring6&quot;}

function runeffects(trans)
&#9;for i,v in ipairs(effectparts) do
&#9;&#9;local part=sp.Parent:FindFirstChild(v)
&#9;&#9;if part~=nil then
&#9;&#9;&#9;part.Transparency=trans
&#9;&#9;end
&#9;&#9;wait(.15)
&#9;end
end

sp.ClickDetector.MouseClick:connect(function()
&#9;if sp.BrickColor == oncolor then
&#9;&#9;sp.BrickColor = offcolor
&#9;&#9;sp.ButtonPress:SetValue(0)
&#9;&#9;runeffects(1)
&#9;else
&#9;&#9;sp.BrickColor = oncolor
&#9;&#9;sp.ButtonPress:SetValue(1)
&#9;&#9;runeffects(0)
&#9;end
end)




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX175">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DelayScript</string>
				<ProtectedString name="Source">--





sp=script.Parent


function check(val)
&#9;if sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;if val&gt;.5 then
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;else
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;end
&#9;wait(sp.Configuration.DelayTime.Value)
&#9;sp.Output:SetValue(val)
&#9;if sp.Parent:FindFirstChild(&quot;Light2Color&quot;) then
&#9;&#9;if val&gt;.5 then
&#9;&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;else
&#9;&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;end
end

sp.DelayInput.SourceValueChanged:connect(check)
check(sp.DelayInput:GetCurrentValue())




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX176">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorScript</string>
				<ProtectedString name="Source">-- useless comment here

function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
end

local model = script.Parent
local doorOpenTime = 3

local weld1RelativePosition = CFrame.new() + Vector3.new(0, -1.1, .55)
local weld2RelativePosition = CFrame.new() + Vector3.new(0, -1.1, -.55)


waitForChild(model, &quot;PlayerIdTag&quot;)
waitForChild(model, &quot;Configuration&quot;)
waitForChild(model, &quot;Door1&quot;)
waitForChild(model, &quot;Door2&quot;)
waitForChild(model, &quot;TouchDoor1&quot;)
waitForChild(model, &quot;TouchDoor2&quot;)
waitForChild(model, &quot;OuterEdge&quot;)

local doorOwnerId = model.PlayerIdTag.Value  -- Update the owner ID
local config = model.Configuration
local doorPart1 = model.Door1
local doorPart2 = model.Door2
local doorTouch1 = model.TouchDoor1
local doorTouch2 = model.TouchDoor2
local outerEdge = model.OuterEdge

waitForChild(config, &quot;FriendMode&quot;)
local mode = config.FriendMode


function testPermission(part)
&#9;doorOwnerId = model.PlayerIdTag.Value -- Update the owner ID
&#9;if part == nil then return false end   -- In case part was deleted
&#9;pChar = part.Parent
&#9;if pChar == nil then return false end
&#9;pPlay = game.Players:GetPlayerFromCharacter(pChar)  -- In case player left game
&#9;if pPlay == nil then return false end

&#9;-- Test permissions
&#9;if(mode.Value == &quot;Everyone&quot;) then
&#9;&#9;return true
&#9;elseif (mode.Value == &quot;Only Me&quot;) then
&#9;&#9;if pPlay.userId == doorOwnerId then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;-- no access
&#9;&#9;end
&#9;elseif(mode.Value == &quot;Friends&quot;) then
&#9;&#9;if (pPlay:IsFriendsWith(doorOwnerId)) then 
&#9;&#9;&#9;return true 
&#9;&#9;else
&#9;&#9;&#9;-- no access
&#9;&#9;end
&#9;elseif(mode.Value == &quot;Best Friends&quot;) then
&#9;&#9;if (pPlay:IsBestFriendsWith(doorOwnerId)) then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;-- no access
&#9;&#9;end
&#9;elseif(mode.Value == &quot;Group&quot;) then
&#9;&#9;if (pPlay:IsInGroup(doorOwnerId)) then
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;-- no access
&#9;&#9;end
&#9;end
&#9;return false
end

local isOpen
function doorOpen()
&#9;isOpen = true
&#9;--if doorPart1:FindFirstChild(&quot;DoorWeld&quot;) ~= nil then doorPart1.DoorWeld:Remove() end
&#9;--if doorPart2:FindFirstChild(&quot;DoorWeld&quot;) ~= nil then doorPart2.DoorWeld:Remove() end
&#9;weld1 = doorPart1:FindFirstChild(&quot;DoorWeld&quot;)
&#9;weld2 = doorPart2:FindFirstChild(&quot;DoorWeld&quot;)
&#9;if not weld1 or not weld2 then return end

&#9;-- horrible animation code
&#9;for i = 1, 10 do
&#9;&#9;weld1.C1 = weld1RelativePosition + Vector3.new(0, 0, i * .2)
&#9;&#9;weld2.C1 = weld2RelativePosition + Vector3.new(0, 0, i * -.2)

&#9;&#9;wait(.1)
&#9;end
end

function doorClose()
&#9;-- horrible animation code
&#9;weld1 = doorPart1:FindFirstChild(&quot;DoorWeld&quot;)
&#9;weld2 = doorPart2:FindFirstChild(&quot;DoorWeld&quot;)

&#9;if not weld1 or not weld2 then return end

&#9;for i = 9, 0, -1 do
&#9;&#9;weld1.C1 = weld1RelativePosition + Vector3.new(0, 0, i * .2)
&#9;&#9;weld2.C1 = weld2RelativePosition + Vector3.new(0, 0, i * -.2)

&#9;&#9;wait(.1)
&#9;end

&#9;isOpen = false
&#9;--doorPart2.CFrame = doorGyro.cframe -- snap shut through the player, so that it doesn&apos;t send them flying
end

local debounce = false
local stayOpenTime = 0
function touchEvent(part)
&#9;if not part or not part.Parent or part.Parent == model then return end

&#9;--if (part ~= door1 and part ~= door2) then
&#9;&#9;if (testPermission(part)) then
&#9;&#9;&#9;if not debounce and not isOpen then
&#9;&#9;&#9;&#9;debounce = true
&#9;&#9;&#9;&#9;doorOpen()
&#9;&#9;&#9;&#9;wait(doorOpenTime)
&#9;&#9;&#9;&#9;while stayOpenTime &gt; 0 do
&#9;&#9;&#9;&#9;&#9;local tempVariable = stayOpenTime -- allows us to use this variable in the wait while also setting it to zero
&#9;&#9;&#9;&#9;&#9;stayOpenTime = 0
&#9;&#9;&#9;&#9;&#9;wait(tempVariable)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;doorClose()
&#9;&#9;&#9;&#9;debounce = false
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;stayOpenTime = doorOpenTime
&#9;&#9;&#9;end
&#9;&#9;end
&#9;--end
end


function changedEvent(prop)
&#9;-- Only interested in CFrame (position + rotation) changes
&#9;if(prop ~= &quot;CFrame&quot;) then return end

&#9;--targetPos = underDoors.Position
&#9;--door1bp.position = side2.Position
&#9;--door2bp.position = side1.Position
&#9;--a = underDoors.CFrame.lookVector
&#9;--lookVector = Vector3.new( math.abs(a.x), math.abs(a.y), math.abs(a.z) )
&#9;--setDoorForces()
end

changedEvent(&quot;CFrame&quot;) -- Fire once to initialize

-- shut the front door
-- create door welds if we don&apos;t have them yet

weld1 = doorPart1:FindFirstChild(&quot;DoorWeld&quot;)
weld2 = doorPart2:FindFirstChild(&quot;DoorWeld&quot;)
if not weld1 or not weld2 then
&#9;if weld1 then weld1:Remove() end
&#9;if weld2 then weld2:Remove() end

&#9;newDoorWeld = Instance.new(&quot;ManualWeld&quot;)
&#9;newDoorWeld.Part0 = doorPart1
&#9;newDoorWeld.Part1 = outerEdge
&#9;newDoorWeld.C1 = weld1RelativePosition
&#9;newDoorWeld.Name = &quot;DoorWeld&quot;
&#9;newDoorWeld.Parent = doorPart1

&#9;newDoorWeld = Instance.new(&quot;ManualWeld&quot;)
&#9;newDoorWeld.Part0 = doorPart2
&#9;newDoorWeld.Part1 = outerEdge
&#9;newDoorWeld.C1 = weld2RelativePosition
&#9;newDoorWeld.Name = &quot;DoorWeld&quot;
&#9;newDoorWeld.Parent = doorPart2
else
&#9;weld1.C1 = weld1RelativePosition
&#9;weld2.C1 = weld2RelativePosition
end
isOpen = false

doorTouch1.Touched:connect(touchEvent)
doorTouch2.Touched:connect(touchEvent)

print(&quot;REACHED END&quot;)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX177">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorScriptDraw</string>
				<ProtectedString name="Source">--Stickmasterluke

sp=script.Parent
framerate=30

frames=1
running=false
direction=1


function waitForChild(instance,name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Bottom&quot;)
waitForChild(sp.Bottom,&quot;CloseGate&quot;)
waitForChild(sp.Bottom,&quot;Configuration&quot;)


function checkframes()
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local config=sp.Bottom:FindFirstChild(&quot;Configuration&quot;)
&#9;&#9;if config then
&#9;&#9;&#9;frames=math.floor(config.TimeToMove.Value*framerate)+1
&#9;&#9;end
&#9;end
end
sp.Bottom.Configuration.TimeToMove.Changed:connect(checkframes)
checkframes()


function updatedoor(frame)
&#9;local percentage=1-(frame/frames)
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;HingeMain&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(0,-4,0)*CFrame.Angles(math.pi/2*percentage,0,0)
&#9;&#9;end
&#9;&#9;local hinge2=sp.Bottom:FindFirstChild(&quot;HingeSecondary&quot;)
&#9;&#9;if hinge2~=nil then
&#9;&#9;&#9;hinge2.C1=CFrame.new(0,-10,0)*CFrame.Angles(math.pi/2*percentage,0,0)
&#9;&#9;end
&#9;&#9;local hinge3=sp.Bottom:FindFirstChild(&quot;HingeCorner1&quot;)
&#9;&#9;if hinge3~=nil then
&#9;&#9;&#9;hinge3.C1=CFrame.new(0,0,10)*CFrame.Angles(0,math.pi/2*-percentage,0)
&#9;&#9;end
&#9;&#9;local hinge4=sp.Bottom:FindFirstChild(&quot;HingeCorner2&quot;)
&#9;&#9;if hinge4~=nil then
&#9;&#9;&#9;hinge4.C1=CFrame.new(0,0,10)*CFrame.Angles(0,math.pi/2*percentage,math.pi)
&#9;&#9;end
&#9;&#9;local hinge5=sp.Bottom:FindFirstChild(&quot;HingeCorner3&quot;)
&#9;&#9;if hinge5~=nil then
&#9;&#9;&#9;hinge5.C1=CFrame.new(0,0,13)*CFrame.Angles(0,math.pi/2*-percentage,0)
&#9;&#9;end
&#9;&#9;local hinge6=sp.Bottom:FindFirstChild(&quot;HingeCorner4&quot;)
&#9;&#9;if hinge6~=nil then
&#9;&#9;&#9;hinge6.C1=CFrame.new(0,0,13)*CFrame.Angles(0,math.pi/2*percentage,math.pi)
&#9;&#9;end
&#9;end
end

function runloop()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;while true do
&#9;&#9;&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;&#9;&#9;local frame=sp.Bottom:FindFirstChild(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;frame.Value=frame.Value+direction
&#9;&#9;&#9;&#9;&#9;if frame.Value&gt;frames then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=frames
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if frame.Value&lt;=0 then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;updatedoor(frame.Value)
&#9;&#9;&#9;&#9;&#9;wait(1/framerate)
&#9;&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;&#9;if (frame.Value&lt;=0 and direction==-1) or (frame.Value&gt;=frames and direction==1) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;running=false
&#9;end
end

function check(val)
&#9;if val&gt;.5 then
&#9;&#9;direction=1
&#9;else
&#9;&#9;direction=-1
&#9;end
&#9;runloop()
end

sp.Bottom.CloseGate.SourceValueChanged:connect(check)
check(sp.Bottom.CloseGate:GetCurrentValue())



</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX178">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorScriptSci</string>
				<ProtectedString name="Source">--Stickmasterluke

sp=script.Parent
framerate=30

frames=1
running=false
direction=1


function waitForChild(instance,name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Bottom&quot;)
waitForChild(sp.Bottom,&quot;OpenDoor&quot;)
waitForChild(sp.Bottom,&quot;Configuration&quot;)


function checkframes()
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local config=sp.Bottom:FindFirstChild(&quot;Configuration&quot;)
&#9;&#9;if config then
&#9;&#9;&#9;frames=math.floor(config.TimeToMove.Value*framerate)+1
&#9;&#9;end
&#9;end
end
sp.Bottom.Configuration.TimeToMove.Changed:connect(checkframes)
checkframes()


function updatedoor(frame)
&#9;local percentage=frame/frames
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local bottomhinge=sp.Bottom:FindFirstChild(&quot;BottomHinge&quot;)
&#9;&#9;if bottomhinge~=nil then
&#9;&#9;&#9;bottomhinge.C1=CFrame.new(0,3.25*percentage,0)
&#9;&#9;end
&#9;&#9;local tophinge=sp.Bottom:FindFirstChild(&quot;TopHinge&quot;)
&#9;&#9;if tophinge~=nil then
&#9;&#9;&#9;tophinge.C1=CFrame.new(0,-3.25*percentage,0)
&#9;&#9;end
&#9;&#9;local center1=sp.Bottom:FindFirstChild(&quot;Center1Hinge&quot;)
&#9;&#9;if center1~=nil then
&#9;&#9;&#9;center1.C1=CFrame.new(0,0,3.25*percentage)
&#9;&#9;end
&#9;&#9;local center2=sp.Bottom:FindFirstChild(&quot;Center2Hinge&quot;)
&#9;&#9;if center2~=nil then
&#9;&#9;&#9;center2.C1=CFrame.new(0,0,3.25*percentage)
&#9;&#9;end
&#9;end
end

function checkemitters()
&#9;if sp:FindFirstChild(&quot;Emitter1&quot;) then
&#9;&#9;sp.Emitter1.Smoke.Enabled=running
&#9;end
&#9;if sp:FindFirstChild(&quot;Emitter2&quot;) then
&#9;&#9;sp.Emitter2.Smoke.Enabled=running
&#9;end
end
checkemitters()

function runloop()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;checkemitters()
&#9;&#9;while true do
&#9;&#9;&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;&#9;&#9;local frame=sp.Bottom:FindFirstChild(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;frame.Value=frame.Value+direction
&#9;&#9;&#9;&#9;&#9;if frame.Value&gt;frames then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=frames
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if frame.Value&lt;=0 then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;updatedoor(frame.Value)
&#9;&#9;&#9;&#9;&#9;wait(1/framerate)
&#9;&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;&#9;if (frame.Value&lt;=0 and direction==-1) or (frame.Value&gt;=frames and direction==1) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;running=false
&#9;&#9;checkemitters()
&#9;end
end

function check(val)
&#9;if val&gt;.5 then
&#9;&#9;direction=1
&#9;else
&#9;&#9;direction=-1
&#9;end
&#9;runloop()
end

sp.Bottom.OpenDoor.SourceValueChanged:connect(check)
check(sp.Bottom.OpenDoor:GetCurrentValue())



</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX179">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorScriptWIRING</string>
				<ProtectedString name="Source">--Stickmasterluke

sp=script.Parent
framerate=30

frames=1
running=false
direction=1


function waitForChild(instance,name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Bottom&quot;)
waitForChild(sp.Bottom,&quot;OpenDoor&quot;)
waitForChild(sp.Bottom,&quot;Configuration&quot;)


function checkframes()
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local config=sp.Bottom:FindFirstChild(&quot;Configuration&quot;)
&#9;&#9;if config then
&#9;&#9;&#9;frames=math.floor(config.TimeToMove.Value*framerate)+1
&#9;&#9;end
&#9;end
end
sp.Bottom.Configuration.TimeToMove.Changed:connect(checkframes)
checkframes()


function updatedoor(frame)
&#9;local percentage=frame/frames
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;Hinge1&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(1.75,0,0)*CFrame.Angles(0,(math.pi/2)*percentage,0)*CFrame.new(-1.75,0,0)
&#9;&#9;end
&#9;&#9;local hinge2=sp.Bottom:FindFirstChild(&quot;Hinge2&quot;)
&#9;&#9;if hinge2~=nil then
&#9;&#9;&#9;hinge2.C1=CFrame.new(-1.75,0,0)*CFrame.Angles(0,(-math.pi/2)*percentage,0)*CFrame.new(1.75,0,0)
&#9;&#9;end
&#9;end
end

function runloop()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;while true do
&#9;&#9;&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;&#9;&#9;local frame=sp.Bottom:FindFirstChild(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;frame.Value=frame.Value+direction
&#9;&#9;&#9;&#9;&#9;if frame.Value&gt;frames then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=frames
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if frame.Value&lt;=0 then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;updatedoor(frame.Value)
&#9;&#9;&#9;&#9;&#9;wait(1/framerate)
&#9;&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;&#9;if (frame.Value&lt;=0 and direction==-1) or (frame.Value&gt;=frames and direction==1) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;running=false
&#9;end
end

function check(val)
&#9;if val&gt;.5 then
&#9;&#9;direction=1
&#9;else
&#9;&#9;direction=-1
&#9;end
&#9;runloop()
end

sp.Bottom.OpenDoor.SourceValueChanged:connect(check)
check(sp.Bottom.OpenDoor:GetCurrentValue())



</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX180">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorScriptiris</string>
				<ProtectedString name="Source">--Stickmasterluke

sp=script.Parent
framerate=30

frames=1
running=false
direction=1


function waitForChild(instance,name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Bottom&quot;)
waitForChild(sp.Bottom,&quot;OpenDoor&quot;)
waitForChild(sp.Bottom,&quot;Configuration&quot;)


function checkframes()
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local config=sp.Bottom:FindFirstChild(&quot;Configuration&quot;)
&#9;&#9;if config then
&#9;&#9;&#9;frames=math.floor(config.TimeToMove.Value*framerate)+1
&#9;&#9;end
&#9;end
end
sp.Bottom.Configuration.TimeToMove.Changed:connect(checkframes)
checkframes()


function updatedoor(frame)
&#9;local percentage=frame/frames
&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;local hingedist=1.9
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;Door1&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(-hingedist,-hingedist,0)*CFrame.Angles(0,0,(math.pi/2)*percentage)*CFrame.new(hingedist,hingedist,0)
&#9;&#9;end
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;Door2&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(-hingedist,hingedist,0)*CFrame.Angles(0,0,(math.pi/2)*percentage)*CFrame.new(hingedist,-hingedist,0)
&#9;&#9;end
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;Door3&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(hingedist,hingedist,0)*CFrame.Angles(0,0,(math.pi/2)*percentage)*CFrame.new(-hingedist,-hingedist,0)
&#9;&#9;end
&#9;&#9;local hinge1=sp.Bottom:FindFirstChild(&quot;Door4&quot;)
&#9;&#9;if hinge1~=nil then
&#9;&#9;&#9;hinge1.C1=CFrame.new(hingedist,-hingedist,0)*CFrame.Angles(0,0,(math.pi/2)*percentage)*CFrame.new(-hingedist,hingedist,0)
&#9;&#9;end
&#9;end
end

function runloop()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;while true do
&#9;&#9;&#9;if sp:FindFirstChild(&quot;Bottom&quot;) then
&#9;&#9;&#9;&#9;local frame=sp.Bottom:FindFirstChild(&quot;Frame&quot;)
&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;frame.Value=frame.Value+direction
&#9;&#9;&#9;&#9;&#9;if frame.Value&gt;frames then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=frames
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;if frame.Value&lt;=0 then
&#9;&#9;&#9;&#9;&#9;&#9;frame.Value=0
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;updatedoor(frame.Value)
&#9;&#9;&#9;&#9;&#9;wait(1/framerate)
&#9;&#9;&#9;&#9;&#9;if frame then
&#9;&#9;&#9;&#9;&#9;&#9;if (frame.Value&lt;=0 and direction==-1) or (frame.Value&gt;=frames and direction==1) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;running=false
&#9;end
end

function check(val)
&#9;if val&gt;.5 then
&#9;&#9;direction=1
&#9;else
&#9;&#9;direction=-1
&#9;end
&#9;runloop()
end

sp.Bottom.OpenDoor.SourceValueChanged:connect(check)
check(sp.Bottom.OpenDoor:GetCurrentValue())



</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX181">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">DoorbellScript</string>
				<ProtectedString name="Source">--Stickmasterluke


sp=script.Parent
button=sp.Parent:FindFirstChild(&quot;Button&quot;)
ontill=0

function on()
&#9;sp.ButtonPushed:SetValue(1)
&#9;button.BrickColor=BrickColor.new(&quot;Cool yellow&quot;)
&#9;button.Mesh.Offset=Vector3.new(0,.25,0)
end

function off()
&#9;sp.ButtonPushed:SetValue(0)
&#9;button.BrickColor=BrickColor.new(&quot;Bright yellow&quot;)
&#9;button.Mesh.Offset=Vector3.new(0,.1,0)
end

button.ClickDetector.MouseClick:connect(function()
&#9;on()
&#9;ontill=tick()+sp.Configuration.ActivationTime.Value
&#9;while ontill&gt;tick() do
&#9;&#9;wait()
&#9;end
&#9;off()
end)




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX182">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ElevatorScript</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end



-- SETTINGS
local offColor = BrickColor.new(&quot;Earth green&quot;)
local onColor  = BrickColor.new(&quot;Lime green&quot;)
local platformOffset = -3.6 -- Offset the platform this many studs from the goalTop and goalBottom positions (along the Platform&apos;s lookVector axis).
local triggerStopThreshold = 1  -- How close must platform be to goal position to signal a stop?

local model = script.Parent
waitForChild(model, &quot;SwitchBottom&quot;)
waitForChild(model, &quot;SwitchBottomWedge&quot;)
waitForChild(model, &quot;SwitchTop&quot;)
waitForChild(model, &quot;Platform&quot;)
waitForChild(model, &quot;Invisiweight&quot;)
waitForChild(model, &quot;Spine&quot;)
waitForChild(model, &quot;Bottom&quot;)
waitForChild(model, &quot;SpineBottom&quot;)
local platform = model.Platform
local weight = model.Invisiweight
waitForChild(weight, &quot;BodyPosition&quot;)
local bodyPosition = weight.BodyPosition
waitForChild(weight, &quot;BodyGyro&quot;)
local bodyGyro = weight.BodyGyro

local switchBottom = model.SwitchBottom
local switchBottomWedge = model.SwitchBottomWedge
local switchTop = model.SwitchTop
local spine = model.Spine
local spineBottom = model.SpineBottom
local bottom = model.Bottom
local goalTop = switchTop
local goalBottom = spineBottom
local goalTopPosition  -- Platform&apos;s position at top
local goalBottomPosition  -- Platform&apos;s position at bottom
local goalPositionOffset = Vector3.new(0, (weight.Size.y/2 + platform.Size.y/2), 0)
-- In more exact terms: goalTop.Position + Platform.CFrame.lookVector*(this amount) should put the platform in its goalTop and goalBottom positions.
local isMoving = false
local isGoingUp = false
local timeout = 5
local platformListenerDisabled = false  -- Necessary because your legs call the platform way too much.

-- FUNCTIONS

function platformLoop()
&#9;local endTime = time() + timeout
&#9;local stayAlive = true
&#9;while stayAlive do
&#9;&#9;local dist = weight.Position - bodyPosition.position
&#9;&#9;if(dist.magnitude &lt;= triggerStopThreshold) then
&#9;&#9;&#9;print(&quot;Platform has reached goal.  isMoving = false.&quot;)
&#9;&#9;&#9;isMoving = false
&#9;&#9;&#9;stayAlive = false
&#9;&#9;else
&#9;&#9;&#9;wait(0.5)
&#9;&#9;&#9;print(&quot;loop...&quot;)
&#9;&#9;&#9;if time() &gt; endTime then
&#9;&#9;&#9;&#9;print(&quot;loop: timeout. Reversing...&quot;)
&#9;&#9;&#9;&#9;if isGoingUp then
&#9;&#9;&#9;&#9;&#9;moveElevatorDown()
&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;moveElevatorUp()
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;stayAlive = false
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

platformCoroutine = coroutine.create(platformLoop)

function moveElevatorUp()
&#9;print(&quot;moveElevatorUp()&quot;)
&#9;switchTop.BrickColor = onColor
&#9;switchBottom.BrickColor = offColor
&#9;switchBottomWedge.BrickColor = offColor
&#9;bodyPosition.position = goalTopPosition
&#9;bodyGyro.cframe = CFrame.new(goalTopPosition, goalTopPosition + spine.CFrame.lookVector)
&#9;isMoving = true
&#9;local status = coroutine.status(platformCoroutine)
&#9;print(status)
&#9;if status==&quot;dead&quot; then
&#9;&#9;platformCoroutine = coroutine.create(platformLoop)
&#9;&#9;coroutine.resume(platformCoroutine)
&#9;end
end

function moveElevatorDown()
&#9;print(&quot;moveElevatorDown()&quot;)
&#9;switchTop.BrickColor = offColor
&#9;switchBottom.BrickColor = onColor
&#9;switchBottomWedge.BrickColor = onColor
&#9;bodyPosition.position = goalBottomPosition
&#9;bodyGyro.cframe = CFrame.new(goalTopPosition, goalTopPosition + spine.CFrame.lookVector)
&#9;isMoving = true
&#9;local status = coroutine.status(platformCoroutine)
&#9;print(status)
&#9;if status==&quot;dead&quot; then
&#9;&#9;platformCoroutine = coroutine.create(platformLoop)
&#9;&#9;coroutine.resume(platformCoroutine)
&#9;end
end

function switchTopListener(part)
&#9;print(&quot;switchTopListener():&quot;, part)
&#9;if part==nil then print(&quot;switchTopListener(): part==nil. Canceling.&quot;) return end
&#9;if part.Parent==model then print(&quot;switchTopListener(): part.Parent==elevator. Canceling.&quot;) return end
&#9;moveElevatorUp()
end

function switchBottomListener(part)
&#9;print(&quot;switchBottomListener():&quot;, part)
&#9;if part==nil then print(&quot;switchBottomListener(): part==nil. Canceling.&quot;) return end
&#9;if part.Parent==model then print(&quot;switchBottomListener(): part.Parent==elevator. Canceling.&quot;) return end
&#9;moveElevatorDown()
end

function platformListener(part)
&#9;-- when you walk onto the platform, and it&apos;s stopped at either top or bottom, trigger it after a short delay.
&#9;if part==nil then print(&quot;platformListener(): part==nil. Canceling.&quot;) return end
&#9;if part.Parent==model then print(&quot;platformListener(): part.Parent==nil. Canceling.&quot;) return end
&#9;if isMoving then print(&quot;platformListener(): isMoving==true. Canceling.&quot;) return end
&#9;if platformListenerDisabled then print (&quot;platformListener(): platformListenerDisabled==true. Canceling.&quot;) return end

&#9;print(&quot;platformListener():&quot;, part)
&#9;platformListenerDisabled = true
&#9;wait(1.5)
&#9;if(bodyPosition.position==goalBottomPosition) then
&#9;&#9;moveElevatorUp()
&#9;elseif(bodyPosition.position==goalTopPosition) then
&#9;&#9;moveElevatorDown()
&#9;else
&#9;&#9;print(&quot;Platform is somewhere in middle, and not moving.  What the heck?&quot;)
&#9;end
&#9;platformListenerDisabled = false
end

function getWeight(part)
&#9;-- Returns the force of gravity on the object
&#9;-- Useful for making things weightless
&#9;-- If part is inside a character, we get weight of the entire character.
&#9;-- Otherwise, we get weight of only this part.
&#9;local character
&#9;while part.Parent ~= nil and part.Parent ~= Workspace do
&#9;&#9;if part:FindFirstChild(&quot;Humanoid&quot;) then
&#9;&#9;&#9;character = part
&#9;&#9;end
&#9;end
&#9;local parts
&#9;if character then
&#9;&#9;-- It&apos;s a character.  Find mass of character.
&#9;&#9;parts = character:GetChildren()
&#9;else
&#9;&#9;parts = {part}
&#9;end
&#9;-- Sum up the mass of all parts
&#9;local mass = 0
&#9;for i=1,#parts do
&#9;&#9;local n = parts[i].className
&#9;&#9;if(n==&quot;Part&quot; or n==&quot;TrussPart&quot; or n==&quot;WedgePart&quot;) then
&#9;&#9;&#9;mass = mass + parts[i]:GetMass()
&#9;&#9;elseif(n==&quot;Hat&quot; or n==&quot;Tool&quot;) then
&#9;&#9;&#9;mass = mass + parts[i].Handle:GetMass()
&#9;&#9;end
&#9;end
&#9;print(&quot;getWeight(): character:&quot;, character, &quot;part:&quot;, part, &quot;mass:&quot;, mass)
end


function setGoalPositions()
&#9;local wasAlignedTo
&#9;if bodyPosition.position == goalTopPosition then wasAlignedTo = &quot;top&quot;
&#9;elseif bodyPosition.position == goalBottomPosition then wasAlignedTo = &quot;bottom&quot; end
&#9;--goalTopPosition = goalTop.Position + platformOffset*platform.CFrame.lookVector + goalPositionOffset
&#9;--goalBottomPosition = goalBottom.Position + platformOffset*platform.CFrame.lookVector + goalPositionOffset
&#9;goalTopPosition = goalTop.Position + goalPositionOffset + platformOffset * spine.CFrame.lookVector
&#9;goalBottomPosition = goalBottom.Position + goalPositionOffset + platformOffset * spine.CFrame.lookVector
&#9;if wasAlignedTo==&quot;top&quot; then bodyPosition.position = goalTopPosition bodyGyro.cframe = CFrame.new(goalTopPosition, goalTopPosition + spine.CFrame.lookVector)
&#9;elseif wasAlignedTo==&quot;bottom&quot; then bodyPosition.position = goalBottomPosition bodyGyro.cframe = CFrame.new(goalTopPosition, goalTopPosition + spine.CFrame.lookVector) end
&#9;print(&quot;setGoalPositions() top:&quot;, goalTopPosition, &quot;bottom:&quot;, goalBottomPosition)
end

function changedEvent(prop)
&#9;-- Only interested in CFrame (position + rotation) changes
&#9;if(prop ~= &quot;CFrame&quot;) then return end
&#9;print(&quot;changedEvent()&quot;, prop)
&#9;setGoalPositions()
end

function destroyElevator()
&#9;-- Destroy forces, and disable script.
&#9;print(&quot;destroyElevator()&quot;)
&#9;a = weight:GetChildren()
&#9;for i=1,#a do
&#9;&#9;a[i]:Remove()
&#9;end
&#9;-- Make switches dark
&#9;switchTop.BrickColor = offColor
&#9;switchBottom.BrickColor = offColor
&#9;switchBottomWedge.BrickColor = offColor
&#9;-- Disconnect events
&#9;pcall(function() con1:disconnect() end)
&#9;pcall(function() con2:disconnect() end)
&#9;pcall(function() con3:disconnect() end)
&#9;pcall(function() con4:disconnect() end)
&#9;pcall(function() con5:disconnect() end)
&#9;pcall(function() con6:disconnect() end)
&#9;script.Disabled = true
end

function checkIfHasWeld(part)
&#9;print(&quot;checkIfHasWeld():&quot;, part)
&#9;-- If spine and bottom have no weld, then the elevator has come unanchored and must break. (Otherwise, platform will float mid-air.)
&#9;local hasAWeld = false
&#9;local a = bottom:GetChildren()
&#9;for i=1,#a do
&#9;&#9;local c = a[i].className
&#9;&#9;if c==&quot;Weld&quot; or c==&quot;ManualWeld&quot; then hasAWeld = true end
&#9;end
&#9;local a = spine:GetChildren()
&#9;for i=1,#a do
&#9;&#9;local c = a[i].className
&#9;&#9;if c==&quot;Weld&quot; or c==&quot;ManualWeld&quot; then hasAWeld = true end
&#9;end
&#9;if not hasAWeld then destroyElevator() return end
end

setGoalPositions() -- Fire once to initialize
if (weight.Position - goalTopPosition):Dot(weight.Position - goalTopPosition) &lt; (weight.Position - goalBottomPosition):Dot(weight.Position - goalBottomPosition) then
&#9;isGoingUp = true
&#9;moveElevatorUp()
else
&#9;moveElevatorDown()
end
bodyPosition.maxForce = Vector3.new(200000, 16000, 200000)
bodyGyro.maxTorque = Vector3.new(4000000, 4000000, 4000000)
wait(1)

print(&quot;ElevatorScript: adding connections.&quot;)
local con1 = switchBottom.Touched:connect(switchBottomListener)
local con2 = switchTop.Touched:connect(switchTopListener)
local con3 = platform.Touched:connect(platformListener)
local con4 = spine.Changed:connect(changedEvent)
local con5 = spine.ChildRemoved:connect(checkIfHasWeld)
local con6 = bottom.ChildRemoved:connect(checkIfHasWeld)
print(&quot;ElevatorScript: finished adding connections.&quot;)

coroutine.resume(platformCoroutine)

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX183">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">EnergyScript</string>
				<ProtectedString name="Source">script.Parent.ConstantCurrent:SetValue(1)


--&#9;&#9;&#9;...good?


</ProtectedString>
			</Properties>
		</Item>
		<Item class="BoolValue" referent="RBX184">
			<Properties>
				<string name="Name">Finobe ID</string>
				<bool name="Value">false</bool>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX185">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FixThings</string>
				<ProtectedString name="Source">while true do
&#9;wait (.5)
&#9;&#9;for _,v in pairs(script.Parent:GetChildren()) do
&#9;&#9;&#9;if v.Name == &quot;Spikes_Simple&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;for _,q in pairs(v:GetChildren()) do
&#9;&#9;&#9;&#9;&#9;game.Lighting.SpikeScript:Clone().Parent = q
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Spike_Retracting&quot; and v:FindFirstChild(&quot;SpikeTrap&quot;) == nil then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.SpikeControlScript:Clone().Parent = v.Spikes
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;FriendOnlyDoorHostile&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.FriendDoorDeadly:Clone().Parent = v
&#9;&#9;&#9;&#9;v.FriendDoorDeadly.Name = &quot;Script&quot;
&#9;&#9;&#9;&#9;v.Script.Disabled = false
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;SpaceHatch&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;UltimateFloatPadSideways&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PadScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;UltimateFloatPad&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PadScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;e&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ElevatorScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;FriendOnlyDoor2&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ScriptFO:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Boombox&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;local controller = game.Lighting:FindFirstChild(&quot;Boombox Controller&quot;)
&#9;&#9;&#9;&#9;controller:Clone().Parent = v.Boombox
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;WireLeverSimple&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ButtonScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;ConfigPortrait&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PictureScript:Clone().Parent = v.Picture
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;ConfigPlacePicture&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PictureScripts:Clone().Parent = v.Picture
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;IrisDoor&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorScriptiris:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;LaserTrigger&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.LaserTriggerScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;LightSwitch&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.SwitchScript:Clone().Parent = v.Fixture
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;SciFiDoor&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorScriptSci:Clone().Parent = v
&#9;&#9;&#9;end
----[[
&#9;&#9;&#9;if v.Name == &quot;WiredTrapPart&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PlatformScrwipt:Clone().Parent = v.Head
&#9;&#9;&#9;end
--]]--
&#9;&#9;&#9;if v.Name == &quot;Timer&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.TimerScript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;DoorbellButton&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorbellScript:Clone().Parent = v.Fixture
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;CastleDrawbridge&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorScriptDraw:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;EnergyButton&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ButtonScriptcoil:Clone().Parent = v.Button
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Speaker&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.BoomboxController:Clone().Parent = v.Speaker
&#9;&#9;&#9;--&#9;local okcloneitok = game.Lighting:FindFirstChild(&quot;Finobe ID&quot;)
&#9;&#9;&#9;&#9;--okcloneitok:Clone().Parent = v.Configuration
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Incinerator&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.Grate:Clone().Parent = v.Grate
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;MagicBall&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.MagicScript:Clone().Parent = v:FindFirstChild(&quot;Control Sphere&quot;)
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;EnergyCore&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.EnergyScript:Clone().Parent = v.EnergyBall
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;DelayGate&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DelayScript:Clone().Parent = v.BasePart
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Repeater&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.RepeaterScript:Clone().Parent = v.BasePart
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Inverter&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.InvertScript:Clone().Parent = v.BasePart
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;ORgate&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.OrGateScript:Clone().Parent = v.BasePart
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;ANDgate&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.AndGateScript:Clone().Parent = v.BasePart
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Lamp&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.LightScript:Clone().Parent = v.Light
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;WiredButton1&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ButtonScriptOK:Clone().Parent = v.Button
&#9;&#9;&#9;end
&#9;&#9;&#9;----[[
&#9;&#9;&#9;if v.Name == &quot;Flame Thrower&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ScriptFT:Clone().Parent = v.Flamethrower
&#9;&#9;&#9;end
&#9;&#9;--&#9;]]--
&#9;&#9;&#9;if v.Name == &quot;TransparentTrigger&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.ScriptSSS:Clone().Parent = v.Part
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;AppearingPlatformModel&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.PlatformScript:Clone().Parent = v.AppearingPlatform
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;WiringDoor&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.DoorScriptWIRING:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Trapdoor&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.Trapscript:Clone().Parent = v.Head
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name == &quot;Head&quot; then
&#9;&#9;&#9;&#9;
&#9;&#9;&#9;&#9;game.Lighting.Trapscript:Clone().Parent = v
&#9;&#9;&#9;end
&#9;&#9;&#9;if v.Name ~= &quot;FixThings&quot; then
&#9;&#9;&#9;&#9;v.Parent = game.Workspace
&#9;&#9;&#9;end&#9;
&#9;&#9;end
end

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX186">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">FriendDoorDeadly</string>
				<ProtectedString name="Source">-- useless comment

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local debris = game:GetService(&quot;Debris&quot;)

print(&quot;Starting script&quot;)

local door = script.Parent
waitForChild(door, &quot;PlayerIdTag&quot;)

print(&quot;Getting ownerId&quot;)

local ownerId = door.PlayerIdTag.Value
waitForChild(door, &quot;Poster&quot;)
local poster = door.Poster.Decal
poster.Texture = &quot;http://www.pengin.xyz/thumbs/avatar.ashx?userId=&quot; .. tostring(ownerId) .. &quot;&amp;x=352&amp;y=352&quot;

print(&quot;Getting Lasers&quot;)

waitForChild(door, &quot;Laser1&quot;)
waitForChild(door, &quot;Laser2&quot;)
waitForChild(door, &quot;Laser3&quot;)

waitForChild(door, &quot;Bottom&quot;)

local laser1 = door.Laser1
local laser2 = door.Laser2
local laser3 = door.Laser3

local laserWeld1 = door:FindFirstChild(&quot;LaserWeld1&quot;)
if not laserWeld1 then
&#9;laserWeld1 = Instance.new(&quot;ManualWeld&quot;)
&#9;laserWeld1.Name = &quot;LaserWeld1&quot;
&#9;laserWeld1.Part0 = laser1
&#9;laserWeld1.Part1 = door.Bottom
&#9;laserWeld1.C0 = laser1.CFrame:inverse() * door.Bottom.CFrame
&#9;laserWeld1.Parent = door
&#9;laser1.Anchored = false
else
&#9;laserWeld1.C0 = laser1.CFrame:inverse() * door.Bottom.CFrame
end

local laserWeld2 = door:FindFirstChild(&quot;LaserWeld2&quot;)
if not laserWeld2 then
&#9;laserWeld2 = Instance.new(&quot;ManualWeld&quot;)
&#9;laserWeld2.Name = &quot;LaserWeld2&quot;
&#9;laserWeld2.Part0 = laser2
&#9;laserWeld2.Part1 = door.Bottom
&#9;laserWeld2.C0 = laser2.CFrame:inverse() * door.Bottom.CFrame
&#9;laserWeld2.Parent = door
&#9;laser2.Anchored = false
else
&#9;laserWeld2.C0 = laser2.CFrame:inverse() * door.Bottom.CFrame
end

local laserWeld3 = door:FindFirstChild(&quot;LaserWeld3&quot;)
if not laserWeld3 then
&#9;laserWeld3 = Instance.new(&quot;ManualWeld&quot;)
&#9;laserWeld3.Name = &quot;LaserWeld3&quot;
&#9;laserWeld3.Part0 = laser3
&#9;laserWeld3.Part1 = door.Bottom
&#9;laserWeld3.C0 = laser3.CFrame:inverse() * door.Bottom.CFrame
&#9;laserWeld3.Parent = door
&#9;laser3.Anchored = false
else
&#9;laserWeld3.C0 = laser3.CFrame:inverse() * door.Bottom.CFrame
end

local lasers = {laser1, laser2, laser3}
local laserWelds = {laserWeld1, laserWeld2, laserWeld3}

print(&quot;Defining fcns&quot;)

local laserTextures = {}
for i = 1, #lasers do
&#9;laserTextures[2*i-1] = lasers[i].Decal1.Texture
&#9;laserTextures[2*i] = lasers[i].Decal2.Texture
end

waitForChild(door, &quot;Wedge1&quot;)
waitForChild(door, &quot;Wedge2&quot;)
local Wedge1 = door.Wedge1
local Wedge2 = door.Wedge2

local wedge1 = Wedge1.Position
local wedge2 = Wedge2.Position

function burninatePlayer(vChar)
&#9;--vChar.Head:remove() -- for now, simple kill
&#9;if vChar:FindFirstChild(&quot;Torso&quot;) then
&#9;&#9;vChar.Torso:BreakJoints()
&#9;&#9;littleParts = vChar:GetChildren()
&#9;&#9;for i = 1, #littleParts do
&#9;&#9;&#9;if littleParts[i]:IsA(&quot;Part&quot;) or littleParts[i]:IsA(&quot;TrussPart&quot;) or littleParts[i]:IsA(&quot;WedgePart&quot;) then
&#9;&#9;&#9;&#9;if littleParts[i]:FindFirstChild(&quot;Burrrrrn&quot;) == nil then
&#9;&#9;&#9;&#9;&#9;tempFire = Instance.new(&quot;Fire&quot;)
&#9;&#9;&#9;&#9;&#9;tempFire.Name = &quot;Burrrrrn&quot;
&#9;&#9;&#9;&#9;&#9;tempFire.Parent = littleParts[i]
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function shutOffLasers()
&#9;lasers[#lasers].CanCollide = false
&#9;for i = 1, #lasers do
&#9;&#9;lasers[i].Decal1.Texture = &quot;&quot;
&#9;&#9;lasers[i].Decal2.Texture = &quot;&quot;
&#9;end
end

function turnOnLasers()
&#9;lasers[#lasers].CanCollide = true
&#9;for i = 1, #lasers do
&#9;&#9;lasers[i].Decal1.Texture = laserTextures[2*i-1]
&#9;&#9;lasers[i].Decal2.Texture = laserTextures[2*i]
&#9;end
end

function flickerOnLasers()
&#9;for i = 1, #lasers do
&#9;&#9;coinFlip = math.random(0,1)
&#9;&#9;if coinFlip == 0 then
&#9;&#9;&#9;lasers[i].Decal1.Texture = laserTextures[2*i-1]
&#9;&#9;&#9;lasers[i].Decal2.Texture = laserTextures[2*i]
&#9;&#9;end
&#9;end
end

function flickerOffLasers()
&#9;for i = 1, #lasers do
&#9;&#9;coinFlip = math.random(0,1)
&#9;&#9;if coinFlip == 0 then
&#9;&#9;&#9;lasers[i].Decal1.Texture = &quot;&quot;
&#9;&#9;&#9;lasers[i].Decal2.Texture = &quot;&quot;
&#9;&#9;end
&#9;end
end

function accessGranted(part)
-- prevent outside collisions (as extremities can &quot;poke through&quot; walls)&#9;
&#9;if part.Name == &quot;Right Leg&quot; or part.Name == &quot;Left Leg&quot; or part.Name == &quot;Right Arm&quot; or part.Name == &quot;Left Arm&quot; then return false end

&#9;if part == nil then return false end
&#9;pChar = part.Parent
&#9;if pChar == nil then return false end
&#9;pPlay = game.Players:GetPlayerFromCharacter(pChar)
&#9;if pPlay == nil then return false end
&#9;-- insert friend code here...  currently, door will open at a humanoid&apos;s touch

&#9;if (pPlay:IsFriendsWith(ownerId)) then return true end
&#9;burninatePlayer(pChar)
&#9;return false
&#9;--return true
end

--local lasersOn = {true, true, true}

local lasersOn = true

function checkHit(part)
&#9;if not part or not part.Parent then return end
&#9;local didItHit = accessGranted(part)
&#9;if lasersOn and didItHit then
&#9;&#9;-- win
&#9;&#9;lasersOn = false
&#9;&#9;shutOffLasers()
&#9;&#9;wait(5)
&#9;&#9;flickerOnLasers()
&#9;&#9;wait(.1)
&#9;&#9;flickerOffLasers()
&#9;&#9;wait(.2)
&#9;&#9;flickerOnLasers()
&#9;&#9;wait(.1)
&#9;&#9;flickerOffLasers()
&#9;&#9;wait(.1)
&#9;&#9;turnOnLasers()
&#9;&#9;lasersOn = true
&#9;end
end

for i = 1, #lasers do
&#9;lasers[i].Touched:connect(checkHit)
end

--[[for i = 1, #lasers do
&#9;lasers[i].Touched:connect(function (part) 
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;if lasersOn[i] and not accessGranted(part) then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;-- win
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasersOn[i] = false
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(5)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = laserTextures[2*i-1]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = laserTextures[2*i]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(.1)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(.2)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = laserTextures[2*i-1]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = laserTextures[2*i]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(.1)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = &quot;&quot;
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;wait(.1)
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal1.Texture = laserTextures[2*i-1]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasers[i].Decal2.Texture = laserTextures[2*i]
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;lasersOn[i] = true
&#9;end
&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;&#9;end)
end

--]]

print(&quot;fodhv ended&quot;)


local laserVelocities = {Vector3.new(0,0,0.5), Vector3.new(0,0,-0.5), Vector3.new(0,0,0)}

local dir = (wedge2 - wedge1).unit
--[[for i = 1, #lasers do
&#9;&#9;coinFlip = math.random(0,1)
&#9;&#9;if coinFlip == 0 then
&#9;&#9;&#9;--lasers[i].Velocity = dir / 2
&#9;&#9;&#9;lasers[i].Velocity = Vector3.new(1,0,0)/2
&#9;&#9;else
&#9;&#9;&#9;--lasers[i].Velocity = -dir / 2
&#9;&#9;&#9;lasers[i].Velocity = -Vector3.new(1,0,0)/2
&#9;&#9;end
end]]--

local dist = math.sqrt((wedge2 - wedge1):Dot(wedge2 - wedge1))

local loopGo = true
while loopGo do
&#9;wedge1 = Wedge1.Position
&#9;wedge2 = Wedge2.Position&#9;
&#9;dir = (wedge2 - wedge1).unit
&#9;loopGo = false
&#9;for i = 1, #lasers-1 do
&#9;&#9;if lasers[i] ~= nil and lasers[i].Parent ~= nil then
&#9;&#9;&#9;--if (lasers[i].Position-wedge1):Dot(dir) &lt;= 0 or (lasers[i].Position - wedge1):Dot(dir) &gt; dist then laserVelocities[i] = -laserVelocities[i] end
&#9;&#9;&#9;--lasers[i].CFrame = lasers[i].CFrame + lasers[i].Velocity

&#9;&#9;&#9;if (lasers[i].Position-wedge1-dir*.5):Dot(dir) &lt;= 0 then  -- extra -dir*.5 so that it breaks one step early and returns without expanding bounding box
&#9;&#9;&#9;&#9;--laserVelocities[i] = -laserVelocities[i]
&#9;&#9;&#9;&#9;laserVelocities[i] = Vector3.new(0, 0, 0.5)
&#9;&#9;&#9;elseif (lasers[i].Position - wedge1):Dot(dir) &gt; dist then
&#9;&#9;&#9;&#9;--laserVelocities[i] = -laserVelocities[i]
&#9;&#9;&#9;&#9;laserVelocities[i] = Vector3.new(0, 0, -0.5)
&#9;&#9;&#9;end

&#9;&#9;&#9;if laserWelds[i] ~= nil and laserWelds[i].Parent ~= nil then laserWelds[i].C0 = laserWelds[i].C0 + laserVelocities[i] loopGo = true
&#9;&#9;&#9;else 
&#9;&#9;&#9;&#9;-- laser dead; make sure we remove it [commented out for now, since this gets triggered when we rotate the model (since scripts aren&apos;t currently stopped correctly)]
&#9;&#9;&#9;&#9;--lasers[i].Parent = nil
&#9;&#9;&#9;&#9;loopGo = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
&#9;wait(.1)
end

-- if we get here, then all three laserWelds have been killed X|
debris:AddItem(door, 15)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX187">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">Grate</string>
				<ProtectedString name="Source">--


sp=script.Parent

function incinerate(part)
&#9;if part and sp.Fire.Enabled then
&#9;&#9;if part.Parent then
&#9;&#9;&#9;if part.Parent~=sp.Parent and not part.Anchored then
&#9;&#9;&#9;&#9;part:BreakJoints()
&#9;&#9;&#9;&#9;part.BrickColor=BrickColor.new(&quot;Black&quot;)
&#9;&#9;&#9;&#9;delay(sp.Configuration.IncinerationSpeed.Value,function()
&#9;&#9;&#9;&#9;&#9;if part then
&#9;&#9;&#9;&#9;&#9;&#9;if part.Parent~=nil then
&#9;&#9;&#9;&#9;&#9;&#9;&#9;part:remove()
&#9;&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;end)
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

sp.Touched:connect(incinerate)

function check(val)
&#9;if val==1 then
&#9;&#9;sp.Fire.Enabled=true
&#9;&#9;initialparts=game.Workspace:FindPartsInRegion3(Region3.new(sp.Position+Vector3.new(-sp.Size.x/2,.4,-sp.Size.z/2),sp.Position+Vector3.new(sp.Size.x/2,3,sp.Size.z/2)),nil,100)
&#9;&#9;for i,v in ipairs(initialparts) do
&#9;&#9;&#9;incinerate(v)
&#9;&#9;end
&#9;else
&#9;&#9;sp.Fire.Enabled=false
&#9;end
end

sp.Input.SourceValueChanged:connect(check)
check(sp.Input:GetCurrentValue())




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX188">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">InvertScript</string>
				<ProtectedString name="Source">--





sp=script.Parent


function check(val)
&#9;if val==0 then
&#9;&#9;sp.Output:SetValue(1)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light2Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;sp.Output:SetValue(0)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;end
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light2Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;end
end

sp.InvertInput.SourceValueChanged:connect(check)
check(sp.InvertInput:GetCurrentValue())




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX189">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LaserTriggerScript</string>
				<ProtectedString name="Source">--Stickmasterluke


sp=script.Parent

recasttime=.15
maxdist=50
leeway=.1

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Configuration&quot;)
waitForChild(sp,&quot;Base&quot;)
waitForChild(sp.Base,&quot;LaserTrigger&quot;)
waitForChild(sp,&quot;Laser&quot;)
waitForChild(sp.Laser,&quot;Mesh&quot;)
waitForChild(sp,&quot;Configuration&quot;)
lastdist=sp.Configuration.Distance.Value
dist=lastdist
running=false

function updatelaser()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;while running and sp.Laser.Transparency&lt;1 do
&#9;&#9;&#9;sp.Laser.Transparency=sp.Laser.Transparency+.05
&#9;&#9;&#9;wait(.15)
&#9;&#9;end
&#9;&#9;running=false
&#9;end
end
updatelaser()

function raycast(spos,vec,totaldist,currentdist)
&#9;local hit2,pos2=game.Workspace:FindPartOnRay(Ray.new(spos+(vec*.01),vec*(totaldist-currentdist)),sp)
&#9;if hit2~=nil and pos2 then
&#9;&#9;if hit2.Transparency&gt;=.5 then
&#9;&#9;&#9;local currentdist=currentdist+(pos2-spos).magnitude
&#9;&#9;&#9;return raycast(pos2,vec,totaldist,currentdist)
&#9;&#9;end
&#9;end
&#9;return hit2,pos2
end

while true do
&#9;wait(1/sp.Configuration.RaysPerSecond.Value)
&#9;if sp.Base:FindFirstChild(&quot;Weld&quot;) then
&#9;&#9;lastdist=dist
&#9;&#9;local vec=((sp.Laser.CFrame*CFrame.new(0,1,0)).p-sp.Laser.Position).unit
&#9;&#9;hit,pos=raycast(sp.Laser.Position,vec,sp.Configuration.Distance.Value,0)
&#9;&#9;--hit,pos=game.Workspace:FindPartOnRay(Ray.new(sp.Laser.Position,vec*(sp.Configuration.Distance.Value)),sp)
&#9;&#9;if hit~=nil then
&#9;&#9;&#9;dist=(sp.Laser.Position-pos).magnitude
&#9;&#9;else
&#9;&#9;&#9;dist=sp.Configuration.Distance.Value
&#9;&#9;end
&#9;&#9;sp.Laser.Mesh.Scale=Vector3.new(.2,dist*(1/sp.Laser.Size.y),.2)
&#9;&#9;sp.Laser.Mesh.Offset=Vector3.new(0,(dist/2)-.1,0)
&#9;&#9;if math.abs(lastdist-dist)&gt;leeway then
&#9;&#9;&#9;sp.Base.LaserTrigger:SetValue(1)
&#9;&#9;&#9;sp.Laser.Transparency=.5
&#9;&#9;&#9;delay(0,updatelaser)
&#9;&#9;else
&#9;&#9;&#9;sp.Base.LaserTrigger:SetValue(0)
&#9;&#9;end
&#9;&#9;--[[if math.random()&lt;(1/15)*(1/sp.Configuration.RaysPerSecond.Value) then
&#9;&#9;&#9;sp.Laser.Transparency=.75
&#9;&#9;&#9;delay(0,updatelaser)
&#9;&#9;end]]
&#9;end
end




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX190">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">LightScript</string>
				<ProtectedString name="Source">--





sp=script.Parent

sp.Luminate.SourceValueChanged:connect(function(val)
&#9;if val==1 then
&#9;&#9;sp.BrickColor=BrickColor.new(&quot;New Yeller&quot;)
&#9;&#9;sp.Transparency=0
&#9;&#9;sp.Sparkles.Enabled=true
&#9;elseif val==0 then
&#9;&#9;sp.BrickColor=BrickColor.new(&quot;Medium stone grey&quot;)
&#9;&#9;sp.Transparency=.5
&#9;&#9;sp.Sparkles.Enabled=false
&#9;end
end)





</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX191">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">MagicScript</string>
				<ProtectedString name="Source">--





sp=script.Parent

sp.ClickDetector.MouseClick:connect(function()
&#9;sp.Fire.Enabled=not sp.Fire.Enabled
&#9;if sp.Fire.Enabled then
&#9;&#9;sp.Magic:SetValue(1)
&#9;else
&#9;&#9;sp.Magic:SetValue(0)
&#9;end
end)




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX192">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">OrGateScript</string>
				<ProtectedString name="Source">--





sp=script.Parent

local inputs={sp.Input1:GetCurrentValue(),sp.Input2:GetCurrentValue()}

function check()
&#9;if inputs[1]&gt;.5 and sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;else
&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;end
&#9;if inputs[2]&gt;.5 and sp.Parent:FindFirstChild(&quot;Light2Color&quot;) then
&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;else
&#9;&#9;sp.Parent.Light2Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;end
&#9;if inputs[1]&gt;.5 or inputs[2]&gt;.5 then
&#9;&#9;sp.Output:SetValue(1)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light3Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light3Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;end
&#9;else
&#9;&#9;sp.Output:SetValue(0)
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light3Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light3Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;end
end

sp.Input1.SourceValueChanged:connect(function(val)
&#9;inputs[1]=val
&#9;check()
end)

sp.Input2.SourceValueChanged:connect(function(val)
&#9;inputs[2]=val
&#9;check()
end)

check()

</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX193">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PadScript</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local pad = script.Parent
waitForChild(pad, &quot;Base&quot;)
waitForChild(pad, &quot;FakeBase&quot;)
waitForChild(pad, &quot;Configuration&quot;)
waitForChild(pad.Configuration, &quot;Height&quot;)
waitForChild(pad.Configuration, &quot;Speed&quot;)
waitForChild(pad, &quot;UpFacingWedge&quot;)

local base = pad.Base
local base2 = pad.FakeBase
local height = pad.Configuration.Height
local speed = pad.Configuration.Speed

local debris = game:GetService(&quot;Debris&quot;)
local r = game:GetService(&quot;RunService&quot;)

local airDir = pad.UpFacingWedge.CFrame.lookVector

-- animation variables
local continueAnimation = false

waitForChild(base, &quot;Fire&quot;)
waitForChild(base, &quot;Smoke&quot;)

local onColor = BrickColor.new(&quot;Toothpaste&quot;)
local offColor = BrickColor.new(&quot;Really blue&quot;)


function truncate(value)
&#9;if value &lt; .5 then return 0
&#9;else return 1 end
end

function zeroOut(value)
&#9;if math.abs(value) &lt; .01 then return 0
&#9;else return 1 end
end

local dX = Vector3.new(0,0,0)
local dY = base.CFrame.lookVector
local truncatedAirDir = Vector3.new(zeroOut(airDir.X), zeroOut(airDir.Y), zeroOut(airDir.Z))
function updateAirDirection()
&#9;airDir = pad.UpFacingWedge.CFrame.lookVector
&#9;dY = base.CFrame.lookVector -- we assume when upFacingWedge changes, so too does base
&#9;dX = airDir:Cross(dY)
&#9;truncatedAirDir = Vector3.new(zeroOut(airDir.X), zeroOut(airDir.Y), zeroOut(airDir.Z))
end

local debounce = false
function touchHandler(part)
&#9;if part == nil then return end
&#9;if part.Anchored then return end
&#9;while debounce do wait() end
&#9;if(part.Parent:FindFirstChild(&quot;Humanoid&quot;) ~= nil) then
&#9;&#9;-- If part is the arm or leg of a humanoid, then move everything to the torso.
&#9;&#9;-- This is so we can&apos;t double up forces on a humanoid (scripts inside each leg, arm, etc)
&#9;&#9;waitForChild(part.Parent, &quot;Torso&quot;)
&#9;&#9;part = part.Parent.Torso
&#9;end

&#9;-- below case necessary for hats and tools (don&apos;t want to float them separately)
&#9;if (part.Parent.Parent ~= nil and part.Parent.Parent:FindFirstChild(&quot;Humanoid&quot;) ~= nil) then
&#9;&#9;waitForChild(part.Parent.Parent, &quot;Torso&quot;)
&#9;&#9;part = part.Parent.Parent.Torso
&#9;end

&#9;debounce = true

&#9;local newBV = part:FindFirstChild(&quot;FloatMe&quot;)

&#9;if newBV ~= nil then
&#9;&#9;if math.abs(newBV.velocity:Dot(airDir)) &gt; speed.ConstrainedValue then debounce = false return end

&#9;&#9;newBV.velocity = speed.ConstrainedValue*airDir + newBV.velocity - newBV.velocity:Dot(airDir)*airDir
&#9;&#9;newBV.maxForce = truncatedAirDir*Vector3.new(newBV.P, newBV.P, newBV.P)
&#9;else
&#9;&#9;-- make new float force
&#9;&#9;newBV = Instance.new(&quot;BodyVelocity&quot;)
&#9;&#9;newBV.Name = &quot;FloatMe&quot;
&#9;&#9;newBV.P = 100000

&#9;&#9;newBV.velocity = speed.ConstrainedValue * airDir
&#9;&#9;newBV.maxForce = truncatedAirDir*Vector3.new(newBV.P, newBV.P, newBV.P)

&#9;&#9;newBV.Parent = part
&#9;&#9;debris:AddItem(newBV, .5) -- force disappears after .5 seconds
&#9;end

&#9;continueAnimation = true
&#9;debounce = false
end

-- to use the region3 or raycast code, unfortunately, we still have to poll
pad.UpFacingWedge.Changed:connect(updateAirDirection)

local lastOn = 0
local curTime = 0
local wasOn = false

local baseSize = base.Size.X / 6 -- we assume square base, and want to travel 1/6 from the center, so we divide region into 3rds

while true do&#9;&#9;
&#9;continueAnimation = false
&#9;currTime = r.Stepped:wait()  -- serves as the loop wait; want this to be as fast as possible

&#9;-- pass up to 4 parts (first parts caught by the rays) to our touchHandler every polling period
&#9;for xStep = -1, 1, 2 do
&#9;&#9;for yStep = -1, 1, 2 do
&#9;&#9;&#9;touchHandler(game.Workspace:FindPartOnRay(Ray.new(base.Position + xStep * dX * baseSize + yStep * dY * baseSize , height.ConstrainedValue * airDir), pad))
&#9;&#9;end
&#9;end

&#9;if continueAnimation then 
&#9;&#9;base.BrickColor = onColor
&#9;&#9;base.Fire.Enabled = true
&#9;&#9;base.Smoke.Enabled = true
&#9;&#9;lastOn = currTime
&#9;&#9;wasOn = true
&#9;else
&#9;&#9;base.Fire.Enabled = false
&#9;&#9;--wait(0.5)
&#9;&#9;-- only shut off smoke and change brick color if it&apos;s been at least .5 seconds since blast pad was active
&#9;&#9;if currTime - lastOn &gt; .5 and wasOn then
&#9;&#9;&#9;base.Smoke.Enabled = false
&#9;&#9;&#9;base.BrickColor = offColor
&#9;&#9;&#9;wasOn = false
&#9;&#9;end
&#9;end
end
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX194">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PictureScript</string>
				<ProtectedString name="Source">--Stickmasterluke


sp=script.Parent

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Configuration&quot;)
waitForChild(sp,&quot;Decal&quot;)
waitForChild(sp.Configuration,&quot;Player Name&quot;)

playername=sp.Configuration[&quot;Player Name&quot;]

function check()
&#9;if playername and playername.Parent~=nil and sp:FindFirstChild(&quot;Decal&quot;) then
&#9;&#9;sp.Decal.Texture=&quot;http://www.pengin.xyz/Thumbs/Avatar.ashx?x=200&amp;y=200&amp;Format=Png&amp;username=&quot;..playername.Value
&#9;end
end

check()
playername.Changed:connect(check)


</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX195">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PictureScripts</string>
				<ProtectedString name="Source">--Stickmasterluke


sp=script.Parent

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

waitForChild(sp,&quot;Configuration&quot;)
waitForChild(sp,&quot;Decal&quot;)
waitForChild(sp.Configuration,&quot;Place Id&quot;)

placeid=sp.Configuration[&quot;Place Id&quot;]

function check()
&#9;if placeid and placeid.Parent~=nil and sp:FindFirstChild(&quot;Decal&quot;) then
&#9;&#9;sp.Decal.Texture=&quot;http://www.pengin.xyz/Thumbs/Asset.ashx?format=png&amp;width=420&amp;height=230&amp;assetId=&quot;..placeid.Value
&#9;end
end

check()
placeid.Changed:connect(check)


</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX196">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PlatformScript</string>
				<ProtectedString name="Source">local platform = script.Parent

function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
end

waitForChild(platform, &quot;Configuration&quot;)
local config = platform.Configuration

waitForChild(config, &quot;Time&quot;)
local maxTime = config.Time

local appearTime = 0

local platformCoroutine = nil

-- start platform off as mostly transparent
platform.Transparency = .8
platform.CanCollide = false

function runPlatform()
&#9;local timeStep = 0

&#9;while appearTime &gt; 0 do
&#9;&#9;if (appearTime &gt; .2 * maxTime.Value) then
&#9;&#9;&#9;-- do nothing during this time
&#9;&#9;else
&#9;&#9;&#9;-- fade out
&#9;&#9;&#9;platform.Transparency = .8*(1 - appearTime/(.2*maxTime.Value))
&#9;&#9;end
&#9;&#9;timeStep = wait()
&#9;&#9;appearTime = appearTime - timeStep
&#9;end
&#9;platform.Transparency = .8
&#9;platform.CanCollide = false
end

platform.MakeAppear.SourceValueChanged:connect(function(val)
&#9;if val &gt; 0 then
&#9;&#9;appearTime = math.max(maxTime.Value,appearTime)
&#9;&#9;platform.Transparency = 0
&#9;&#9;platform.CanCollide = true
&#9;&#9;if not platformCoroutine or coroutine.status(platformCoroutine) == &quot;dead&quot; then
&#9;&#9;&#9;-- need a new coroutine
&#9;&#9;&#9;platformCoroutine = coroutine.create(runPlatform)
&#9;&#9;&#9;coroutine.resume(platformCoroutine)
&#9;&#9;end
&#9;end
end)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX197">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">PlatformScrwipt</string>
				<ProtectedString name="Source">local platform = script.Parent

function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
end

waitForChild(platform, &quot;Configuration&quot;)
local config = platform.Configuration

waitForChild(config, &quot;Time&quot;)
local maxTime = config.Time

local appearTime = 0

local platformCoroutine = nil

-- start platform off as normal block
platform.Transparency = 0
platform.CanCollide = true

function runPlatform()
&#9;local timeStep = 0

&#9;while appearTime &gt; 0 do
&#9;&#9;if (appearTime &gt; .2 * maxTime.ConstrainedValue) then
&#9;&#9;&#9;-- do nothing during this time
&#9;&#9;else
&#9;&#9;&#9;-- fade back in
&#9;&#9;&#9;platform.Transparency = 1*appearTime/(.2*maxTime.Value)
&#9;&#9;&#9;if appearTime &lt; .1*maxTime.Value then
&#9;&#9;&#9;&#9;platform.CanCollide = true
&#9;&#9;&#9;end
&#9;&#9;end
&#9;&#9;timeStep = wait()
&#9;&#9;appearTime = appearTime - timeStep
&#9;end
&#9;platform.Transparency = 0
end

platform.MakeDisappear.SourceValueChanged:connect(function(val)
&#9;if val &gt; .5 then
&#9;&#9;appearTime = math.max(maxTime.Value, appearTime)
&#9;&#9;platform.Transparency = 1
&#9;&#9;platform.CanCollide = false
&#9;&#9;if not platformCoroutine or coroutine.status(platformCoroutine) == &quot;dead&quot; then
&#9;&#9;&#9;-- need a new coroutine
&#9;&#9;&#9;platformCoroutine = coroutine.create(runPlatform)
&#9;&#9;&#9;coroutine.resume(platformCoroutine)
&#9;&#9;end
&#9;end
end)


d1=platform:FindFirstChild(&quot;Decal1&quot;)
if d1 then
&#9;d1:Remove()
end
d2=platform:FindFirstChild(&quot;Decal2&quot;)
if d2 then
&#9;d2:Remove()
end
d3=platform:FindFirstChild(&quot;Decal3&quot;)
if d3 then
&#9;d3:Remove()
end
d4=platform:FindFirstChild(&quot;Decal4&quot;)
if d4 then
&#9;d4:Remove()
end



</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX198">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">RepeaterScript</string>
				<ProtectedString name="Source">--





sp=script.Parent


--method #1
on=false
shutdown=false

function check(val)
&#9;if val==1 then
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Dark green&quot;)
&#9;&#9;end
&#9;&#9;shutdown=false
&#9;&#9;if not on then
&#9;&#9;&#9;on=true
&#9;&#9;&#9;while true do
&#9;&#9;&#9;&#9;sp.RepeaterOutput:SetValue(1)
&#9;&#9;&#9;&#9;wait(sp.Configuration.TimeOn.Value)
&#9;&#9;&#9;&#9;sp.RepeaterOutput:SetValue(0)
&#9;&#9;&#9;&#9;wait(sp.Configuration.TimeOff.Value)
&#9;&#9;&#9;&#9;if shutdown then
&#9;&#9;&#9;&#9;&#9;break
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;end
&#9;&#9;&#9;shutdown=false
&#9;&#9;&#9;on=false
&#9;&#9;end
&#9;elseif val==0 then
&#9;&#9;if sp.Parent:FindFirstChild(&quot;Light1Color&quot;) then
&#9;&#9;&#9;sp.Parent.Light1Color.BrickColor=BrickColor.new(&quot;Bright red&quot;)
&#9;&#9;end
&#9;&#9;shutdown=true
&#9;end
end

sp.Input.SourceValueChanged:connect(check)
check(sp.Input:GetCurrentValue())

--method #2&#9;&#9;con: does not start exactly when powered
--[[while true do
&#9;sp.RepeaterOutput:SetValue(sp.Input:GetCurrentValue())
&#9;wait(sp.Configuration.TimeOn.Value)
&#9;sp.RepeaterOutput:SetValue(0)
&#9;wait(sp.Configuration.TimeOff.Value)
end]]


</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX199">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ScriptFO</string>
				<ProtectedString name="Source">-- useless comment

function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end

local model = script.Parent
waitForChild(model, &quot;PlayerNameTag&quot;)
waitForChild(model, &quot;PlayerIdTag&quot;)
waitForChild(model, &quot;PlayerNameTag&quot;)
waitForChild(model, &quot;Wedge1&quot;)
waitForChild(model, &quot;Wedge2&quot;)
waitForChild(model, &quot;Door1&quot;)
waitForChild(model, &quot;Door2&quot;)
waitForChild(model, &quot;Side1&quot;)
waitForChild(model, &quot;Side2&quot;)
waitForChild(model, &quot;Door1Hinge1&quot;)
waitForChild(model, &quot;Door1Hinge2&quot;)
waitForChild(model, &quot;Door2Hinge1&quot;)
waitForChild(model, &quot;Door2Hinge2&quot;)
waitForChild(model, &quot;UnderDoors&quot;)
waitForChild(model, &quot;Mode&quot;)
waitForChild(model, &quot;Bottom&quot;)
waitForChild(model, &quot;Head&quot;)

local doorOwnerId = model.PlayerIdTag.Value
local doorOwnerName = model.PlayerNameTag.Value

local door1 = model.Door1
local door2 = model.Door2
local wedge1 = model.Wedge1
local wedge2 = model.Wedge2
local side1 = model.Side1
local side2 = model.Side2
local top = model.Head
local head = model.Head
local bottom = model.Bottom
local underDoors = model.UnderDoors
local door1bp = model.Door1.BodyPosition
local door2bp = model.Door2.BodyPosition
local lookVector
local mode = model.Mode
local weld1 = nil
local weld2 = nil

-- SETTINGS
local offColor = BrickColor.new(&quot;Earth green&quot;)
local onColor  = BrickColor.new(&quot;Lime green&quot;)
local openForce = 300 -- maxForce when off (should let doors swing)
local closedForce = 2000 -- maxForce when on (should prevent players pushing doors open)
local currentForce = closedForce
local doorOpenTime = 3

local isOpen = false

--[[
-- Owner Image stuff
waitForChild(model, &quot;DoorSign1&quot;)
waitForChild(model.DoorSign1, &quot;Decal&quot;)

local pic = model.DoorSign1.Decal
pic.Texture = &quot;http://www.pengin.xyz/thumbs/avatar.ashx?userId=&quot;.. doorOwnerId ..&quot;&amp;x=352&amp;y=352&quot;

waitForChild(model, &quot;DoorSign2&quot;)
waitForChild(model.DoorSign2, &quot;Decal&quot;)

local otherSide = model.DoorSign2.Decal
otherSide.Texture = &quot;http://www.pengin.xyz/thumbs/avatar.ashx?userId=&quot;.. doorOwnerId ..&quot;&amp;x=352&amp;y=352&quot;
--]]

function setDoorForces()
&#9;local f = lookVector * currentForce
&#9;door1bp.maxForce = f
&#9;door2bp.maxForce = f
&#9;print(&quot;door forces:&quot;, f)
end

function doorOpen()
&#9;print(&quot;doorOpen()&quot;)
&#9;isOpen = true
&#9;if(weld1 ~= nil) then weld1:Remove() end
&#9;if(weld2 ~= nil) then weld2:Remove() end
&#9;top.BrickColor = onColor
&#9;currentForce = openForce
&#9;setDoorForces()
end

function doorClose()
&#9;print(&quot;doorClose()&quot;)
&#9;isOpen = false
&#9;top.BrickColor = offColor
&#9;currentForce = closedForce
&#9;setDoorForces()
&#9;wait(0.3)
&#9;-- Weld doors
&#9;weld1 = Instance.new(&quot;Weld&quot;)
&#9;weld2 = Instance.new(&quot;Weld&quot;)
&#9;weld1.Part0 = door1
&#9;weld1.Part1 = bottom
&#9;weld2.Part0 = door2
&#9;weld2.Part1 = bottom
--&#9;weld1.C0 = door1
--&#9;weld1.C1 =  bottom.CFrame:inverse() * door1.CFrame
--&#9;weld2.C0 = door2
&#9;--weld2.C1 = bottom.CFrame:inverse() * door2.CFrame
&#9;weld1.C1 = CFrame.Angles(0,math.pi,0) + Vector3.new(0, 4, -1.71)
&#9;weld2.C1 = CFrame.new() + Vector3.new(0, 4, 1.71)
&#9;weld1.Parent = door1
&#9;weld2.Parent = door2
end

function testPermission2(part)
&#9;return true
end

function debug(a)
&#9;print(&quot;debug:&quot;, a)
&#9;model.Name = a
end

function testPermission(part)
&#9;print(&quot;testPermission:&quot;, part.Name)
&#9;doorOwnerId = model.PlayerIdTag.Value  -- Update the owner ID
&#9;if part == nil then return false end   -- In case part was deleted
&#9;local pChar = part.Parent
&#9;if pChar == nil then return false end
&#9;local pPlay = game.Players:GetPlayerFromCharacter(pChar)  -- In case player left game
&#9;if not pPlay then return false end

&#9;-- Test permissions
&#9;if(mode.Value == &quot;true&quot; or mode.Value == &quot;debug&quot;) then
&#9;&#9;debug(&quot;debug mode always true&quot;)
&#9;&#9;return true
&#9;elseif(mode.Value == &quot;friend&quot;) then
&#9;&#9;if (pPlay:IsFriendsWith(doorOwnerId)) then 
&#9;&#9;&#9;debug(pPlay.Name .. &quot; is friends with &quot; .. doorOwnerId)
&#9;&#9;&#9;return true 
&#9;&#9;else
&#9;&#9;&#9;debug(pPlay.Name .. &quot; is NOT friends with &quot; .. doorOwnerId)
&#9;&#9;end
&#9;elseif(mode.Value == &quot;bestFriend&quot;) then
&#9;&#9;if (pPlay:IsBestFriendsWith(doorOwnerId)) then
&#9;&#9;&#9;debug(pPlay.Name .. &quot; is best friends with &quot; .. doorOwnerId)
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;debug(&quot;player &quot; .. pPlay.Name .. &quot; is NOT best friends with &quot; .. doorOwnerId)
&#9;&#9;end
&#9;elseif(mode.Value == &quot;group&quot;) then
&#9;&#9;if (pPlay:IsInGroup(doorOwnerId)) then
&#9;&#9;&#9;debug(pPlay.Name .. &quot; is in group &quot; .. doorOwnerId)
&#9;&#9;&#9;return true
&#9;&#9;else
&#9;&#9;&#9;debug(pPlay.Name .. &quot; is NOT in group &quot; .. doorOwnerId)
&#9;&#9;end
&#9;end
&#9;return false
end

function touchEvent(part)
&#9;print(&quot;touchEvent&quot;)
&#9;if (part ~= door1 and part ~= door2) then
&#9;&#9;if (testPermission(part)) then
&#9;&#9;&#9;if not isOpen then
&#9;&#9;&#9;&#9;doorOpen()
&#9;&#9;&#9;&#9;wait(doorOpenTime)
&#9;&#9;&#9;&#9;doorClose()
&#9;&#9;&#9;end
&#9;&#9;end
&#9;end
end

function changedEvent(prop)
&#9;-- Only interested in CFrame (position + rotation) changes
&#9;if(prop ~= &quot;CFrame&quot;) then return end
&#9;print(&quot;positionChangedEvent()&quot;)
&#9;targetPos = underDoors.Position
&#9;door1bp.position = side2.Position
&#9;door2bp.position = side1.Position
&#9;a = underDoors.CFrame.lookVector
&#9;lookVector = Vector3.new( math.abs(a.x), math.abs(a.y), math.abs(a.z) )
&#9;setDoorForces()
end

wedge1.Touched:connect(touchEvent)
wedge2.Touched:connect(touchEvent)
door1.Touched:connect(touchEvent)
door2.Touched:connect(touchEvent)
underDoors.Changed:connect(changedEvent)

changedEvent(&quot;CFrame&quot;) -- Fire once to initialize
doorClose()

print(&quot;Events added.&quot;)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX200">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ScriptFT</string>
				<ProtectedString name="Source">function waitForChild(parent, child)
&#9;while not parent:FindFirstChild(child) do parent.ChildAdded:wait() end
end

local thisModel = script.Parent.Parent


local off_time = 0
local thread_running = false

waitForChild(thisModel, &quot;FireSmoke&quot;)
waitForChild(thisModel, &quot;Flamethrower&quot;)
local FIRESMOKE = thisModel.FireSmoke
local BASE = thisModel.Flamethrower
local EXTENTCHECK1 = Vector3.new(-2, -2, -2.5)
local EXTENTCHECK2 = Vector3.new(2, 2, -7.5)

function mix(v1, v2, fn)
&#9;return Vector3.new(fn(v1.x, v2.x), fn(v1.y, v2.y), fn(v1.z, v2.z))
end

-- init fire and smoke (we don&apos;t save these for state bug fix)
local fire = Instance.new(&quot;Fire&quot;)
fire.Color = Color3.new(1,128/255,0)
fire.Enabled = false
fire.Heat = 25
fire.Name = &quot;Fire&quot;
fire.SecondaryColor = Color3.new(1,0,0)
fire.Size = 5
fire.Archivable = false
fire.Parent = FIRESMOKE

local smoke = Instance.new(&quot;Smoke&quot;)
smoke.Color = Color3.new(95/255,95/255,95/255)
smoke.Enabled = false
smoke.Opacity = 0.2
smoke.Name = &quot;Smoke&quot;
smoke.RiseVelocity = 10
smoke.Size = 1
smoke.Archivable = false
smoke.Parent = FIRESMOKE

-- get player&apos;s base plate, if possible
local playerArea = thisModel.Parent
local playerBasePlate = nil
local minBoundsVect = nil
local maxBoundsVect = nil
if playerArea.Name == &quot;PlayerArea&quot; then
&#9;playerBasePlate = playerArea:FindFirstChild(&quot;BasePlate&quot;)
&#9;if not playerBasePlate and playerArea.Parent then playerBasePlate = playerArea.Parent:FindFirstChild(&quot;BasePlate&quot;) end

&#9;if playerBasePlate then
&#9;&#9;extent1 = playerBasePlate.CFrame:pointToWorldSpace(-playerBasePlate.Size/2)
&#9;&#9;extent2 = playerBasePlate.CFrame:pointToWorldSpace(playerBasePlate.Size/2)
&#9;&#9;minBoundsVect = mix(extent1, extent2, math.min)
&#9;&#9;minBoundsVect = Vector3.new(minBoundsVect.x, -1000, minBoundsVect.z)
&#9;&#9;maxBoundsVect = mix(extent1, extent2, math.max)
&#9;&#9;maxBoundsVect = Vector3.new(maxBoundsVect.x, 1000, maxBoundsVect.z)
&#9;end
end

function damageHumanoids()
&#9;local hitHumanoids = {}
&#9;local extent1 = BASE.CFrame:pointToWorldSpace(EXTENTCHECK1)
&#9;local extent2 = BASE.CFrame:pointToWorldSpace(EXTENTCHECK2)
&#9;local region3 = nil
&#9;if playerBasePlate then 
&#9;&#9;region3 = Region3.new(
&#9;&#9;&#9;mix(mix(extent1, extent2, math.min), minBoundsVect, math.max),
&#9;&#9;&#9;mix(mix(extent1, extent2, math.max), maxBoundsVect, math.min))
&#9;else
&#9;&#9;region3 = Region3.new(
&#9;&#9;&#9;mix(extent1, extent2, math.min),
&#9;&#9;&#9;mix(extent1, extent2, math.max))
&#9;end

&#9;local parts = game.Workspace:FindPartsInRegion3(region3, thisModel)
&#9;for idx, part in ipairs(parts) do
&#9;&#9;local humanoid = part.Parent:FindFirstChild(&quot;Humanoid&quot;)
&#9;&#9;if humanoid and humanoid:IsA(&quot;Humanoid&quot;) then
&#9;&#9;&#9;hitHumanoids[humanoid] = true
&#9;&#9;end
&#9;end
&#9;for humanoid, unused in pairs(hitHumanoids) do
&#9;&#9;humanoid:TakeDamage(49.5)
&#9;end
end

function monitorFire()
&#9;thread_running = true
&#9;while time() &lt;= off_time do
&#9;&#9;damageHumanoids()
&#9;&#9;wait(0.25)
&#9;end
&#9;FIRESMOKE.Fire.Enabled = false
&#9;FIRESMOKE.Smoke.Enabled = false
&#9;thread_running = false
end

script.Parent.Fire.SourceValueChanged:connect(function(val)
&#9;if val == 0 then return end
&#9;FIRESMOKE.Fire.Enabled = true
&#9;FIRESMOKE.Smoke.Enabled = true
&#9;off_time = time() + 4
&#9;if not thread_running then
&#9;&#9;delay(0, monitorFire)
&#9;end
end)

script.Parent.Parent.AncestryChanged:connect(function(child,parent)
&#9;if parent == nil then
&#9;&#9;FIRESMOKE.Fire.Enabled = false
&#9;&#9;FIRESMOKE.Smoke.Enabled = false
&#9;end
end)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX201">
			<Properties>
				<bool name="Disabled">true</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ScriptHashWhitelistMaker</string>
				<ProtectedString name="Source">-- registers stampable models with the insert service on the server side of things
local baseUrl = string.lower(game:GetService(&quot;ContentProvider&quot;).BaseUrl)
local isGametest = string.find(baseUrl,&quot;gametest&quot;)
local userIdsForStamperParts = {11744447,2409156}

if isGametest then
&#9;table.insert(userIdsForStamperParts,28215009)
&#9;table.insert(userIdsForStamperParts,28215010)
&#9;table.insert(userIdsForStamperParts,28220612)
&#9;table.insert(userIdsForStamperParts,28220614)
else
&#9;table.insert(userIdsForStamperParts,18881789)
&#9;table.insert(userIdsForStamperParts,18881808)
&#9;table.insert(userIdsForStamperParts,19238067)
&#9;table.insert(userIdsForStamperParts,19238114)
end

local userData = {}
local newTable = {}

local newHint = Instance.new(&quot;Message&quot;)
newHint.Text = &quot;Creating Script Hash Whitelist&quot;
newHint.Parent = game.Workspace

function getAllScriptHashes(model, myTable)
&#9;if not model then return end
&#9;if model:IsA(&quot;Script&quot;) or model:IsA(&quot;LocalScript&quot;) then
&#9;&#9;--table.insert(myTable, model:GetHash())
&#9;&#9;myTable[model:GetHash()] = true
&#9;end

&#9;-- recuRsion!  the big R stands for &quot;recuRsion&quot;
&#9;local mc = model:GetChildren()
&#9;for i = 1, #mc do
&#9;&#9;getAllScriptHashes(mc[i], myTable)
&#9;end
end

function collectScriptsToApprove(id)
&#9;local newThing = game:GetService(&quot;InsertService&quot;):LoadAsset(id)
&#9;getAllScriptHashes(newThing, newTable)
end


for i = 1, #userIdsForStamperParts do
&#9;local newUserData = game:GetService(&quot;InsertService&quot;):GetUserCategories(userIdsForStamperParts[i])
&#9;if newUserData and #newUserData &gt; 0 then
&#9;&#9;for j = 1, #newUserData do
&#9;&#9;&#9;table.insert(userData, newUserData[j])
&#9;&#9;end
&#9;end
end


local counter = 0

print(&quot;Registering script hashes.&quot;)

-- register all the good hashes :)
for index, object in pairs(userData) do
&#9;local tempSet = game:GetService(&quot;InsertService&quot;):GetCollection(object.CategoryId)
&#9;for sIndex, sObject in pairs(tempSet) do
&#9;&#9;counter = counter + 1
&#9;&#9;
&#9;&#9;local assetId = sObject.AssetId
&#9;&#9;collectScriptsToApprove(assetId)
&#9;end
end

local counter2 = 0
local newHashString = Instance.new(&quot;StringValue&quot;)
newHashString.Name = &quot;ScriptHashWhitelist&quot;
newHashString.Value = &quot;&quot;
newHashString.Parent = game.Lighting

for i,j in pairs(newTable) do
&#9;counter2 = counter2 + 1
&#9;print(counter2)
&#9;print(i)
&#9;if counter2 == 1 then newHashString.Value = newHashString.Value .. i
&#9;else newHashString.Value = newHashString.Value .. &quot;;&quot; .. i end
end

print(&quot;Registered &quot; .. tostring(counter2) .. &quot; scripts from &quot; .. tostring(counter) .. &quot; assets.&quot;)
newHint:Remove()
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX202">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">ScriptSSS</string>
				<ProtectedString name="Source">function waitForChild(instance, name)
&#9;while not instance:FindFirstChild(name) do
&#9;&#9;instance.ChildAdded:wait()
&#9;end
end


local trigger = script.Parent

waitForChild(script.Parent,&quot;Configuration&quot;)
waitForChild(script.Parent.Configuration,&quot;Trigger Reset Time&quot;)
local resetTime = script.Parent.Configuration:FindFirstChild(&quot;Trigger Reset Time&quot;)

trigger.CanCollide = false

local triggerDebounce = false
trigger.Touched:connect(function (hit)
&#9;if triggerDebounce then return end

&#9;triggerDebounce = true
&#9;trigger.Triggered:SetValue(1.0)
&#9;wait(resetTime.Value - 0.1)
&#9;trigger.Triggered:SetValue(0)
&#9;wait(0.1) -- to stop value from being immediately reset
&#9;triggerDebounce = false
end)

-- Remove decals
waitForChild(script.Parent, &quot;Decal1&quot;)
waitForChild(script.Parent, &quot;Decal2&quot;)
waitForChild(script.Parent, &quot;Decal3&quot;)
waitForChild(script.Parent, &quot;Decal4&quot;)
script.Parent.Decal1:Remove()
script.Parent.Decal2:Remove()
script.Parent.Decal3:Remove()
script.Parent.Decal4:Remove()
script.Parent.Transparency = 1</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX203">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SpikeControlScript</string>
				<ProtectedString name="Source">-- V2

print(&quot;Starting SpikeControlScript&quot;)

-- offset should be between .1 and 1 inclusive, speed should be integer (0 for no movement, 1 for instant, 9 is decent speed), and delay is number of seconds to wait between shifts (so like 5, 3, or 1 for very fast are all good numbers)

local forceField = script.Parent
local SpikeModel = forceField.Parent
local box = SpikeModel.Box

local debris = game:GetService(&quot;Debris&quot;)

--local forceFieldExtent = 9.29 - 5.8 -- forceField should extend by this amount past box when stretched to its fullest extent
--local spikeExtent = 9.61 - 5.8 -- spikes should extend by this amount past box when stretched to their fullest extent
--local spikeExtent = 9.61 - 5.5
local spikeExtent = 9.61 - 5.8

local spikeWeld = box:FindFirstChild(&quot;SpikeWeld&quot;)
if spikeWeld == nil then
&#9;spikeWeld = Instance.new(&quot;ManualWeld&quot;)
&#9;spikeWeld.Name = &quot;SpikeWeld&quot;
&#9;spikeWeld.Part0 = box
&#9;spikeWeld.Part1 = forceField
&#9;spikeWeld.C0 = CFrame.new() + Vector3.new(0,1,0)*(spikeExtent - 3.75*0)
&#9;spikeWeld.Parent = box
end

local parts = SpikeModel:GetChildren()

local heightFactor = 1
local config = SpikeModel:FindFirstChild(&quot;Configuration&quot;)

local spikesDown = false

print(&quot;Finished Declarations&quot;)

function onTouched(hit)
&#9;if spikesDown then return end
&#9;if hit == nil then return end
&#9;if hit.Name == &quot;Right Arm&quot; or hit.Name == &quot;Left Arm&quot; then return end

&#9;local human = hit.Parent:findFirstChild(&quot;Humanoid&quot;)&#9;
&#9;if human and human:IsA(&quot;Humanoid&quot;) then&#9;&#9;human:TakeDamage(100)
&#9;end
end
script.Parent.Touched:connect(onTouched)


--box.Anchored = true
--forceField.Anchored = true


print(&quot;Configuring Speed&quot;)

local dh = 1/9
if config ~= nil and config:FindFirstChild(&quot;Speed&quot;) ~= nil then 
&#9;if config.Speed.Value == 0 then dh = .1
&#9;else dh = 1/config.Speed.Value end
end

print(&quot;Configuring Delay&quot;)

local waitTime = 3
if config ~= nil and config:FindFirstChild(&quot;Delay&quot;) ~= nil then waitTime = config.Delay.Value end

if config ~= nil and config:FindFirstChild(&quot;Offset&quot;) ~= nil then 
&#9;totalTime = waitTime*2+2*.05*math.ceil(0.9/dh)
&#9;offset = config.Offset.Value
&#9;startTime = offset*totalTime
&#9;if offset == 1 then offset = 0 end
&#9;if startTime &lt;= waitTime then
&#9;&#9;wait(waitTime - startTime + .05)
&#9;&#9;dh = -dh
&#9;&#9;heightFactor = 1 + dh
&#9;elseif startTime &lt; waitTime+.05*math.ceil(0.9/dh) then
&#9;&#9;dh = -dh
&#9;&#9;numItersToSkip = math.floor((startTime - waitTime)/.05)
&#9;&#9;heightFactor = 1 + dh*numItersToSkip
&#9;&#9;extraTime = startTime - waitTime - numItersToSkip*.05
&#9;&#9;wait(extraTime) -- wait the extra
&#9;elseif startTime &lt;= waitTime*2 + .05*math.ceil(0.9/dh) then
&#9;&#9;timeToWait = startTime - waitTime - .05*math.ceil(0.9/dh)
&#9;&#9;spikesDown = true
&#9;&#9;wait(waitTime - timeToWait + .05)
&#9;&#9;heightFactor = 0.1 + dh
&#9;&#9;spikesDown = false
&#9;else
&#9;&#9;timeIntoIters = startTime - waitTime*2 - .05*math.ceil(0.9/dh)
&#9;&#9;numItersToSkip = math.floor(timeIntoIters/.05)
&#9;&#9;heightFactor = 0.1 + dh*numItersToSkip
&#9;&#9;extraTime = timeIntoIters - numItersToSkip*.05
&#9;&#9;wait(extraTime)
&#9;end

if config ~= nil and config:FindFirstChild(&quot;Speed&quot;) ~= nil then 
&#9;if config.Speed.Value == 0 then dh = 0 end
end

&#9;--heightFactor = config.Offset.Value 
end

print(&quot;Starting Loop&quot;)

local smallVector = Vector3.new(0,0.001,0)

local loopGo = true
while loopGo do
&#9;if heightFactor &gt;= 1 or heightFactor &lt;= 0.1 then 
&#9;&#9;if heightFactor &lt;= 0.1 then spikesDown = true end
&#9;&#9;print(&quot;end of animation.  Waiting.&quot;)
&#9;&#9;wait(waitTime)
&#9;&#9;if heightFactor &lt;= 0.1 then 
&#9;&#9;&#9;spikesDown = false 
&#9;&#9;&#9;--altForceField = forceField:Clone()
&#9;&#9;&#9;--altForceField.SpikeControlScript.Disabled = true
&#9;&#9;&#9;--altForceField.SpikeScript.Disabled = false
&#9;&#9;&#9;--altForceField.Parent = SpikeModel
&#9;&#9;&#9;--debris:AddItem(altForceField, 1)
&#9;&#9;end
&#9;&#9;dh = -dh 
&#9;end
&#9;heightFactor = heightFactor + dh
&#9;wait(.05)
&#9;--for i = 1, #parts do
&#9;&#9;--currPart = parts[i]
&#9;--&#9;currPart.Anchored = true
&#9;&#9;--if currPart:FindFirstChild(&quot;Mesh&quot;) ~= nil then
&#9;&#9;&#9;--currPart.CFrame = box.CFrame + currPart.CFrame:vectorToWorldSpace(Vector3.new(0,1,0)).unit*(spikeExtent - 3.75*(1-heightFactor))
--&#9;&#9;end
--&#9;end

&#9;--spikeWeld.C0 = forceField.CFrame:inverse()*(box.CFrame + box.CFrame:vectorToWorldSpace(Vector3.new(0,1,0)).unit*(spikeExtent - 3.75*(1-heightFactor)))
&#9;--spikeWeld.C0 = CFrame.new() + box.CFrame:vectorToWorldSpace(Vector3.new(0,1,0)).unit*(spikeExtent - 3.75*(2-heightFactor))
&#9;if spikeWeld == nil or spikeWeld.Parent == nil then debris:AddItem(SpikeModel, 15) loopGo = false
&#9;else 
&#9;&#9;spikeWeld.C0 = CFrame.new() + Vector3.new(0,1,0)*(spikeExtent - 3.75 * (1-heightFactor))
&#9;&#9;--box.CFrame = box.CFrame+Vector3.new(0,0,.01*math.random()-.005)
&#9;&#9;forceField.Mesh.VertexColor = Vector3.new(1-heightFactor*.01, 1-heightFactor*.01, 1-heightFactor*.01)
&#9;end
end

print(&quot;got here&quot;)
</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX204">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SpikeScript</string>
				<ProtectedString name="Source">-- useless comment

function onTouched(hit)
&#9;if not hit or not hit.Parent then return end
&#9;local human = hit.Parent:findFirstChild(&quot;Humanoid&quot;)
&#9;if human and human:IsA(&quot;Humanoid&quot;) then&#9;&#9;human:TakeDamage(100)
&#9;end
end
script.Parent.Touched:connect(onTouched)</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX205">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">SwitchScript</string>
				<ProtectedString name="Source">--





sp=script.Parent

sp.ClickDetector.MouseClick:connect(function()
&#9;sp.OnOff.Value=not sp.OnOff.Value
&#9;if sp.OnOff.Value then
&#9;&#9;sp.LightSwitch:SetValue(1)
&#9;&#9;sp.SwitchWeld.C1=CFrame.Angles(.8,0,0)
&#9;else
&#9;&#9;sp.LightSwitch:SetValue(0)
&#9;&#9;sp.SwitchWeld.C1=CFrame.Angles(-.8,0,0)
&#9;end
end)




</ProtectedString>
			</Properties>
		</Item>
		<Item class="Script" referent="RBX206">
			<Properties>
				<bool name="Disabled">false</bool>
				<Content name="LinkedSource"><null></null></Content>
				<string name="Name">TimerScript</string>
				<ProtectedString name="Source">--Stickmasterluke


sp=script.Parent

numberids={59518377,59518402,59518433,59518457,59518480,59518522,59518607,59518632,59518651,59518670}
flashingtime=5

running=false
timer=math.ceil(sp.Configuration.Timer.Value)

function updatedisplay()
&#9;d4=timer%10
&#9;d3=math.floor((timer%60)/10)
&#9;d2=math.floor(timer/60)%10
&#9;d1=math.floor(timer/600)%10
&#9;sp.Timer1.Decal.Texture=&quot;http://www.pengin.xyz/asset?id=&quot;..tostring(numberids[d1+1])
&#9;sp.Timer2.Decal.Texture=&quot;http://www.pengin.xyz/asset?id=&quot;..tostring(numberids[d2+1])
&#9;sp.Timer3.Decal.Texture=&quot;http://www.pengin.xyz/asset?id=&quot;..tostring(numberids[d3+1])
&#9;sp.Timer4.Decal.Texture=&quot;http://www.pengin.xyz/asset?id=&quot;..tostring(numberids[d4+1])
end

function colortimer(clr)
&#9;for i,v in ipairs(sp:GetChildren()) do
&#9;&#9;if v.Name==&quot;Color&quot; or v.Name==&quot;Part&quot; or v.Name==&quot;Wedge&quot; then
&#9;&#9;&#9;v.BrickColor=BrickColor.new(clr)
&#9;&#9;end
&#9;end
end

function countdown()
&#9;if not running then
&#9;&#9;running=true
&#9;&#9;timer=math.ceil(sp.Configuration.Timer.Value)
&#9;&#9;colortimer(&quot;Black&quot;)
&#9;&#9;while running and timer&gt;0 do
&#9;&#9;&#9;if timer&lt;=flashingtime then--and timer%2==1 then
&#9;&#9;&#9;&#9;local flashtimes=(flashingtime-timer)+1
&#9;&#9;&#9;&#9;if flashtimes%2==1 then
&#9;&#9;&#9;&#9;&#9;flashtimes=flashtimes+1
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;local a=0
&#9;&#9;&#9;&#9;for i=1,flashtimes do
&#9;&#9;&#9;&#9;&#9;a=a+1
&#9;&#9;&#9;&#9;&#9;if a%2==1 then
&#9;&#9;&#9;&#9;&#9;&#9;colortimer(&quot;Really red&quot;)
&#9;&#9;&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;&#9;&#9;colortimer(&quot;Black&quot;)
&#9;&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;&#9;&#9;wait(1/flashtimes)
&#9;&#9;&#9;&#9;end
&#9;&#9;&#9;else
&#9;&#9;&#9;&#9;wait(1)
&#9;&#9;&#9;end
&#9;&#9;&#9;timer=timer-1
&#9;&#9;&#9;updatedisplay()
&#9;&#9;end
&#9;&#9;colortimer(&quot;Black&quot;)
&#9;&#9;sp.Antenna.TimerOutput:SetValue(1)
&#9;&#9;sp.Antenna.BrickColor=BrickColor.new(&quot;Really red&quot;)
&#9;&#9;wait(sp.Configuration.OutputTime.Value)
&#9;&#9;sp.Antenna.BrickColor=BrickColor.new(&quot;Really black&quot;)
&#9;&#9;sp.Antenna.TimerOutput:SetValue(0)
&#9;&#9;running=false
&#9;&#9;check(sp.Antenna.StartTimer:GetCurrentValue())
&#9;end
end

function check(val)
&#9;if val&gt;.5 then
&#9;&#9;countdown()
&#9;else
&#9;&#9;--No going back. Lol
&#9;end
end

sp.Configuration.Timer.Changed:connect(function()
&#9;timer=math.ceil(sp.Configuration.Timer.Value)
&#9;updatedisplay()
end)

for i,v in ipairs(sp:GetChildren()) do
&#9;if v.Name==&quot;Color&quot; then
&#9;&#9;v.BrickColor=BrickColor.new(&quot;Black&quot;)
&#9;end
end
sp.Antenna.BrickColor=BrickColor.new(&quot;Really black&quot;)

sp.Antenna.TimerOutput:SetValue(0)
sp.Antenna.StartTimer.SourceValueChanged:connect(check)
check(sp.Antenna.StartTimer:GetCurrentValue())
updatedisplay()
</ProtectedString>
			</Properties>
		</Item>
	</Item>
	<Item class="ChangeHistoryService" referent="RBX207">
		<Properties>
			<string name="Name">ChangeHistoryService</string>
		</Properties>
	</Item>
</roblox>